 --- srcref --- 
 at /tmp/RtmpyXFw4U/R.INSTALL2bf1c54e32b46/geoR/R/variofit.R#658: 
 --- call (function) --- 
variog.model.env(s100, obj.variog = s100.vario, model = s100.ml)
 --- stacktrace ---
where 1: variog.model.env(s100, obj.variog = s100.vario, model = s100.ml)

 --- value of length: 2 type: logical ---
[1] FALSE FALSE
 --- function --- 
function(geodata, coords = geodata$coords, obj.variog,
           model.pars, nsim = 99, save.sim = FALSE, messages) 
{
  call.fc <- match.call()
  obj.variog$v <- NULL
  if(missing(messages))
    messages.screen <- as.logical(ifelse(is.null(getOption("geoR.messages")), TRUE, getOption("geoR.messages")))
  else messages.screen <- messages
  ##
  ## reading input
  ##
  if(class(model.pars) == "eyefit"){
    if(length(model.pars) == 1L)
      model.pars <- model.pars[[1]]
    else
      stop(paste("variog.model.env: more than one variograma model in the object",
                 deparse(substitute(model.pars)), "\n  specify which i_th model in the list to be used using [[i]]"))
  }
  if(!is.null(model.pars$beta)) beta <- model.pars$beta
  else beta <- 0
  if(!is.null(model.pars$cov.model))
    cov.model <- model.pars$cov.model
  else cov.model <- "exponential"
  if(!is.null(model.pars$kappa)) kappa <- model.pars$kappa
  else kappa <- 0.5
  #if(!is.null(model.pars$lambda)) lambda <- model.pars$lambda
  #else lambda <- 0.5
  if(!is.null(model.pars$nugget)) nugget <- model.pars$nugget
  else nugget <- 0
  cov.pars <- model.pars$cov.pars
  if(!is.null(obj.variog$estimator.type))
    estimator.type <- obj.variog$estimator.type
  else estimator.type <- "classical"
  if (obj.variog$output.type != "bin") 
    stop("envelops can be computed only for binned variogram")
  ##
  ## generating simulations from the model with parameters provided
  ##
  if (messages.screen) 
    cat(paste("variog.env: generating", nsim, "simulations (with ",
              obj.variog$n.data, 
              "points each) using the function grf\n"))
#  simula <- grf(obj.variog$n.data, grid = as.matrix(coords),
#                cov.model = cov.model, cov.pars = cov.pars,
#                nugget = nugget, kappa = kappa, nsim = nsim,
#                messages = FALSE, lambda = obj.variog$lambda)
  simula <- grf(obj.variog$n.data, grid = as.matrix(coords),
                cov.model = cov.model, cov.pars = cov.pars,
                nugget = nugget, kappa = kappa, nsim = nsim,
                messages = FALSE)
  ##
  ## add the mean
  ##
  if(messages.screen)
    cat("variog.env: adding the mean or trend\n")
  x.mat <- unclass(trend.spatial(trend=obj.variog$trend, geodata = geodata))
  if(ncol(x.mat) != length(beta))
    stop("incompatible sizes of trend matrix and beta parameter vector. Check whether the trend specification are the same in the objects passed to the arguments \"obj.vario\" and \"model.pars\"")
  simula$data <- as.vector(x.mat %*% beta) + simula$data
  ##
  ## computing empirical variograms for the simulations
  ##
  if (messages.screen) 
    cat(paste("variog.env: computing the empirical variogram for the", 
              nsim, "simulations\n"))
  nbins <- length(obj.variog$bins.lim) - 1
  bin.f <- function(sim){
    cbin <- vbin <- sdbin <- rep(0, nbins)  
    temp <- .C("binit",
               as.integer(obj.variog$n.data),
               as.double(as.vector(coords[,1])),
               as.double(as.vector(coords[,2])),
               as.double(as.vector(sim)),
               as.integer(nbins),
               as.double(as.vector(obj.variog$bins.lim)),
               as.integer(estimator.type == "modulus"),
               as.double(max(obj.variog$u)),
               as.double(cbin),
               vbin = as.double(vbin),
               as.integer(FALSE),
               as.double(sdbin),
               PACKAGE = "geoR")$vbin
    return(temp)
  }
  simula.bins <- apply(simula$data, 2, bin.f)
  simula.bins <- simula.bins[obj.variog$ind.bin,]
  if(exists(".IND.geoR.variog.model.env", where=1))
    return(simula.bins)
  if(save.sim == FALSE) simula$data <- NULL
  ##
  ## computing envelops
  ##
  if (messages.screen) 
    cat("variog.env: computing the envelops\n")
  limits <- apply(simula.bins, 1, range)
  res.env <- list(u = obj.variog$u, v.lower = limits[1, ],
                  v.upper = limits[2,])
  if(save.sim)
    res.env$simulated.data <- simula$data
  res.env$call <- call.fc
  oldClass(res.env) <- "variogram.envelope"
  return(res.env)
}
<environment: namespace:geoR>
 --- function (body) search ---
Function variog.model.env in namespace geoR has this body.
