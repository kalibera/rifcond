
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library("RObsDat")
Loading required package: zoo

Attaching package: 'zoo'

The following objects are masked from 'package:base':

    as.Date, as.Date.numeric

> if(require(testthat)){
+ 	test_package("RObsDat")
+ } else {
+ }
Loading required package: testthat
Not testing example on PostgreSQL. Use 'options(testPostgreSQL = TRUE)' to do so
Not testing example on MySQL. Use 'options(testMySQL = TRUE)' to do so
SQLite
SQLite file initiated
Not testing long example. Use 'options(testLongExample = TRUE)' to do so
SQLite example processed
Exiting and deleting RODM.db
Not testing long example on PostgreSQL. Use 'options(testLongExample = TRUE, testPostgreSQL = TRUE)' to do so
Not testing long example on MySQL. Use 'options(testLongExample = TRUE, testMySQL = TRUE)' to do so

addDtV> #connect to database
addDtV> getDefaultDB()
Connection closed

addDtV> ## Not run: 
addDtV> ##D #connect to postgreSQL database
addDtV> ##D require("RObsDat")
addDtV> ##D require("RPostgreSQL")
addDtV> ##D m <- dbDriver("PostgreSQL")
addDtV> ##D con <- dbConnect(m, user="a_user", password="secret", dbname="obsdat")
addDtV> ##D sqhandler <-  new("odm1_1Ver", con=con)
addDtV> ##D options(odm.handler=sqhandler)
addDtV> ##D 
addDtV> ##D #connect to MySQL database
addDtV> ##D require("RObsDat")
addDtV> ##D require("RMySQL")
addDtV> ##D m <- dbDriver("MySQL")
addDtV> ##D con <- dbConnect(m, user="a_user", password="secret", dbname="obsdat")
addDtV> ##D sqhandler <-  new("odm1_1Ver", con=con)
addDtV> ##D options(odm.handler=sqhandler)
addDtV> ##D 
addDtV> ##D #connect to SQLite database
addDtV> ##D require("RObsDat")
addDtV> ##D require("RSQLite")
addDtV> ##D m <- dbDriver("SQLite")
addDtV> ##D dbname = "database.db"
addDtV> ##D con <- dbConnect(m, dbname = dbname)
addDtV> ##D sqhandler <-  new("odm1_1Ver", con=con)
addDtV> ##D options(odm.handler=sqhandler)
addDtV> ##D 
addDtV> ## End(Not run)
addDtV> 
addDtV> #Store metadata in database
addDtV> addSite(Code="test", Name="Virtual test site", x=-5, y=46,
addDtV+ 	LatLongDatum="WGS84", Elevation=1500, State="Germany")

addDtV> addVariable(Name="Distance", Unit="cm", ValueType="Field Observation",
addDtV+ 	GeneralCategory="Instrumentation", Code="test_dist")

addDtV> addQualityControlLevel(ID=6,Code="test_ok", Definition="The default")

addDtV> addISOMetadata(TopicCategory="Unknown", Title="Testdata",
addDtV+ 	Abstract="This data is created to test the functions of RObsDat")

addDtV> addSource(Organization="Your Org", SourceDescription="Madeup data", 
addDtV+ 	SourceLink="RObsDat Documentation", ContactName="Yourself",
addDtV+ 	Metadata="Testdata")

addDtV> library(xts)

addDtV> library(spacetime)

addDtV> example.data <- xts(1:40, seq(as.POSIXct("2014-01-01", tz="UTC"), 
addDtV+ 		as.POSIXct("2014-02-09", tz="UTC"), length.out=40))

addDtV> example.data[40] <- 30

addDtV> example.data[35] <- 22

addDtV> addDataValues(example.data[1:20], Site="Virtual test site", Variable="test_dist",  
addDtV+ 	Source="Madeup", QualityControlLevel="test_ok")
Importing column  1 out of 1 

addDtV> #Avoid duplicates automatically
addDtV> example.data[15] <- 30

addDtV> addDataValues(example.data, Site="Virtual test site", Variable="test_dist",  
addDtV+ 	Source="Madeup", QualityControlLevel="test_ok")
Importing column  1 out of 1 

addDtV> inDB <- getDataValues(Site="test")

addDtV> stplot(inDB, mode="ts")

addDtV> #Version management
addDtV> inDB <- getDataValues(Site="test")

addDtV> to.correct <- which(inDB@data > 30)

addDtV> inDB@data[to.correct,] <- 20

addDtV> if(NROW(inDB@data)>=30){
addDtV+    inDB@data[30,] <- 32
addDtV+    updateDataValues(inDB, "Correction of wrong value")
addDtV+ }
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpqTXawT/R.INSTALL20b866ec0630/RObsDat/R/sv.R#9: 
 --- if/while statement is in package --- 
RObsDat
 --- call (currently evaluated) --- 
sv(getDataResult@DerivedFromIDs@data[selectMeta])
 --- R stacktrace ---
where 1: sv(getDataResult@DerivedFromIDs@data[selectMeta])
where 2 at /var/scratch2/tomas/tmp/RtmpqTXawT/R.INSTALL20b866ec0630/RObsDat/R/odm1_1.R#570: paste("UPDATE DataValues SET DataValue = \"", value, "\", ValueAccuracy = ", 
    valueAccuracy, ", LocalDateTime = \"", localDateTime, "\", UTCOffset = \"", 
    tz2offset(TZ), "\", DateTimeUTC = \"", strftime(localDateTime, 
        tz = TZ), "\", SiteID = ", SiteID, ", VariableID = ", 
    VariableID, ", OffsetValue = ", Offset, ", OffsetTypeID = ", 
    OffsetTypeID, ", CensorCode = \"", CensorCode, "\", QualifierID = ", 
    QualifierID, ", MethodID = ", MethodID, ", SourceID = ", 
    SourceID, ", SampleID = ", SampleID, ", DerivedFromID = ", 
    DerivedFromID, ", QualityControlLevelID = ", QualityControlLevelID, 
    " WHERE ValueID = ", ValueID, sep = "")
where 3: .local(object, ValueID, localDateTime, value, TZ, SiteID, VariableID, 
    Offset, OffsetTypeID, CensorCode, QualifierID, MethodID, 
    SourceID, SampleID, DerivedFromID, QualityControlLevelID, 
    ...)
where 4 at /var/scratch2/tomas/tmp/RtmpqTXawT/R.INSTALL20b866ec0630/RObsDat/R/odm1_1.R#50: IupdateDataValues(obj, ValueID = rec.id, localDateTime = index(getDataResult@time[the.row, 
    ]), value = sv(coredata(getDataResult@data[the.row, ])), 
    valueAccuracy = sv(getDataResult@Metadata$Valueaccuracy[selectMeta]), 
    TZ = the.tz, SiteID = getID("Site", getDataResult@Metadata$site[selectMeta]), 
    VariableID = getID("Variable", getDataResult@Metadata$variable[selectMeta]), 
    Offset = sv(getDataResult@Metadata$offsetvalue[selectMeta]), 
    OffsetTypeID = getID("OffsetType", getDataResult@Metadata$offsettype[selectMeta]), 
    CensorCode = sv(getDataResult@Metadata$censorcode[selectMeta]), 
    QualifierID = getID("Qualifier", getDataResult@Metadata$qualifier[selectMeta]), 
    MethodID = getID("Method", getDataResult@Metadata$method[selectMeta]), 
    SourceID = getID("Source", getDataResult@Metadata$source[selectMeta]), 
    SampleID = getID("Sample", getDataResult@Metadata$sample[selectMeta]), 
    DerivedFromID = sv(getDataResult@DerivedFromIDs@data[selectMeta]), 
    QualityControlLevelID = getID("QualityControlLevel", getDataResult@Metadata$qualitycontrollevel[selectMeta]))
where 5 at /var/scratch2/tomas/tmp/RtmpqTXawT/R.INSTALL20b866ec0630/RObsDat/R/updateDataValues.R#33: IupdateDataValues(obj, ValueID = rec.id, localDateTime = index(getDataResult@time[the.row, 
    ]), value = sv(coredata(getDataResult@data[the.row, ])), 
    valueAccuracy = sv(getDataResult@Metadata$Valueaccuracy[selectMeta]), 
    TZ = the.tz, SiteID = getID("Site", getDataResult@Metadata$site[selectMeta]), 
    VariableID = getID("Variable", getDataResult@Metadata$variable[selectMeta]), 
    Offset = sv(getDataResult@Metadata$offsetvalue[selectMeta]), 
    OffsetTypeID = getID("OffsetType", getDataResult@Metadata$offsettype[selectMeta]), 
    CensorCode = sv(getDataResult@Metadata$censorcode[selectMeta]), 
    QualifierID = getID("Qualifier", getDataResult@Metadata$qualifier[selectMeta]), 
    MethodID = getID("Method", getDataResult@Metadata$method[selectMeta]), 
    SourceID = getID("Source", getDataResult@Metadata$source[selectMeta]), 
    SampleID = getID("Sample", getDataResult@Metadata$sample[selectMeta]), 
    DerivedFromID = sv(getDataResult@DerivedFromIDs@data[selectMeta]), 
    QualityControlLevelID = getID("QualityControlLevel", getDataResult@Metadata$qualitycontrollevel[selectMeta]))
where 6 at /var/scratch2/tomas/tmp/RtmpwLkDhJ/Rexb543e861877#75: updateDataValues(inDB, "Correction of wrong value")
where 7: eval(ei, envir)
where 8: eval(ei, envir)
where 9: withVisible(eval(ei, envir))
where 10: source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, 
    getOption("prompt")), continue.echo = paste0(prompt.prefix, 
    getOption("continue")), verbose = verbose, max.deparse.length = Inf, 
    encoding = "UTF-8", skip.echo = skips, keep.source = TRUE)
where 11 at /var/scratch2/tomas/test/mine/R-ifc4/lib/RObsDat/tests/test_various.R#8: example(addDataValues)
where 12: eval(code, test_env)
where 13: eval(code, test_env)
where 14: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error)
where 15: doTryCatch(return(expr), name, parentenv, handler)
where 16: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 17: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 18: doTryCatch(return(expr), name, parentenv, handler)
where 19: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
    names[nh], parentenv, handlers[[nh]])
where 20: tryCatchList(expr, classes, parentenv, handlers)
where 21: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error), error = handle_fatal, 
    skip = function(e) {
    })
where 22 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-that.R#31: test_code(desc, code, env = parent.frame())
where 23 at /var/scratch2/tomas/test/mine/R-ifc4/lib/RObsDat/tests/test_various.R#5: test_that("NA data does not produce an error", {
    on.exit({
        cat("Exiting and deleting RODM.db\n")
        unlink("RODM.db")
    })
    example(addDataValues)
    example.data <- xts(c(5, 6, NA), seq(as.POSIXct("2012-01-01", 
        tz = "UTC"), as.POSIXct("2013-01-01", tz = "UTC"), length.out = 3))
    addDataValues(example.data, Site = "test", Variable = "test_dist", 
        Source = "Madeup", QualityControlLevel = "ok")
})
where 24: eval(code, test_env)
where 25: eval(code, test_env)
where 26: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error)
where 27: doTryCatch(return(expr), name, parentenv, handler)
where 28: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 29: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 30: doTryCatch(return(expr), name, parentenv, handler)
where 31: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
    names[nh], parentenv, handlers[[nh]])
where 32: tryCatchList(expr, classes, parentenv, handlers)
where 33: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error), error = handle_fatal, 
    skip = function(e) {
    })
where 34: test_code(NULL, exprs, env)
where 35: source_file(path, new.env(parent = env), chdir = TRUE, wrap = wrap)
where 36 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/reporter-zzz.R#53: force(code)
where 37: with_reporter(reporter = reporter, start_end_reporter = start_end_reporter, 
    {
        lister$start_file(basename(path))
        source_file(path, new.env(parent = env), chdir = TRUE, 
            wrap = wrap)
        end_context()
    })
where 38: FUN(X[[i]], ...)
where 39: lapply(paths, test_file, env = env, reporter = current_reporter, 
    start_end_reporter = FALSE, load_helpers = FALSE, wrap = wrap)
where 40 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/reporter-zzz.R#53: force(code)
where 41 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-files.R#25: with_reporter(reporter = current_reporter, results <- lapply(paths, 
    test_file, env = env, reporter = current_reporter, start_end_reporter = FALSE, 
    load_helpers = FALSE, wrap = wrap))
where 42 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-directory.R#86: test_files(paths, reporter = reporter, env = env, stop_on_failure = stop_on_failure, 
    stop_on_warning = stop_on_warning, wrap = wrap)
where 43 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-directory.R#190: test_dir(path = test_path, reporter = reporter, env = env, filter = filter, 
    ..., stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning, 
    wrap = wrap)
where 44 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-directory.R#136: test_package_dir(package = package, test_path = test_path, filter = filter, 
    reporter = reporter, ..., stop_on_failure = stop_on_failure, 
    stop_on_warning = stop_on_warning)
where 45: test_package("RObsDat")

 --- value of length: 40 type: logical ---
   Distance
1      TRUE
2      TRUE
3      TRUE
4      TRUE
5      TRUE
6      TRUE
7      TRUE
8      TRUE
9      TRUE
10     TRUE
11     TRUE
12     TRUE
13     TRUE
14     TRUE
15     TRUE
16     TRUE
17     TRUE
18     TRUE
19     TRUE
20     TRUE
21     TRUE
22     TRUE
23     TRUE
24     TRUE
25     TRUE
26     TRUE
27     TRUE
28     TRUE
29     TRUE
30     TRUE
31     TRUE
32     TRUE
33     TRUE
34     TRUE
35     TRUE
36     TRUE
37     TRUE
38     TRUE
39     TRUE
40     TRUE
 --- function (currently evaluated)--- 
function(the.vect, rownum=1){ #select variable
	#avoid going beyond the vector.
	#If we have only one entry, we may
	# assume that this is valid for all
	if(length(the.vect)==1) rownum=1

	stopifnot(is.null(the.vect) || rownum <= length(the.vect))

	if(is.null(the.vect)){
		to.ret <- "NULL" 
	} else if(is.na(the.vect[rownum])){
		to.ret <- "NULL" 
	} else {
		to.ret <- the.vect[rownum]
	}
	return(to.ret)
}
<environment: namespace:RObsDat>
 --- function (body) search ---
Function sv in namespace RObsDat has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
