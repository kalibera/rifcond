
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "mixedsde"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('mixedsde')
Loading required package: sde
Loading required package: MASS
Loading required package: stats4
Loading required package: fda
Loading required package: splines
Loading required package: Matrix

Attaching package: ‘fda’

The following object is masked from ‘package:graphics’:

    matplot

Loading required package: zoo

Attaching package: ‘zoo’

The following objects are masked from ‘package:base’:

    as.Date, as.Date.numeric

sde 2.0.15
Companion package to the book
‘Simulation and Inference for Stochastic Differential Equations With R Examples’
Iacus, Springer NY, (2008)
To check the errata corrige of the book, type vignette("sde.errata")
Loading required package: moments
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("mixedsde-package")
> ### * mixedsde-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mixedsde-package
> ### Title: Density estimation in mixed stochastic differential models
> ### Aliases: mixedsde-package mixedsde
> ### Keywords: package
> 
> ### ** Examples
> 
> # Frequentist estimation, two random effects
> 
> model = 'CIR'; M <- 100;  T <- 10 
> delta <- 0.1 # delta <- 0.001 and M <- 200 would yield better results!
> N <- floor(T/delta); sigma <- 0.01
> random <- c(1,2); density.phi <- 'gammainvgamma2'
> param<- c(1.8, 0.8, 8, 0.05);
> simu <- mixedsde.sim(M = M, T = T, N = N, model = model, random = random,
+   density.phi = density.phi, param = param, sigma = sigma, invariant = 1)

T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000


T set to = 10.000000

> X <- simu$X ; phi <- simu$phi; times <- simu$times
> estim.method<- 'nonparam'
> estim <- mixedsde.fit(times = times, X = X, model = model, random = random, 
+    estim.method = 'nonparam')
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpgKi0Uq/R.INSTALLa6e41973e0f/mixedsde/R/mixedsde.fit.R#305: 
 --- if/while statement is in package --- 
mixedsde
 --- call (currently evaluated) --- 
mixedsde.fit(times = times, X = X, model = model, random = random, 
    estim.method = "nonparam")
 --- R stacktrace ---
where 1: mixedsde.fit(times = times, X = X, model = model, random = random, 
    estim.method = "nonparam")

 --- value of length: 2 type: logical ---
[1] FALSE FALSE
 --- function (currently evaluated)--- 
function(times, X, model = c("OU", "CIR"), random, fixed = 0, estim.fix = 0, estim.method = c("nonparam", 
    "paramML", "paramBayes"), gridf = NULL, prior, nMCMC = NULL) {
  
    model <- match.arg(model)
    estim.method <- match.arg(estim.method)
    
    
    if((model != 'OU')&(model != 'CIR')){stop("A model must be precised: OU or CIR")}
    if((random != 1)&(random != 2)&(random !=c(1,2))){stop("random must be precised: 1 or 2 or c(1,2)")}
    if((estim.method != 'nonparam')&(estim.method != 'paramML')&(estim.method !='paramBayes')){stop("estim.method must be precised: paramML or nonparam or paramBayes")}
    
    
    if (is.matrix(X)) {
      
        if (nrow(X) == ncol(X)){warning("X is a square matrix, check that a line of X is a trajectory")}
        if ((nrow(X) == length(times))&(nrow(X) != ncol(X))) {
            X <- t(X)
        } else {
            if (ncol(X) != length(times)) {
                stop("Length of times has to be equal to the columns of X")
            }
        }
    }
    
    M <- dim(X)[1]
    K <- dim(X)[2]
    delta <- round(diff(times), 10)
    Tend <- times[length(times)]
    
    if (estim.method == "paramBayes") {
        if (model == "CIR") {
            if (any(X < 0)) {
                Xold <- X
                indices <- sapply(1:M, function(i) any(X[i, ] < 0))
                X <- X[!indices,  ]
                message("Attention: series", indices, " are skipped for estimation because of negative values")
            }
        }
        
        if (missing(prior)) {
            ind.4.prior <- 1:max(3, ceiling(M/10))
            X.4.prior <- X[ind.4.prior, ]
            estimUV <- UV(X.4.prior, model, random = c(1, 2), fixed = 0, times)  # fixed is only used for random == 1
            U <- estimUV$U
            V <- estimUV$V
            deter <- lapply(V, det)
            index <- which((deter != Inf) & (deter != 0))
            Mindex <- length(index)
            V <- V[index]
            U <- U[, index]
            
            
            if (length(V) == 0) {
                l.prior <- length(ind.4.prior)
                while (length(V) == 0 && max(ind.4.prior) + l.prior - 1 < M) {
                  ind.4.prior <- ind.4.prior + l.prior
                  X.4.prior <- X[ind.4.prior, ]
                  estimUV <- UV(X.4.prior, model, random = c(1, 2), fixed = 0, times)  # fixed is only used for random == 1
                  U <- estimUV$U
                  V <- estimUV$V
                  deter <- lapply(V, det)
                  index <- which((deter != Inf) & (deter != 0))
                  Mindex <- length(index)
                  V <- V[index]
                  U <- U[, index]
                }
            }
            if (length(V) == 0) {
                message("Please specify prior parameters")
                prior <- list(m = c(1, 1), v = c(10, 10), alpha.omega = rep(3, length(random)), beta.omega = rep(10, 
                  length(random)) * 2, alpha.sigma = 3, beta.sigma = 1 * 2)
                message("Parameters are set to: ", unlist(prior))
            } else {
                
                A <- matrix(0, 2, Mindex)
                for (j in 1:Mindex) {
                  A[, j] <- (1/det(V[[j]])) * matrix(c(V[[j]][2, 2], -V[[j]][1, 2], -V[[j]][1, 2], V[[j]][1, 
                    1]), 2, 2) %*% U[, j]
                }
                estimphi <- A
                
                mu <- apply(estimphi, 1, mean)
                Omega <- apply(estimphi, 1, var)
                if (model == "OU") 
                  var.fun <- function(x) 1
                if (model == "CIR") 
                  var.fun <- function(x) x
                
                sigma2 <- mean(sapply(1:Mindex, function(i) mean(diff(X.4.prior[index[i], 2:K])^2 * (1/delta[1:(K - 
                  2)]) * var.fun(1/X.4.prior[index[i], 3:K]))))
                prior <- list(m = mu, v = abs(mu), alpha.omega = rep(3, length(random)), beta.omega = Omega[random] * 
                  2, alpha.sigma = 3, beta.sigma = sigma2 * 2)
                message("attention: series ", ind.4.prior, " are used for prior parameter calculation")
            }
        } else {
            ind.4.prior <- M + 1
        }
        
        res <- BayesianNormal(times, X[-ind.4.prior, ], model, prior, start = list(mu = prior$m, sigma = prior$beta.sigma/(prior$alpha.sigma - 
            1)), random, nMCMC)
        he <- diagnostic(res, random)
        return(new(Class = "Bayes.fit", prior = prior, alpha = as.matrix(res$alpha), beta = as.matrix(res$beta), 
            random = random, mu = as.matrix(res$mu), omega = as.matrix(res$omega), sigma2 = res$sigma2, burnIn = he$burnIn, 
            thinning = he$thinning, model = model, times = times, X = X, ind.4.prior = ind.4.prior))
        
    } else {
        
        if (sum(random) > 2) {
            
            if (missing(fixed) == 0) {
                message("the parameter fixed is not used because random = c(1,2)")
            }
            
            # Estimation of sigma2
            if (model == "OU") {
                
                meanU <- rep(0, M)
                for (i in 1:M) {
                  meanU[i] <- mean((diff(X[i, 2:K])^2) * (1/delta[1:(K - 2)]))
                }
                sigma2 <- mean(meanU)
                Mindex <- M
                index <- 1:Mindex
            }
            if (model == "CIR") {
                
                index <- which(rowSums(X <= 0) == 0)
                Mindex <- length(index)
                if (Mindex == 0) {
                  warning("All the trajectories have non positive values the model CIR cannot be used", call. = FALSE)
                  estimf <- 0
                  estimphi <- 0
                  bic <- 0
                  aic <- 0
                  gridf <- 0
                  mu <- 0
                  omega <- 0
                  cutoff <- 0
                  sigma2 <- 0
                  estimf.trunc <- 0
                  estimphi.trunc <- 0
                  estim.fixed <- 0
                }
                if (Mindex > 0) {
                  meanU <- rep(0, Mindex)
                  for (i in 1:Mindex) {
                    meanU[i] <- mean(diff(X[index[i], 2:K])^2 * (1/delta[1:(K - 2)]) * (1/X[index[i], 3:K]))
                  }
                  sigma2 <- mean(meanU)
                }
            }
            # -- Computation of the sufficient statistics
            U <- matrix(0, 2, Mindex)
            V <- as.list(1:Mindex)
            b <- as.list(1:Mindex)
            
            estimUV <- UV(X[index, ], model, random, fixed, times)
            U <- estimUV$U
            V <- estimUV$V
            
            deter <- lapply(V, det)
            index2 <- which((deter != Inf) & (deter != 0))  # indexes in 1:Mindex 
            Mindex2 <- length(index2)
            V <- V[index2]
            U <- U[, index2]
            
            # Estimator Aj of the random effects phij
            A <- matrix(0, Mindex2, 2)
            for (j in 1:Mindex2) {
                A[j, ] <- (1/det(V[[j]])) * matrix(c(V[[j]][2, 2], -V[[j]][1, 2], -V[[j]][1, 2], V[[j]][1, 1]), 
                  2, 2) %*% U[, j]
            }
            estimphi <- t(A)
            eigenvalues <- eigenvaluesV(V)
            
            if (is.null(gridf) == 1) {
                gridf <- matrix(0, 2, 500)
                gridf[1, ] <- seq(min(estimphi[1, ]) * 0.8, max(estimphi[1, ]) * 1.2, length = 500)
                gridf[2, ] <- seq(min(estimphi[2, ]) * 0.8, max(estimphi[2, ]) * 1.2, length = 500)
            }
            
            if (is.null(gridf) == 0) {
                gridf <- gridf
            }
            
            estim.fixed <- 0
            
            if (estim.method == "nonparam") {
                # Troncation of the estimators of phij
                
                kap <- 0.125
                cutoff <- apply(eigenvalues, 1, min) * (1/sigma2) > kap * sqrt(Tend)
                estimphi.trunc <- estimphi * matrix(c(cutoff, cutoff), 2, dim(estimphi)[2], byrow = TRUE)
                
                # Kernel estimator of the density 
                
                estimf <- kde2d(estimphi[1, ], estimphi[2, ], n = length(gridf[1, ]), lims = c(min(gridf[1, 
                  ]), max(gridf[1, ]), min(gridf[2, ]), max(gridf[2, ])))$z
                
                if (sum(cutoff) >= 0.25 * Mindex2) {
                  # Kernel estimator if the density from the truncated Aj
                  estimf.trunc <- kde2d(estimphi.trunc[1, ], estimphi.trunc[2, ], n = length(gridf[1, ]), lims = c(min(gridf[1, 
                    ]), max(gridf[1, ]), min(gridf[2, ]), max(gridf[2, ])))$z
                }
                if (sum(cutoff) < 0.25 * Mindex2) {
                  message("More than 75 percents of the estimated values of the random effect have been put to zero")
                  
                  estimf.trunc <- matrix(0, 2, length(gridf[1, ]))
                }
                
                bic <- 0
                aic <- 0
                mu <- 0
                omega <- 0
            }
            
            if (estim.method == "paramML") {
                # estimphi has Mindex colomns maximization of the likelihood
                
                Vsigma2 <- as.list(1:length(V))
                for (i in 1:length(V)) {
                  Vsigma2[[i]] <- V[[i]] * (1/sigma2)
                }
                Usigma2 <- U/sigma2
                
                # Estimator of the density 
                
                res <- EstParamNormal(Usigma2, Vsigma2, K = K, random = random, estim.fix = 0)
                
                bic <- res$BIChere
                aic <- res$AIChere
                mu <- res$mu
                omega <- res$omega
                # Computation of the estimators of the chosen grid
                estimf1 <- dnorm(gridf[1, ], mean = mu[1], sd = abs(omega[1]))
                estimf2 <- dnorm(gridf[2, ], mean = mu[2], sd = abs(omega[2]))
                
                estimf <- estimf1 %*% t(estimf2)
                
                estimf.trunc <- estimf
                estimphi.trunc <- estimphi
                
                cutoff <- FALSE
            }
            
            index <- index[index2]
            
        }
        
        ####################################################################################################################### 
        
        if (length(random) == 1) {
            
            if (model == "OU") {
                
                meanU <- rep(0, M)
                for (i in 1:M) {
                  
                  meanU[i] <- mean((diff(X[i, 2:K])^2) * (1/delta[1:(K - 2)]))
                }
                sigma2 <- mean(meanU)
                Mindex <- M
                index <- 1:Mindex
            }
            
            if (model == "CIR") {
                index <- which(apply(X <= 0, 1, sum) == 0)
                Mindex <- length(index)
                if (Mindex == 0) {
                  warning("All the trajectories have non positive values the model CIR cannot be used", call. = FALSE)
                  
                  estimf <- 0
                  estimphi <- 0
                  bic <- 0
                  aic <- 0
                  gridf <- 0
                  mu <- 0
                  omega <- 0
                  cutoff <- 0
                  sigma2 <- 0
                  estimf.trunc <- 0
                  estimphi.trunc <- 0
                  estim.fixed <- 0
                }
                if (Mindex != 0) {
                  meanU <- rep(0, Mindex)
                  for (i in 1:Mindex) {
                    meanU[i] <- mean(diff(X[index[i], 2:K])^2 * (1/delta[1:(K - 2)]) * (1/X[index[i], 3:K]))
                  }
                  sigma2 <- mean(meanU)
                }
            }
            
            if (estim.method == "nonparam") {
                
                if (estim.fix == 1) {
                  
                  warning("Wrong argument estim.fix with method nonparam, fixed as to be specify and estim.fix = 0", 
                    call. = FALSE)
                  
                }
                
                if (estim.fix == 0) {
                  
                  U <- rep(0, Mindex)
                  V <- rep(0, Mindex)
                  estimUV <- UV(X[index, ], model, random, fixed = fixed, times)
                  U <- estimUV$U
                  V <- estimUV$V
                  
                  # Estimator of the random effect phi
                  index2 <- which((V != Inf) & (V != 0))
                  Mindex2 <- length(index2)
                  V <- V[index2]
                  U <- U[index2]
                  A <- U/V
                  estimphi <- A
                  
                  
                  if (is.null(gridf) == 1) {
                    gridf <- seq(min(estimphi) * 0.8, max(estimphi) * 1.2, length = 500)
                  }
                  
                  if (is.null(gridf) == 0) {
                    gridf <- gridf
                  }
                  
                  # Kernel estimator of the density 

                  test <- suppressMessages(density(estimphi, from = min(gridf), to = max(gridf), bw = "ucv", n = length(gridf)))
                  
                  if (test$bw < 0.1) {
                    estimf <- suppressMessages(density(estimphi, from = min(gridf), to = max(gridf), n = length(gridf))$y)
                  }
                  if (test$bw >= 0.1) {
                    estimf <- test$y
                  }
                  
                  if (random == 2 & fixed == 0 & model == "OU") {
                    # Troncation of the Aj estimators
                    
                    kap <- 0.2
                    cutoff <- V * (1/sigma2) > kap * sqrt(Tend)
                    estimphi.trunc <- A * cutoff
                    
                    if (sum(cutoff) < 0.25 * Mindex2) {
                      message("More than 75 percents of the estimated values of the random effect have been put to zero")
                    }
                    
                    # Kernel estimator from the truncated Aj
                    test2 <- suppressMessages(density(estimphi.trunc, from = min(gridf), bw = "ucv", to = max(gridf), n = length(gridf)))
                    
                    if (test2$bw < 0.1) {
                      estimf.trunc <- suppressMessages(density(estimphi.trunc, from = min(gridf), to = max(gridf), n = length(gridf))$y)
                      estimf.trunc <- matrix(estimf.trunc, 1, length(estimf.trunc), byrow = TRUE)
                      estimphi.trunc <- as.matrix(estimphi.trunc, 1, length(estimphi.trunc), byrow = TRUE)
                    }
                    if (test2$bw >= 0.1) {
                      estimf.trunc <- test2$y
                      estimf.trunc <- matrix(estimf.trunc, 1, length(estimf.trunc), byrow = TRUE)
                      estimphi.trunc <- matrix(estimphi.trunc, 1, length(estimphi.trunc), byrow = TRUE)
                    }
                    
                  } else {
                    
                    estimf.trunc <- matrix(estimf, 1, length(estimf), byrow = TRUE)
                    estimphi.trunc <- matrix(estimphi, 1, length(estimphi), byrow = TRUE)
                    cutoff <- FALSE
                  }
                  gridf <- matrix(gridf, 1, length(gridf), byrow = TRUE)
                  estimf <- matrix(estimf, 1, length(estimf), byrow = TRUE)
                  estimphi <- matrix(estimphi, 1, length(estimphi), byrow = TRUE)
                  
                  bic <- 0
                  aic <- 0
                  mu <- 0
                  omega <- 0
                  estim.fixed <- 0
                }
                index <- index[index2]
            }
            if (estim.method == "paramML") {
                
                U12 <- matrix(0, 2, Mindex)
                V12 <- as.list(1:Mindex)
                b12 <- as.list(1:Mindex)
                
                estimUV12 <- UV(X[index, ], model, random = c(1, 2), fixed = 0, times)
                U12 <- estimUV12$U
                V12 <- estimUV12$V
                
                deter12 <- lapply(V12, det)
                index12 <- which((deter12 != Inf) & (deter12 != 0))
                Mindex12 <- length(index12)
                V12 <- V12[index12]
                U12 <- U12[, index12]
                
                Vsigma212 <- as.list(1:length(V12))
                Usigma212 <- U12 * (1/sigma2)
                for (i in 1:length(V12)) {
                  Vsigma212[[i]] <- V12[[i]] * (1/sigma2)
                }
                
                
                if (estim.fix == 1) {
                  
                  # Estimator of the density

                  res <- EstParamNormal(U = Usigma212, V = Vsigma212, K = K, random = random, 
                    estim.fix = 1)
                  bic <- res$BIChere
                  aic <- res$AIChere
                  mu <- res$mu[random]
                  omega <- res$omega
                  estim.fixed <- res$mu[(random == 1) + 1]
                  
                  U <- rep(0, Mindex)
                  V <- rep(0, Mindex)
                  estimUV <- UV(X[index, ], model, random, fixed = estim.fixed, times)
                  V <- estimUV$V
                  U <- estimUV$U
                  
                  # Estimator of the random effect phij
                  index2 <- which((V != Inf) & (V != 0))
                  
                  V <- V[index2]
                  U <- U[index2]
                  A <- U/V
                  estimphi <- A
                  index <- index[index2]
                }
                
                if (estim.fix == 0) {
                  if (fixed == 0) {
                    print("Be careful: estim.fix=0 and fixed=0 thus your fixed effect is 0 and it is not estimated")
                  }
                  
                  # Estimator of the density 
                   res <- EstParamNormal(U = Usigma212, V = Vsigma212, K = K, random = random, 
                    estim.fix = 0, fixed = fixed)
                  bic <- res$BIChere
                  aic <- res$AIChere
                  mu <- res$mu
                  omega <- res$omega
                  estim.fixed <- 0
                  
                  U <- rep(0, Mindex)
                  V <- rep(0, Mindex)
                  estimUV <- UV(X[index, ], model, random, fixed = fixed, times)
                  V <- estimUV$V
                  U <- estimUV$U
                  
                  # Estimator of the random effect phij
                  index2 <- which((V != Inf) & (V != 0))
                  
                  V <- V[index2]
                  U <- U[index2]
                  A <- U/V
                  estimphi <- A
                  index <- index[index2]
                }
                
                if (is.null(gridf) == 1) {
                  gridf <- seq(min(estimphi) * 0.8, max(estimphi) * 1.2, length = 500)
                }
                
                if (is.null(gridf) == 0) {
                  gridf <- gridf
                }
                
                # Estimator of the density
                estimf <- matrix(dnorm(gridf, mean = mu, sd = omega), 1, length(gridf), byrow = TRUE)
                gridf <- matrix(gridf, 1, length(gridf), byrow = TRUE)
                estimphi <- matrix(estimphi, 1, length(estimphi), byrow = TRUE)
                estimphi.trunc <- estimphi
                estimf.trunc <- estimf
                cutoff <- FALSE
                
            }
        }
    }
    return(new(Class = "Freq.fit", model = model, random = random, fixed = fixed, gridf = gridf, mu = mu, omega = omega, 
        cutoff = cutoff, sigma2 = sigma2, estimf.trunc = estimf.trunc, estimphi.trunc = estimphi.trunc, estimf = estimf, 
        estimphi = estimphi, estim.fixed = estim.fixed, estim.fix = estim.fix, index = index, bic = bic, aic = aic, 
        times = times, X = X))
    
}
<environment: namespace:mixedsde>
 --- function (body) search ---
Function mixedsde.fit in namespace mixedsde has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
