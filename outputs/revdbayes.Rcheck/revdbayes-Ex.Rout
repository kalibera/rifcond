 --- srcref --- 
 at /tmp/Rtmp0qlSUA/R.INSTALL1360650fe9b83/revdbayes/R/sample_diagnostics.R#128: 
 --- call (function) --- 
plot.evpost(gpg, use_bayesplot = TRUE)
 --- stacktrace ---
where 1: plot.evpost(gpg, use_bayesplot = TRUE)
where 2: plot(gpg, use_bayesplot = TRUE)

 --- value of length: 4 type: logical ---
[1]  TRUE  TRUE FALSE FALSE
 --- function --- 
function(x, y, ..., n = ifelse(x$d == 1, 1001, 101),
                        prob = c(0.5, 0.1, 0.25, 0.75, 0.95, 0.99),
                        ru_scale = FALSE, rows = NULL, xlabs = NULL,
                        ylabs = NULL, pu_only = FALSE, add_pu = FALSE,
                        use_bayesplot = FALSE,
                        fun_name = c("areas", "intervals", "dens", "hist")) {
  if (!inherits(x, "evpost")) {
    stop("use only with \"evpost\" objects")
  }
  if (n < 1) {
    stop("n must be no smaller than 1")
  }
  #
  if (use_bayesplot) {
    fun_name <- paste("mcmc_", fun_name, sep = "")
    bfun <- utils::getFromNamespace(fun_name, "bayesplot")
    x <- create_sim_vals(x)
    if (fun_name %in% c("mcmc_areas", "mcmc_intervals")) {
      return(bfun(x, prob = prob[1], ...))
    } else {
      return(bfun(x, ...))
    }
  }
  #
  prob <- sort(prob)
  if (ru_scale) {
    plot_data <- x$sim_vals_rho
    plot_density <- x$logf_rho
  } else {
    plot_data <- x$sim_vals
    plot_density <- x$logf
  }
  #
  if (pu_only & is.null(x$bin_sim_vals)) {
    warning("pu_only = TRUE is not relevant and has been ignored",
            immediate. = TRUE)
    pu_only <- FALSE
  }
  if (add_pu & is.null(x$bin_sim_vals)) {
    warning("add_pu = TRUE is not relevant and has been ignored",
            immediate. = TRUE)
    add_pu <- FALSE
  }
  if (pu_only) {
    plot_data <- x$bin_sim_vals
    plot_density <- x$bin_logf
    x$logf_args <- x$bin_logf_args
    x$d <- 1
  }
  if (add_pu) {
    plot_data <- cbind(x$bin_sim_vals, plot_data)
    x$d <- x$d + 1
  }
  if (x$d == 1) {
    temp <- suppressWarnings(graphics::hist(plot_data, prob = TRUE,
                                            plot = FALSE))
    a <- temp$breaks[1]
    b <- temp$breaks[length(temp$breaks)]
    h <- (b-a)/n
    xx <- seq(a, b, by = h)
    density_fun <- function(z) {
      density_list <- c(list(z), x$logf_args)
      exp(do.call(plot_density, density_list))
    }
    yy <- sapply(xx, density_fun)
    # Remove any infinite, missing, or undefined values
    cond <- is.finite(yy)
    yy <- yy[cond]
    xx <- xx[cond]
    n <- length(yy) - 1
    #
    if (pu_only) {
      area <- 1
    } else {
      area <- h * (yy[1] / 2 + sum(yy[2:n]) + yy[n + 1] / 2)
    }
    yy <- yy / area
    max_y <- max(temp$density, yy)
    temp <- list(...)
    if (is.null(temp$xlab)) {
      graphics::hist(plot_data, prob = TRUE, main="", ylim = c(0, max_y),
                     xlab = "", ...)
      suppressWarnings(graphics::hist(plot_data, prob = TRUE, main="",
                                      ylim = c(0, max_y), xlab = "", ...))
      if (!is.null(colnames(plot_data))) {
        graphics::title(xlab = parse(text = colnames(plot_data)[1]))
      }
    } else {
      suppressWarnings(graphics::hist(plot_data, prob = TRUE, main="",
                                      ylim = c(0, max_y), ...))
    }
    suppressWarnings(graphics::lines(xx, yy, ...))
  }
  if (x$d == 2) {
    r <- apply(plot_data, 2, range)
    xx <- seq(r[1,1], r[2,1], len = n)
    yy <- seq(r[1,2], r[2,2], len = n)
    xy <- cbind(xx, yy)
    zz <- matrix(NA, ncol = length(xx), nrow = length(yy))
    for (i in 1:length(xx)) {
      for (j in 1:length(yy)) {
        for_logf <- c(list(c(xx[i], yy[j])), x$logf_args)
        zz[i, j] <- exp(do.call(plot_density, for_logf))
      }
    }
    zz[zz == -Inf] <- NA
    dx <- diff(xx[1:2]); dy <- diff(yy[1:2]); sz <- sort(zz)
    c1 <- cumsum(sz) * dx * dy; c1 <- c1/max(c1)
    con.levs <- sapply(prob, function(x) stats::approx(c1, sz, xout = 1 - x)$y)
    #
    graphics::contour(xx, yy, zz, levels = con.levs, add = FALSE, ann = FALSE,
      labels = prob * 100, ...)
    graphics::points(plot_data, col = 8, ...)
    graphics::contour(xx, yy, zz, levels = con.levs, add = TRUE, ann = TRUE,
      labels = prob * 100, ...)
    temp <- list(...)
    if (is.null(temp$xlab)) {
      if (!is.null(colnames(plot_data))) {
        graphics::title(xlab = parse(text = colnames(plot_data)[1]))
      }
    }
    if (is.null(temp$ylab)) {
      if (!is.null(colnames(plot_data))) {
        graphics::title(ylab = parse(text = colnames(plot_data)[2]))
      }
    }
  }
  if (x$d > 2) {
    if (is.null(rows)) {
      rows <- x$d -2
    }
    cols <- ceiling(choose(x$d, 2) / rows)
    temp <- list(...)
    if (is.null(xlabs)) {
      xlabs <- colnames(plot_data)
    }
    if (is.null(ylabs)) {
      ylabs <- colnames(plot_data)
    }
    def.par <- graphics::par(no.readonly = TRUE)
    graphics::par(mfrow = c(rows, cols))
    pairwise_plots <- function(x) {
      for (i in 1:(ncol(x)-1)) {
        for (j in (i+1):ncol(x)) {
          graphics::plot(x[, i], x[, j], xlab = "", ylab = "", ...)
          graphics::title(xlab = parse(text = xlabs[i]), ylab =
                            parse(text = ylabs[j]))
        }
      }
    }
    pairwise_plots(plot_data)
    graphics::par(def.par)
  }
}
<bytecode: 0x8232498>
<environment: namespace:revdbayes>
 --- function (body) search ---
Function plot.evpost in namespace revdbayes has this body.
