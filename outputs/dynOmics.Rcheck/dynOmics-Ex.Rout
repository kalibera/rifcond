 --- srcref --- 
 at /tmp/RtmpmcqKkd/R.INSTALL758d3646b748/dynOmics/R/associateData-method.R#154: 
 --- call (function) --- 
get.delay(new.data1, new.data2)
 --- stacktrace ---
where 1 at /tmp/RtmpmcqKkd/R.INSTALL758d3646b748/dynOmics/R/associateData-method.R#125: get.delay(new.data1, new.data2)
where 2: FUN(X[[i]], ...)
where 3: fun(quote(1L), quote(function (i) 
{
    index <- 0
    if (singleData) {
        comp <- c((i + 1):nc2)
    } else {
        comp <- c(1:nc2)
    }
    m <- matrix(NA, ncol = 7, nrow = length(comp))
    for (j in comp) {
        index <- index + 1
        if (nc == 1) {
            new.data1 <- scale(data1)
        } else {
            new.data1 <- scale(data1[, i])
        }
        new.data2 <- scale(data2[, j])
        cori <- pori <- delay2 <- pfft <- pori <- NA
        if (sum(is.na(new.data1)) > 0 | sum(is.na(new.data2)) > 
            0) next
        del <- get.delay(new.data1, new.data2)
        m[index, ] <- c(i, j, del)
    }
    return(m)
}))
where 4 at /tmp/RtmpVylxdX/R.INSTALL21f7f1e28f627/snow/R/snow.R#8: do.call("fun", lapply(args, enquote))
where 5: docall(msg$data$fun, msg$data$args)
where 6: doTryCatch(return(expr), name, parentenv, handler)
where 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 8: tryCatchList(expr, classes, parentenv, handlers)
where 9 at /tmp/RtmpVylxdX/R.INSTALL21f7f1e28f627/snow/R/snow.R#60: tryCatch(docall(msg$data$fun, msg$data$args), error = handler)
where 10: doTryCatch(return(expr), name, parentenv, handler)
where 11: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 12: tryCatchList(expr, classes, parentenv, handlers)
where 13 at /tmp/RtmpVylxdX/R.INSTALL21f7f1e28f627/snow/R/snow.R#41: tryCatch({
    msg <- recvData(master)
    cat(paste("Type:", msg$type, "\n"))
    if (msg$type == "DONE") {
        closeNode(master)
        break
    }
    else if (msg$type == "EXEC") {
        success <- TRUE
        handler <- function(e) {
            success <<- FALSE
            structure(conditionMessage(e), class = c("snow-try-error", 
                "try-error"))
        }
        t1 <- proc.time()
        value <- tryCatch(docall(msg$data$fun, msg$data$args), 
            error = handler)
        t2 <- proc.time()
        value <- list(type = "VALUE", value = value, success = success, 
            time = t2 - t1, tag = msg$data$tag)
        msg <- NULL
        sendData(master, value)
        value <- NULL
    }
}, interrupt = function(e) NULL)
where 14: slaveLoop(makeSOCKmaster(master, port))
where 15: eval(quote({
    master <- "localhost"
    port <- ""
    snowlib <- Sys.getenv("R_SNOW_LIB")
    outfile <- Sys.getenv("R_SNOW_OUTFILE")
    args <- commandArgs()
    pos <- match("--args", args)
    args <- args[-(1:pos)]
    for (a in args) {
        pos <- regexpr("=", a)
        name <- substr(a, 1, pos - 1)
        value <- substr(a, pos + 1, nchar(a))
        switch(name, MASTER = master <- value, PORT = port <- value, 
            SNOWLIB = snowlib <- value, OUT = outfile <- value)
    }
    if (!(snowlib %in% .libPaths())) .libPaths(c(snowlib, .libPaths()))
    library(methods)
    library(snow)
    if (port == "") port <- getClusterOption("port")
    sinkWorkerOutput(outfile)
    cat("starting worker for", paste(master, port, sep = ":"), 
        "\n")
    slaveLoop(makeSOCKmaster(master, port))
}), new.env())
where 16: eval(quote({
    master <- "localhost"
    port <- ""
    snowlib <- Sys.getenv("R_SNOW_LIB")
    outfile <- Sys.getenv("R_SNOW_OUTFILE")
    args <- commandArgs()
    pos <- match("--args", args)
    args <- args[-(1:pos)]
    for (a in args) {
        pos <- regexpr("=", a)
        name <- substr(a, 1, pos - 1)
        value <- substr(a, pos + 1, nchar(a))
        switch(name, MASTER = master <- value, PORT = port <- value, 
            SNOWLIB = snowlib <- value, OUT = outfile <- value)
    }
    if (!(snowlib %in% .libPaths())) .libPaths(c(snowlib, .libPaths()))
    library(methods)
    library(snow)
    if (port == "") port <- getClusterOption("port")
    sinkWorkerOutput(outfile)
    cat("starting worker for", paste(master, port, sep = ":"), 
        "\n")
    slaveLoop(makeSOCKmaster(master, port))
}), new.env())
where 17: eval(expr, p)
where 18: eval(expr, p)
where 19: eval.parent(substitute(eval(quote(expr), envir)))
where 20: local({
    master <- "localhost"
    port <- ""
    snowlib <- Sys.getenv("R_SNOW_LIB")
    outfile <- Sys.getenv("R_SNOW_OUTFILE")
    args <- commandArgs()
    pos <- match("--args", args)
    args <- args[-(1:pos)]
    for (a in args) {
        pos <- regexpr("=", a)
        name <- substr(a, 1, pos - 1)
        value <- substr(a, pos + 1, nchar(a))
        switch(name, MASTER = master <- value, PORT = port <- value, 
            SNOWLIB = snowlib <- value, OUT = outfile <- value)
    }
    if (!(snowlib %in% .libPaths())) 
        .libPaths(c(snowlib, .libPaths()))
    library(methods)
    library(snow)
    if (port == "") 
        port <- getClusterOption("port")
    sinkWorkerOutput(outfile)
    cat("starting worker for", paste(master, port, sep = ":"), 
        "\n")
    slaveLoop(makeSOCKmaster(master, port))
})

 --- value of length: 9 type: logical ---
  statistic   parameter     p.value    estimate  null.value alternative 
       TRUE        TRUE        TRUE        TRUE        TRUE        TRUE 
     method   data.name    conf.int 
       TRUE        TRUE        TRUE 
 --- function --- 
function(x,y) {
  cord <- cor.test(x,y)
  if(abs(cord$estimate)!=1 & !is.na(cord)){
  l <- length(x)
  ori.fft<- convert.fft(fft(x))[2:(l/2),]

  cf <-convert.fft(fft(y))[2:(l/2),]
  #frequencey at maximum amplitude cycle
  freq <- which.max(ori.fft$strength)
  dels <-  ori.fft$delay[freq]- cf$delay[freq]
 
  dels <- ifelse(dels<0,dels+359,dels)
  #sequence length
  l2 <- l
  if(l%%2!=0)
    l2<-l+1
  l.freq <- l2/freq
  
  newest <- round(dels/(360/l.freq))
  if(dels>-1 & dels<90){
    newest <-  newest
  }
  #positive correlated with neg shift
  if(dels>269 & dels<360){
    newest <-  newest-l.freq
  }
  #negative correlated with neg shift
  if(dels>89 & dels<180){
    newest <-  (l.freq/2)-newest
  }
  #negative correlated with pos shift
  if(dels>180 & dels<270){
    newest <-  (l.freq/2)-newest
  }

  newest <- ifelse(dels=='180', 0,newest)
  newest <- round(newest)
  newest <- ifelse(abs(newest)==(l.freq),0,newest)
  newest <- ifelse((newest)>(l.freq/2),(newest)-(l.freq),newest)
  newest <- ifelse((newest)<(-l.freq/2),(newest)+(l.freq),newest)
  newest <- round(newest)
  delaytests <- c(newest, newest*-1)
  
  cors <- numeric(2)
  for(d in 1:2){
    dely <- delaytests[d]
    cors[d] <- ifelse(dely>0,cor(as.numeric(y[1:(l-abs(dely))]),as.numeric(x[(abs(dely)+1):l])),cor(as.numeric(x[1:(l-abs(dely))]),as.numeric(y[(abs(dely)+1):l])))
  }
  s <- sum(!is.na(cors))
  if(s==2){
    newest <- ifelse(abs(cors[1])>abs(cors[2]),newest,newest*-1)
  }else if(s==1){
    newest <- c(newest,newest*-1)[which(!is.na(cors))]
  }else{
    newest <-0
  }
  delaytests <- c(newest-1,newest,newest+1)
  delaytests[abs(delaytests)>=(l.freq) | is.na(delaytests)] <- 0
  delaytests <- unique(delaytests)
  cors <-  corsp <- numeric(length(delaytests))
  for(d in 1:length(delaytests)){
    dely <- delaytests[d]
    if(dely>0){
      c <- cor.test(as.numeric(y[1:(l-abs(dely))]),as.numeric(x[(abs(dely)+1):l]))
    }else{
      c <- cor.test(as.numeric(x[1:(l-abs(dely))]),as.numeric(y[(abs(dely)+1):l]))
    }
    cors[d] <-c$estimate
    corsp[d] <- c$p.value

  }
  ma <- which.max(abs(cors))
  cori <- cor.test(x,y,use="pairwise.complete.obs")
  delay2  <- delaytests[ma]
  pfft <- corsp[ma]
  cfft <- cors[ma]
  
  if(abs(cfft)<abs(cori$estimate)){
    delay2 <- 0
    cfft <- cori$estimate
    pfft <- cori$p.value
  }
  return(c(delay2,cori$p.value,pfft, cori$estimate,cfft))
  }else{
    
  }

  return(c(0,cord$p.value,cord$p.value, cord$estimate,cord$estimate))
}
<environment: namespace:dynOmics>
 --- function (body) search ---
Function get.delay in namespace dynOmics has this body.
