
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(intamap)
Loading required package: sp
> 
> # observations = Something from Java...
> # Until then we use the Meuse data:
> data(meuse)
> observations = data.frame(x = meuse$x,y = meuse$y,value = log(meuse$zinc))
> # If you send a field just with 3 columns (x,y & z), we can let R figure
> # out itself which names they have, for creation of a spatial object:
> obsNames = names(observations)
> coordinates(observations) = as.formula(paste("~",obsNames[1], "+", obsNames[2]))
> set.seed(13531)
> predictionLocations = spsample(observations, 10, "regular")
> gridded(predictionLocations) = TRUE
> cellsize = predictionLocations@grid@cellsize
> cs = predictionLocations@grid@cellsize[1]/2
> 
> # We dont know the projection of the data at this stage, assume it is
> # somehow metric
> 
> Srl = list()
> for (i in 1:dim(coordinates(predictionLocations))[1]) {
+   pt1 = coordinates(predictionLocations)[i,]
+   x1 = pt1[1]-cs
+   x2 = pt1[1]+cs
+   y1 = pt1[2]-cs
+   y2 = pt1[2]+cs
+ 
+   boun = data.frame(x=c(x1,x2,x2,x1,x1),y=c(y1,y1,y2,y2,y1))
+   coordinates(boun) = ~x+y
+   boun = Polygon(boun)
+   Srl[[i]] = Polygons(list(boun),ID = as.character(i))
+ }
> predictionLocations = SpatialPolygons(Srl)
> 
> 
> krigingObject = createIntamapObject(
+ 	observations = observations,
+ 	predictionLocations = predictionLocations,
+ #	targetCRS = "+init=epsg:3035",
+ #	boundCRS = "+proj=laea +lat_0=48 +lon_0=9 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m",
+ #	boundCRS = boundCRS,
+ #	boundaries = boundaries,
+   formulaString = as.formula(paste(obsNames[3],"~1")),
+ 	params =  list(thresh = quantile(observations$value,0.9),block=cellsize),
+     outputWhat = list(mean=TRUE, variance=TRUE, excprob = 5.9, cumdistr = 5.9, 
+ 		quantile = .1),
+     blockWhat = list(fat=7,fatVar=7,blockMax=TRUE,blockMaxVar = TRUE,blockMin=TRUE),
+ 	class="automap"
+ )
> 
> checkSetup(krigingObject)
Checking object ... OK
> krigingObject = preProcess(krigingObject)
> krigingObject = estimateParameters(krigingObject)
> krigingObject = blockPredict(krigingObject)
[using ordinary kriging]
[1] "performed ordinary block kriging"
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpIkV0vT/R.INSTALLe1049b4477b/intamap/R/aggregation.R#125: 
 --- if/while statement is in package --- 
intamap
 --- call (currently evaluated) --- 
spatialAggregate(object, SpP)
 --- R stacktrace ---
where 1 at /var/scratch2/tomas/tmp/RtmpIkV0vT/R.INSTALLe1049b4477b/intamap/R/aggregation.R#97: spatialAggregate(object, SpP)
where 2 at /var/scratch2/tomas/tmp/RtmpIkV0vT/R.INSTALLe1049b4477b/intamap/R/aggregation.R#3: spatialPredict.block(object, ...)
where 3: blockPredict(krigingObject)

 --- value of length: 5 type: logical ---
        fat      fatVar    blockMax blockMaxVar    blockMin 
      FALSE       FALSE       FALSE       FALSE       FALSE 
 --- function (currently evaluated)--- 
function(object, SpP) {
  predictionLocations = object$predictionLocations
  pointLocations = object$pointLocations  
  if ("predictions" %in% names(object)) {
    predictions = object$predictions
  } else {
    predictions = predictionLocations
  }
    
  pointPredictions = object$pointPredictions
  coor = SpatialPoints(pointPredictions)
  sims = pointPredictions[,grep("sim",names(pointPredictions))>0]
  
  params = object$params
  thresh = params$thresh
  outputWhat = object$outputWhat
  blockWhat = object$blockWhat
  if ("mean" %in% names(outputWhat)) {
     if (blockWhat == "none") blockWhat = list(mean = TRUE) else blockWhat$mean = TRUE
  }
  predAggr = aggregate(sims,by=SpP,mean)
  if ("data" %in% names(getSlots(class(predictions)))) {
    predictions@data = data.frame(predictions@data,predAggr@data)
  } else predictions = SpatialDataFrame(predictions,predAggr@data)
  if (length(blockWhat) > 0 && blockWhat != "none") {
    for (ib in 1:length(blockWhat)) {
      what = blockWhat[ib]
      if (names(what) == "fat") {
        thresh = what[[1]]
        fatf = function(arr,thresh) sum(I(arr>thresh))/length(arr)  
        fatx = aggregate(sims,SpP,FUN = fatf,thresh=thresh)@data
        vmean = rowMeans(fatx[,-1])
        vvar = apply(fatx[,-1],MARGIN=1,FUN=function(arr) var(arr))
        vname = paste("fat",what[[1]],sep="")
        vnamevar = paste("fatVar",what[[1]],sep="")
      } else if (names(what) == "blockMax" && what[[1]]) {
        bmax = aggregate(sims,by=SpP,FUN = max)@data
        vmean = rowMeans(bmax[,-1])
        vvar = apply(bmax[,-1],MARGIN=1,FUN=function(arr) var(arr))
        vname = "blockMax"
        vnamevar = "blockMaxVar"
      } else if (names(what) == "blockMin" && what[[1]]) {
        bmin = aggregate(sims,by=SpP,FUN = min)@data
        vmean = rowMeans(bmin[,-1])
        vvar = apply(bmin[,-1],MARGIN=1,FUN=function(arr) var(arr))
        vname = "blockMin"
        vnamevar = "blockMinVar"
      } else if (names(what) == "mean" && what[[1]]) {
        bmean = aggregate(sims, by = SpP, FUN = mean)@data
        vmean = rowMeans(bmean[,-1])
        vvar = apply(bmean[,-1],MARGIN=1,FUN=function(arr) var(arr))
        vname = "blockMean"
        vnamevar = "blockMeanVar"
      }
      predictions@data[vname] = vmean        
      predictions@data[vnamevar] = vvar             
    }
  }
  object$predictions = predictions
  object
}
<environment: namespace:intamap>
 --- function (body) search ---
Function spatialAggregate in namespace intamap has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
