
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "epifit"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('epifit')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AIC.epifit")
> ### * AIC.epifit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AIC.epifit
> ### Title: Function for calculating Akaike's 'An Information Criterion'
> ###   (AIC) from epifit object.
> ### Aliases: AIC.epifit
> 
> ### ** Examples
> 
> library(survival)
> # The simplest test data set from coxph function
> test1 <- list(time=c(4,3,1,1,2,2,3),
+               status=c(1,1,1,0,1,1,0),
+               x=c(0,2,1,1,1,0,0),
+               sex=c(0,0,0,0,1,1,1))
> AIC(coxph(Surv(time,status)~x + strata(sex), data=test1))
[1] 8.655313
> modelexpr <- "cox(time,status)/strata(sex)~exp(beta*x)"
> AIC(epifit(modelexpr=modelexpr, data=test1))

Choice of initial value of parameters are:
beta 
   0 
[1] 13.42357
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("calcAge")
> ### * calcAge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calcAge
> ### Title: Calculate the difference between two date in terms of unit of
> ###   time.
> ### Aliases: calcAge
> 
> ### ** Examples
> 
> calcAge("1963-2-3")
[1] 54
> 
> 
> 
> cleanEx()
> nameEx("convertFromFactor")
> ### * convertFromFactor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convertFromFactor
> ### Title: Convert factor variable to numeric or character variable.
> ### Aliases: convertFromFactor
> 
> ### ** Examples
> 
> a <- factor(rnorm(5))
> b <- c("a", "b", "c", "d", "e")
> c <- c("1", "2", "3", "4", NA)
> d <- c("1", "2", "3", "4", ".")
> dat <- data.frame(a,b,c,d)
> dat2 <- convertFromFactor(dat)
> dat3 <- convertFromFactor(dat, numeric=c("d"))
Warning in convertFromFactor(dat, numeric = c("d")) :
  NAs introduced by coercion
> dat4 <- convertFromFactor(dat, mode="all_character")
> 
> 
> 
> cleanEx()
> nameEx("convertNA")
> ### * convertNA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convertNA
> ### Title: Convert a character pattern or numeric value into NA and vice
> ###   versa.
> ### Aliases: convertNA
> 
> ### ** Examples
> 
> dat <- data.frame(a=c("","2","3"),b=c("4", NA, "."), c=c(-1,1,3),
+                   d=c(NA,3,2), stringsAsFactors=FALSE)
> dat2 <- convertNA(dat, na.character=c("", "."))
> dat3 <- convertNA(dat, na.character=".", na.numeric=-1, fromNA=TRUE)
> dat
  a    b  c  d
1      4 -1 NA
2 2 <NA>  1  3
3 3    .  3  2
> dat2
     a    b  c  d
1 <NA>    4 -1 NA
2    2 <NA>  1  3
3    3 <NA>  3  2
> dat3
  a b  c  d
1   4 -1 -1
2 2 .  1  3
3 3 .  3  2
> 
> 
> 
> cleanEx()
> nameEx("countNA")
> ### * countNA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: countNA
> ### Title: Count NAs in variables.
> ### Aliases: countNA
> 
> ### ** Examples
> 
> df <- data.frame(id=1:1000, cov1=rnorm(1000), cov2=runif(1000))
> df$cov1 <- ifelse(df$cov1 < 0, NA, df$cov1)
> df$cov2 <- ifelse(df$cov2 < 0.2, NA, df$cov2)
> countNA(df)
     observed missing total percent(%)
id       1000       0  1000        0.0
cov1      482     518  1000       51.8
cov2      788     212  1000       21.2
> 
> 
> 
> cleanEx()
> nameEx("epifit")
> ### * epifit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: epifit
> ### Title: Model fitting function for epifit package
> ### Aliases: epifit
> 
> ### ** Examples
> 
> library(survival)
> 
> # Make sample data
> set.seed(123)
> nsub <- 20
> follow <- 5
> x <- rnorm(nsub)
> rate <- exp(-0.5 + x)
> etime <- rweibull(nsub, 1, 1/rate)
> status <- as.integer(etime < follow)
> time <- pmin(follow, etime)
> dat <- data.frame(status, x, time)
> 
> coxph(Surv(time, status)~x, data=dat)
Call:
coxph(formula = Surv(time, status) ~ x, data = dat)

  coef exp(coef) se(coef)    z      p
x 1.16      3.19     0.37 3.14 0.0017

Likelihood ratio test=11.9  on 1 df, p=0.000564
n= 20, number of events= 19 
> modelexpr <- "cox(time,status)~exp(beta*x)"
> epifit(modelexpr=modelexpr, data=dat)

Choice of initial value of parameters are:
beta 
   0 
Call:
epifit(modelexpr = modelexpr, data = dat)

     coef se(coef)    z      p
beta 1.16     0.37 3.14 0.0017
> 
> glm(status ~ x + offset(log(time)), family=poisson(), data=dat)

Call:  glm(formula = status ~ x + offset(log(time)), family = poisson(), 
    data = dat)

Coefficients:
(Intercept)            x  
    -0.6453       0.7150  

Degrees of Freedom: 19 Total (i.e. Null);  18 Residual
Null Deviance:	    20.99 
Residual Deviance: 13.67 	AIC: 55.67
> preexpr <- "mu <- time*exp(beta0 + beta1*x)"
> modelexpr <- "pois(mu) ~ status"
> epifit(modelexpr=modelexpr, preexpr=preexpr, data=dat)

Choice of initial value of parameters are:
beta0 beta1 
    0     0 
Call:
epifit(modelexpr = modelexpr, preexpr = preexpr, data = dat)

        coef se(coef)     z       p
beta0 -0.645    0.234 -2.76 0.00584
beta1  0.715    0.260  2.75 0.00599
> 
> # The simplest test data set from coxph function
> test1 <- list(time=c(4,3,1,1,2,2,3),
+               status=c(1,1,1,0,1,1,0),
+               x=c(0,2,1,1,1,0,0),
+               sex=c(0,0,0,0,1,1,1))
> 
> # Cox regressions with strata
> coxph(Surv(time, status) ~ x + strata(sex), data=test1)
Call:
coxph(formula = Surv(time, status) ~ x + strata(sex), data = test1)

   coef exp(coef) se(coef)    z    p
x 0.802     2.231    0.822 0.98 0.33

Likelihood ratio test=1.09  on 1 df, p=0.297
n= 7, number of events= 5 
> modelexpr <- "cox(time,status)/strata=sex~exp(beta*x)"
> epifit(modelexpr=modelexpr, data=test1)

Choice of initial value of parameters are:
beta 
   0 
Call:
epifit(modelexpr = modelexpr, data = test1)

      coef se(coef)     z     p
beta 0.802    0.822 0.976 0.329
> 
> # Tie specification example in Cox regressions
> coxph(Surv(time, status) ~ x + strata(sex), data=test1, ties="breslow")
Call:
coxph(formula = Surv(time, status) ~ x + strata(sex), data = test1, 
    ties = "breslow")

   coef exp(coef) se(coef)    z    p
x 0.736     2.087    0.804 0.91 0.36

Likelihood ratio test=0.94  on 1 df, p=0.332
n= 7, number of events= 5 
> modelexpr <- "cox(time,status)/strata=sex,ties=breslow~exp(beta*x)"
> epifit(modelexpr=modelexpr, data=test1)

Choice of initial value of parameters are:
beta 
   0 
Call:
epifit(modelexpr = modelexpr, data = test1)

      coef se(coef)     z    p
beta 0.736    0.804 0.915 0.36
> 
> # Average partial likelihood
> modelexpr <- "cox(time,status)/strata=sex,ties=average~exp(beta*x)"
> epifit(modelexpr=modelexpr, data=test1)

Choice of initial value of parameters are:
beta 
   0 
Call:
epifit(modelexpr = modelexpr, data = test1)

      coef se(coef)     z     p
beta 0.946    0.973 0.973 0.331
> 
> # Conditional logistic regression for matched case-control studies
> # hypothetical data
> conlog <- data.frame(strata=c(1,1,2,2,3,3,4,4,5,5), outcome=c(1,0,1,0,1,0,1,0,1,0),
+                      cov=c(1,3,2,1,5,2,4,2,2,2))
> # Make dummy survival time so that all the cases in a matched set have the same survival
> # time value, and the corresponding controls are censored at later times
> conlog <- cbind(conlog, dummy=(2 - conlog$outcome))
> coxph(Surv(dummy, outcome)~cov + strata(strata), ties="exact", data=conlog)
Call:
coxph(formula = Surv(dummy, outcome) ~ cov + strata(strata), 
    data = conlog, ties = "exact")

     coef exp(coef) se(coef)    z    p
cov 0.500     1.649    0.563 0.89 0.37

Likelihood ratio test=0.94  on 1 df, p=0.332
n= 10, number of events= 5 
> modelexpr <- "cox(dummy,outcome)/ties=discrete,strata=strata~exp(beta*cov)"
> epifit(modelexpr=modelexpr, data=conlog)

Choice of initial value of parameters are:
beta 
   0 
Call:
epifit(modelexpr = modelexpr, data = conlog)

     coef se(coef)     z     p
beta  0.5    0.564 0.888 0.375
> 
> 
> # Joint model example (for demonstrating technical specifications)
> nsub <- 1000
> follow <- 10
> x <- rnorm(nsub)
> dose <- rweibull(nsub, 0.5, 1/(2.84)^2)
> rate <- exp(-1 + x)*(1 + 0.5*dose)
> 
> # Generate survival data
> etime <- rweibull(nsub, 1, 1/rate)
> status <- as.integer(etime < follow)
> time <- pmin(follow, etime)
> dat2 <- data.frame(event=status, py=time, x, dose, model=1)
> 
> # Generate person-year table (baseline is different)
> py <- runif(nsub)*follow
> rate2 <- exp(-0.5 + 0.5*x)*(1 + 0.5*dose)
> event <- sapply(rate2*py, function(x){rpois(1, x)})
> dat3 <- cbind(pytable(event, py, cbind(x,dose)), model=2)
> dat4 <- rbind(dat2, dat3)
> 
> modelexpr <- c("cox(py,event)/subset=(model==1)~exp(beta0*x)*(1 + beta*dose)",
+              "pois(py*exp(beta1 + beta2*x)*(1 + beta*dose))/subset=(model==2) ~ event")
> epifit(modelexpr, data=dat4)

Choice of initial value of parameters are:
beta0  beta beta1 beta2 
    0     0     0     0 
Warning in nlm(f = LogLikelihood, p = init, iterlim = maxiter, hessian = TRUE,  :
  NA/Inf replaced by maximum positive value
Call:
epifit(modelexpr = modelexpr, data = dat4)

        coef se(coef)     z p
beta0  0.933   0.0419  22.3 0
beta   0.502   0.0498  10.1 0
beta1 -0.505   0.0215 -23.5 0
beta2  0.490   0.0158  31.1 0
> 
> # Time dependent covariate example
> id <- 1:8
> group <- c(0, 0, 0, 0, 1, 1, 1, 1)
> time <- c(4, 5, 7, 9, 6, 10, 11, 12)
> event <- c(1, 1, 0, 1, 1, 1, 1, 0)
> dat5 <- data.frame(id=id, group=group, time=time, event=event)
> modelexpr <- "cox(time, event) ~ exp(beta1*group + beta2*t_g)"
> # t_g is time-dependent variable created by using event time time_inner_ (created automatically)
> timedepexpr <- "t_g <- time_inner_ * group"
> epifit(modelexpr=modelexpr, timedepexpr=timedepexpr, data=dat5)

Choice of initial value of parameters are:
beta1 beta2 
    0     0 
Call:
epifit(modelexpr = modelexpr, timedepexpr = timedepexpr, data = dat5)

        coef se(coef)       z     p
beta1 -0.332    3.945 -0.0842 0.933
beta2 -0.215    0.628 -0.3418 0.733
> 
> coxph(Surv(time, event) ~ group + tt(group),
+       tt = function(x, t, ...){x * t},data=dat5)
Call:
coxph(formula = Surv(time, event) ~ group + tt(group), data = dat5, 
    tt = function(x, t, ...) {
        x * t
    })

            coef exp(coef) se(coef)     z    p
group     -0.332     0.717    3.945 -0.08 0.93
tt(group) -0.215     0.807    0.629 -0.34 0.73

Likelihood ratio test=2.5  on 2 df, p=0.286
n= 8, number of events= 6 
> 
> cov0 <- data.frame(id=id, time=0, value=0*group)
> cov4 <- data.frame(id=id, time=3.9, value=4*group)
> cov5 <- data.frame(id=id, time=4.9, value=5*group)
> cov6 <- data.frame(id=id, time=5.9, value=6*group)
> cov9 <- data.frame(id=id, time=8.9, value=9*group)
> cov10 <- data.frame(id=id, time=9.9, value=10*group)
> cov11 <- data.frame(id=id, time=10.9, value=11*group)
> tdata <- data.frame(id=id, group=group)
> tdata <- tmerge(tdata, dat5, id, status=event(time, event))
> tdata <- tmerge(tdata, cov0, id, t_g=tdc(time, value))
> tdata <- tmerge(tdata, cov4, id, t_g=tdc(time, value))
> tdata <- tmerge(tdata, cov5, id, t_g=tdc(time, value))
> tdata <- tmerge(tdata, cov6, id, t_g=tdc(time, value))
> tdata <- tmerge(tdata, cov9, id, t_g=tdc(time, value))
> tdata <- tmerge(tdata, cov10, id, t_g=tdc(time, value))
> tdata <- tmerge(tdata, cov11, id, t_g=tdc(time, value))
> coxph(Surv(tstart, tstop, status) ~ group + t_g, data=tdata)
Call:
coxph(formula = Surv(tstart, tstop, status) ~ group + t_g, data = tdata)

        coef exp(coef) se(coef)     z    p
group -0.332     0.717    3.945 -0.08 0.93
t_g   -0.215     0.807    0.629 -0.34 0.73

Likelihood ratio test=2.5  on 2 df, p=0.286
n= 38, number of events= 6 
> epifit("cox(tstart, tstop, status) ~ exp(beta1*group + beta2*t_g)", data=tdata)

Choice of initial value of parameters are:
beta1 beta2 
    0     0 
Call:
epifit(modelexpr = "cox(tstart, tstop, status) ~ exp(beta1*group + beta2*t_g)", 
    data = tdata)

        coef se(coef)       z     p
beta1 -0.332    3.945 -0.0842 0.933
beta2 -0.215    0.628 -0.3418 0.733
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("extractVariable")
> ### * extractVariable
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extractVariable
> ### Title: Extract variables according to mode from data.frame.
> ### Aliases: extractVariable
> 
> ### ** Examples
> 
> df <- data.frame(id=seq(1,10), str=letters[1:10], fac=factor(seq(1,10)), stringsAsFactors=FALSE)
> extractVariable(df)
   id
1   1
2   2
3   3
4   4
5   5
6   6
7   7
8   8
9   9
10 10
> extractVariable(df, mode="character")
   str
1    a
2    b
3    c
4    d
5    e
6    f
7    g
8    h
9    i
10   j
> extractVariable(df, mode="factor")
   fac
1    1
2    2
3    3
4    4
5    5
6    6
7    7
8    8
9    9
10  10
> 
> 
> 
> cleanEx()
> nameEx("getIndex")
> ### * getIndex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getIndex
> ### Title: Get index by specifying cut points
> ### Aliases: getIndex
> 
> ### ** Examples
> 
> # cutpoint   cp(1)  cp(2)  ...   cp(n-1)  cp(n)
> # index    1   *   2  *    ... (n-1) *  (n) * (n+1)
> a <- rnorm(100) * 10
> b <- getIndex(a, cutpoints=c(-2,-1,0,1,2))
> 
> 
> 
> cleanEx()
> nameEx("listNumericIncompatibility")
> ### * listNumericIncompatibility
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: listNumericIncompatibility
> ### Title: List incompatible values when converted into numeric values.
> ### Aliases: listNumericIncompatibility
> 
> ### ** Examples
> 
> a <- factor(rnorm(5))
> b <- c("a", "b", "c", "d", "e")
> c <- c("1", "2", "3", "4", NA)
> d <- c("1", "2", "3", "4", ".")
> dat <- data.frame(a,b,c,d)
> listNumericIncompatibility(dat)
$b
[1] "a" "b" "c" "d" "e"

$d
[1] "."

> 
> 
> 
> cleanEx()
> nameEx("pullOneValue")
> ### * pullOneValue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pullOneValue
> ### Title: Pull one set of values from variables included in data which are
> ###   thought to include essentially the same information.
> ### Aliases: pullOneValue
> 
> ### ** Examples
> 
> dat <- data.frame(a1=c(NA,2,3), a2=c(1,NA,2), a3=c(1,2,NA), b=c(10,11,20))
> dat
  a1 a2 a3  b
1 NA  1  1 10
2  2 NA  2 11
3  3  2 NA 20
> pullOneValue(dat, c("a1", "a2", "a3"))
Imcompatible data exists in row: 3 
a1  =  3 
a2  =  2 
a3  =  NA 
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/Rtmp32SNNO/R.INSTALL4a4b2b1c03fd/epifit/R/pullOneValue.R#74: 
 --- if/while statement is in package --- 
epifit
 --- call (currently evaluated) --- 
pullOneValue(dat, c("a1", "a2", "a3"))
 --- R stacktrace ---
where 1: pullOneValue(dat, c("a1", "a2", "a3"))

 --- value of length: 4 type: logical ---
[1] FALSE  TRUE FALSE FALSE
 --- function (currently evaluated)--- 
function(data=NULL, varlist=c(""), check=TRUE, choose=c("first", "last", "lower", "upper")){

  res <- NULL
  
  if(is.null(data) || !is.data.frame(data))
    stop("data must be data.frame")
  
  allvar <- colnames(data)
  
  for(i in 1:length(varlist)){
    if(!varlist[i] %in% allvar)
      stop("at least one variable in varlist is not included in data")
  }
  
  idx <- GetParamPosition(varlist, allvar)
  
  if(length(idx) < 2)
    return(data[,idx])
  
  n <- nrow(data)

  # check variable mode
  if(is.numeric(data[,idx[1]])){
    res <- as.numeric(rep(NA, n))
    for(i in 2:length(idx)){
      if(!is.numeric(data[,idx[i]]))
        stop("mode of variables are different")
    }
  } else if(is.character(data[,idx[1]])){
    res <- as.character(rep(NA, n))
    for(i in 2:length(idx)){
      if(!is.character(data[,idx[i]]))
        stop("mode of variables are different")
    }
  } else if(is.factor(data[,idx[1]])){
    res <- as.factor(rep(NA, n))
    levels(res) <- levels(data[, idx[1]])
    for(i in 2:length(idx)){
      if(!is.factor(data[,idx[i]]))
        stop("mode of variables are different")
    }
    warning("factor is not fully supported")
  } else {
    stop("unsupported variable type")
  }

  for(i in 1:n){
    for(j in idx){
      
      if(!is.na(data[i,j]) && !is.nan(data[i,j])){
        if(is.na(res[i])){
          res[i] <- data[i,j]
          if(!check)
            next
        } else {
          if(res[i] != data[i,j]){
            cat("Imcompatible data exists in row:", i,"\n")
            for(j in idx){
              cat(allvar[j], " = ", data[i,j], "\n")
            }
            if(choose=="last"){
              res[i] <- data[i,j]
            } else if(choose=="lower"){
              if(res[i] > data[i,j])
                res[i] <- data[i,j]
            } else if(choose=="upper"){
              if(res[i] < data[i,j])
                res[i] <- data[i,j]
            } else if(choose!="first"){
              stop("unknown option is specified in choose argument")
            }
          }
        }
      }
    }
  }
  return(res)
}
<bytecode: 0x2993ac8>
<environment: namespace:epifit>
 --- function (body) search ---
Function pullOneValue in namespace epifit has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
