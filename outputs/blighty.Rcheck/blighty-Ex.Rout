
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "blighty"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('blighty')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("blighty")
> ### * blighty
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: blighty
> ### Title: British Isles Coastlines
> ### Aliases: blighty
> ### Keywords: hplot
> 
> ### ** Examples
> 
> blighty()		# British Isles coastline

Plotting  set.British.Isles  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Map complete ...

> blighty(grid=TRUE)	# British Isles coastline with grid

Plotting  set.British.Isles  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Requested gridding applied ...
Map complete ...

> points(399,91)		# add in Poole OS coords last digit is 1km
> text(400,50,"Poole")
> 
> blighty(place="set.Scotland")	# Scotland and the Western Isles

Plotting  set.Scotland  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Map complete ...

> points(327, 672)	# OS coords for Authurs Seat
> text(327, 655, "Edinburgh")
> 
> blighty(place="set.Wales")	# Wales and Anglesey

Plotting  set.Wales  be patient ...
Data loaded ...
Less than 200km East-West - poor map resolution - proceeding
Correct aspect ratio calculated ...
Map complete ...

> 
> blighty(place="set.Ireland")	# Ireland

Plotting  set.Ireland  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Map complete ...

> 
> blighty(place="set.England", xlimits=c(400,600), ylimits=c(50, 200))

Plotting  set.England  be patient ...
Data loaded ...
Less than 200km North-South - poor map resolution - proceeding
Correct aspect ratio calculated ...
Map complete ...

> box()			# south of England and the Isle of Wight
> 			# and the Thames Estuary
> 
> 
> blighty(place="set.British.Isles")	# do a plot then add the capital cities

Plotting  set.British.Isles  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Map complete ...

> x <- c(532, 327, 317, 118, 157)		# make up two vectors of points
> y <- c(181, 672, 175, 385, 529)		# for capital cities
> 
> names <- c("London", "Edinburgh", "Cardiff", "Dublin", "Belfast") # vector of names
>  
> points(x,y, col="red")	# add in the points in red
>  
> text(x + 20, y, labels=names, adj=0)
> 			# add some labels displaced by 20km to the right
> 
> set.mine <- set.British.Isles$Object[c(1,2,3,87,88)]
> blighty(place="set.mine", set=FALSE)

Plotting  set.mine  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Map complete ...

> 			# specify a custom set of objects here it can
> 			# be all the coastlines for the main British Isles
> 			# note how you have to specify the new set in quotes
> 			# and specify set=FALSE - all else should be as normal
> 
> blighty(parcol="gray")	# use a basic shading

Plotting  set.British.Isles  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Map complete ...

> 
> blighty("set.Scotland", parcol="blue", parbor="red", sarcol="red", tlncol="green", tlnwdh=3)

Plotting  set.Scotland  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Map complete ...

> 			# looks hideous but demonstates some of the shading
> 			# functions
> 
> blighty(parang=45, parden=30, parbor="transparent", parcol="black", sarbor="transparent", tlncol="transparent")

Plotting  set.British.Isles  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Map complete ...

> 			# more of a picture for logos etc
> 
> 
> 
> cleanEx()
> nameEx("map.scale")
> ### * map.scale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: map.scale
> ### Title: British Isles Coastline map scale
> ### Aliases: map.scale
> ### Keywords: hplot
> 
> ### ** Examples
> 
> blighty()			# draw coastline

Plotting  set.British.Isles  be patient ...
Data loaded ...
Correct aspect ratio calculated ...
Map complete ...

> map.scale(pos="AUTO", width=2)	# automatic placing
> map.scale(width=2)		# same as above
> ## Not run: map.scale(pos="select")	  # locator to select
> map.scale(pos=c(400,400))	# position vector
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/Rtmp70Y2h9/R.INSTALLd8f66a5c92a8/blighty/R/map.scale.r#23: 
 --- if/while statement is in package --- 
blighty
 --- call (currently evaluated) --- 
map.scale(pos = c(400, 400))
 --- R stacktrace ---
where 1: map.scale(pos = c(400, 400))

 --- value of length: 2 type: logical ---
[1] FALSE FALSE
 --- function (currently evaluated)--- 
function(pos="AUTO", width=1)
{
# positively associate a value with a missing item
if(missing(pos)){pos <- "AUTO"}

# check for the existence of blighty.mapinfo - stop if not
# the complication comes about because R CMD check generates
# a query if no blighty.mapinfo - so the trick is to create and
# destroy it - then hop out map.scale() with an appropriate error
if(!exists("blighty.mapinfo"))
{
blighty.mapinfo <- NULL
rm(blighty.mapinfo)
stop("blighty.mapinfo non existent: run blighty() before map.scale()")
}



# calculate base x and y for automatic selection of position
	if(pos == "AUTO")
		{
		xpos <- ((blighty.mapinfo$xlims[2] - blighty.mapinfo$xlims[1]) * 0.90) + blighty.mapinfo$xlims[1]
		ypos <- ((blighty.mapinfo$ylims[2] - blighty.mapinfo$ylims[1]) * 0.70) + blighty.mapinfo$ylims[1]
		}

# if the user has sent a vector describing where the centre of the scale should be
	if(is.numeric(pos))
		{
		if(length(pos) != 2){cat("\nWrong type for map scale coords\n"); stop}
		xpos <- pos[1]
		ypos <- pos[2]
		}

# if the user wishes to visually select the centre of the map scale
	if(pos == "select")
		{
		cat("\nUse the pointer to select where the map scale should be on the map\npress button 1 to select the point, then press button 2 to exit locator\n\n")
		pnts <- locator()
		xpos <- pnts$x
		ypos <- pnts$y
		}

# get a length for the scale bar
length <- round((blighty.mapinfo$ylims[2] - blighty.mapinfo$ylims[1]) * 0.10, 0)
vec <- pretty(seq(0, length, length=4))
length <- max(vec)

# draw a simple scale bar with annotation beneath it
segments(xpos - (length / 2), ypos, xpos + (length / 2), ypos, lwd=width)
text(xpos, ypos - (length / 5), labels=paste(length, "km", sep=" "), adj=0.5)
}
<bytecode: 0x6322f10>
<environment: namespace:blighty>
 --- function (body) search ---
Function map.scale in namespace blighty has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
