
R Under development (unstable) (2018-10-04 r75396) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "flowViz"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('flowViz')
Loading required package: flowCore
Loading required package: lattice
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("contour-methods")
> ### * contour-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: contour-methods
> ### Title: Contour plots for flow data
> ### Aliases: contour contour,ANY-method contour,flowFrame-method
> ###   contour,flowSet-method contour-methods
> ### Keywords: methods
> 
> ### ** Examples
> 
> data(GvHD)
> 
> ## simple contour plot
> contour(GvHD[[1]])
> 
> ## overlay with existing plot
> plot(GvHD[[1]], c("FSC-H", "SSC-H"))
> contour(GvHD[[1]], add=TRUE, col="lightgray", lty=3)
> 
> ## colored contours
> contour(GvHD[[1]], fill="red")
> cols <- rainbow(3, alpha=0.1)
> contour(GvHD[[1]], fill=cols, col=cols)
> 
> ## overlay of multiple flowFrames in a flowSet
> contour(GvHD[1:3], col=cols, fill=cols)
> 
> 
> 
> cleanEx()
> nameEx("densityplot")
> ### * densityplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: densityplot
> ### Title: One-dimensional density/histogram plots for flow data
> ### Aliases: densityplot densityplot,formula,flowFrame-method
> ###   densityplot,formula,flowSet-method densityplot,formula,view-method
> ###   histogram,formula,flowFrame-method histogram,formula,flowSet-method
> ###   panel.densityplot.flowset.stack prepanel.densityplot.flowset.stack
> 
> ### ** Examples
> 
> library(flowStats)
Loading required package: fda
Loading required package: splines
Loading required package: Matrix

Attaching package: ‘Matrix’

The following object is masked from ‘package:flowCore’:

    %&%


Attaching package: ‘fda’

The following object is masked from ‘package:graphics’:

    matplot

Loading required package: cluster
Loading required package: flowWorkspace
Loading required package: ncdfFlow
Loading required package: RcppArmadillo
Loading required package: BH
> data(GvHD)
> GvHD <- GvHD[pData(GvHD)$Patient %in% 6:7]
> 
> densityplot(~ `FSC-H`, GvHD)
> 
> densityplot(~ `FSC-H` + `SSC-H`, GvHD)
> 
> densityplot(~ ., GvHD[1:3])
> 
> ## include a filter
> densityplot(~ `FSC-H`, GvHD, filter=curv1Filter("FSC-H"))
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/Rtmp1IuaYb/R.INSTALL27f140cf185a/flowViz/R/densityplot.R#411: 
 --- package (from environment) --- 
flowViz
 --- call from context --- 
(function(x, y, darg=list(n=50, na.rm=TRUE), frames, channel,
             overlap = 0.3, channel.name, filter=NULL,
             fill=superpose.polygon$col,
             lty=superpose.polygon$lty,
             lwd=superpose.polygon$lwd,
             alpha=superpose.polygon$alpha,
             col=superpose.polygon$border,
             groups=NULL, refline=NULL,
             margin=0.005
			 ,stats=FALSE
			 ,pos=0.5
			 ,digits=2
			 ,abs=FALSE
			 ,fitGate=TRUE
             ,checkName = TRUE
             , plotType = "densityplot"
             , hist.type = "density"
             , breaks = "Sturges"
             ,gp, ...)
{
	
    
    which.channel <- tail(which.packet(), 1)
    
    lc <- length(channel)
    channel <- channel[[which.channel]]
    channel.name <- channel.name[which.channel]
    ycode <- as.numeric(y)
    validName <- !length(grep("\\(", channel.name))
    if(checkName)
      validName <- !(length(grep("\\(", channel.name)) ||
            length(grep("\\(", channel.name)))
    else
      validName <- TRUE
    
    if(!validName)
      warning("Gate will not be plotted because channel names contain '(' character! Try to set checkName to FALSE to skip this check.")

    if (any(duplicated(ycode)))
        warning("Some combinations seem to have multiple samples.  \n  ",
                "Only one will be used.")
    nnm <- as.character(x)
    filter <- .processFilter(filter, nnm, lc = lc, which.channel = which.channel)  
    ny <- nlevels(y)
	superpose.polygon <- flowViz.par.get("superpose.polygon")
    border <- rep(col, length = ny)
    col <- rep(fill, length = ny)
    if(!is.null(groups))
        col <- col[groups]
    lty <- rep(lty, length = ny)
    lwd <- rep(lwd, length = ny)
    alpha <- rep(alpha, length = ny)
    x <- as.character(x)
    height <- (1 + overlap)
    parm <- gsub("`", "", as.character(channel))
	ptList<-plotType("gdensity", parm)
    for (i in rev(seq_len(ny))){
        if (i %in% ycode)
        {
            nm <- x[match(i, ycode)]
            xx <- evalInFlowFrame(channel, frames[[nm]])
            r <- unlist(range(frames[[nm]])[, channel.name])
            
            if(!is.logical(margin)||isTRUE(margin))#when margin is logical FALSE we skip marginal events filtering
            {
              margin <- min(1, max(0, margin))
              pl <- xx<=r[1]
              pr <- xx>=r[2]
              xxt <- xx[!(pl | pr)]
              ## we indicate piled up data by vertical lines (if > 1%) unless
              ## margin=FALSE
              if(margin<1)
                  mbar(xx, list(pl, pr), r, i, col[i], margin)
              }else
                xxt <- xx
            ## we need a smaller bandwidth than the default and keep it constant
            if(length(xxt)){
                
                if(plotType == "densityplot"){
                  #densityplot
                  if(!("adjust" %in% names(darg)))
                    darg[["adjust"]] <- 2
                  
                  h <- do.call(density, c(list(x=xxt), darg))
                  x.val <- h$x
                  y.val <- h$y
                  n <- length(x.val)
                }else{
                  fitGate <- FALSE
                  #histogram
                  h <- lattice:::hist.constructor(xxt, breaks = breaks, ...)
                  y.val <- switch(hist.type, count = h$counts, percent = 100 * h$counts/length(x), density = h$density)
                  x.val <- h$breaks
                  n <- length(x.val)
                  if (length(y.val) != n - 1) 
                    warning("problem with 'hist' computations")
                }

                max.d <- max(y.val)
                xl <- x.val[c(1, 1:n, n)]
                yl <- i + height * c(0, y.val, 0) / max.d
                
                if(plotType == "densityplot")
                  panel.polygon(x=xl,y=yl, col=col[i], border=NA, alpha=alpha[i])
                else
                  panel.rect(x = xl[-n], y = 0, height = yl, width = diff(xl), 
                      col = col[i], alpha = alpha[i], border = border[i], just = c("left", "bottom"), identifier = "histogram")
                
                ## add the filterResult if possible, we get them from the output of
                ## glpolygon (with plot=FALSE)
				
                if(!is.null(filter[[nm]]) && validName){
                  curFilter <- filter[[nm]]
                  
                  if(is.list(stats))
                    curStats <- stats[[nm]]
                  else
                    curStats <- stats
#                browser()
                if(is(curFilter,"filters"))
                {
                  mapply(curFilter,curStats,FUN=function(thisFilter,thisStats){
#                        browser()              
                         names <- .getStats(thisFilter,thisStats, frames[[nm]], digits, ...)
                        

                        #this plot routine is only for 2-d scatter plot
                        #thus set plot as FALSE,just use it to get bounds
                        #add plot stats/names
                        bounds <- glpolygon(thisFilter, frames[[nm]],
                            channels=parm
                            ,ptList=ptList
                            ,verbose=FALSE
                            , plot=FALSE 
                            ,names=names
                            ,xlim=r
                            ,ylim=c(i,i+1)
                            ,strict=FALSE)
                        oo <- options(warn=-1)
                        on.exit(options(oo))
                        if(!is.na(bounds)){
                          ## iterate over gate regions
                          for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
                            if(fitGate)
                            {
                              if(ncol(tb) == 1 && colnames(tb) == parm){
                                sel <- xl >= min(tb) & xl <= max(tb)
                                if(any(sel)){
                                  afun <- approxfun(xl, yl)
                                  xr <- c(min(tb), seq(min(tb), max(tb), len=100),
                                      max(tb))
                                  yr <- c(i, afun(xr[-c(1, length(xr))]), i)
                                  gpd<-gp$gate.density
                                  panel.polygon(xr, yr
                                      , border=gpd$col, col=gpd$fill,
                                      alpha=gpd$alpha, lwd=gpd$lwd,
                                      lty=gpd$lty
                                  )
                                }
                              }	
                            }else
                            {
#								browser()
                              gpg<-gp$gate
                              panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                              panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                            }
                            
                          }
                        }
                        
                        
                        
                        options(oo)
                      })
                }else
                {
					curFilter<-filter[[nm]]
#					browser()
                    if(is.list(stats))
                      thisStats <- stats[[nm]]
                    else
                      thisStats <- stats
                    names <- .getStats(curFilter,thisStats, frames[[nm]], digits, ...)
					
#					browser()
					#this plot routine is only for 2-d scatter plot
					#thus set plot as FALSE,just use it to get bounds
					#add plot stats/names
                    bounds <- glpolygon(curFilter, frames[[nm]],
                                        channels=parm
										,ptList=ptList
                                        ,verbose=FALSE
										, plot=FALSE 
										,names=names
										,xlim=r
										,ylim=c(i,i+1)
										,strict=FALSE)
                    oo <- options(warn=-1)
                    on.exit(options(oo))
                    if(!is.na(bounds)){
                        ## iterate over gate regions
                        for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
							if(fitGate)
							{
								if(ncol(tb) == 1 && colnames(tb) == parm){
									sel <- xl >= min(tb) & xl <= max(tb)
									if(any(sel)){
										afun <- approxfun(xl, yl)
										xr <- c(min(tb), seq(min(tb), max(tb), len=100),
												max(tb))
										yr <- c(i, afun(xr[-c(1, length(xr))]), i)
										gpd<-gp$gate.density
										panel.polygon(xr, yr
												, border=gpd$col, col=gpd$fill,
												alpha=gpd$alpha, lwd=gpd$lwd,
												lty=gpd$lty
												)
									}
								}	
							}else
							{
#								browser()
								gpg<-gp$gate
								panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
								panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
							}
                            
                        }
                    }
					
					
					
                    options(oo)
                }
               }
#				browser()
                panel.lines(x=xl,y=yl, col=border[i], lty=lty[i],lwd=lwd[i])

            }else{
                panel.lines(rl, rep(i,2), col="black")
            }
			
        }
    }
    if(!is.null(refline))
        panel.abline(v=refline)
})(x = quote(1:14), y = quote(1:14), subscripts = quote(1:14), 
    filter = quote(new("curv1Filter", bwFac = 1.2, gridsize = c(401, 
    401), parameters = new("parameters", .Data = list(new("unitytransform", 
        .Data = function () 
        NULL, parameters = "FSC-H", transformationId = "defaultUnityTransform"))), 
        filterId = "defaultCurv1Filter")), plotType = quote("densityplot"), 
    gp = quote(list(gate = list(alpha = 1, cex = NULL, pch = NULL, 
        col = "#9E0142", fill = "transparent", lwd = 1, lty = "solid"), 
        gate.text = list(font = 1, col = "#000000", alpha = 1, 
            cex = 0.8, lineheight = 0.8, background = list(fill = "white", 
                col = "transparent", alpha = 1)), overlay.symbol = list(
            alpha = 0.5, bg.alpha = 0.3, col = "transparent", 
            fill = "red", cex = 0.5, pch = 19), flow.symbol = list(
            alpha = 1, cex = 0.1, pch = 19, col = "black", fill = "transparent"), 
        gate.density = list(alpha = 1, fill = "#FFFFFFB3", col = "black", 
            lwd = 1, lty = "dotted"), argcolramp = function(n) {
            x <- ramp(seq.int(0, 1, length.out = n))
            rgb(x[, 1L], x[, 2L], x[, 3L], maxColorValue = 255, alpha = alpha * 255)
          }, grid.pars = list(), fontsize = list(text = 12, points = 8), 
        background = list(alpha = 1, col = "transparent"), panel.background = list(
            col = "grey90"), clip = list(panel = "on", strip = "on"), 
        add.line = list(alpha = 1, col = "black", lty = 1, lwd = 1), 
        add.text = list(alpha = 1, cex = 0.8, col = "black", 
            font = 1, lineheight = 1.2), plot.polygon = list(
            alpha = 1, col = "grey20", border = "transparent", 
            lty = 1, lwd = 1), box.dot = list(alpha = 1, col = "grey20", 
            cex = 1, font = 1, pch = "|"), box.rectangle = list(
            alpha = 1, col = "grey20", fill = "white", lty = 1, 
            lwd = 1), box.umbrella = list(alpha = 1, col = "grey20", 
            lty = 1, lwd = 1), dot.line = list(alpha = 1, col = "white", 
            lty = 1, lwd = 1), dot.symbol = list(alpha = 1, cex = 0.8, 
            col = "black", font = 1, pch = 19), plot.line = list(
            alpha = 1, col = "black", lty = 1, lwd = 1), plot.symbol = list(
            alpha = 1, cex = 0.6, col = "black", font = 1, pch = 19, 
            fill = "transparent"), reference.line = list(alpha = 1, 
            col = "white", lty = 1, lwd = 1), strip.background = list(
            alpha = 1, col = c("grey80", "grey70", "grey60")), 
        strip.shingle = list(alpha = 1, col = c("grey60", "grey50", 
        "grey40")), strip.border = list(alpha = 1, col = "transparent", 
            lty = c(1, 1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 
            1, 1, 1)), superpose.line = list(alpha = 1, col = c("#F8766D", 
        "#B79F00", "#00BA38", "#00BFC4", "#619CFF", "#F564E3"
        ), lty = c(1, 1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 
        1, 1, 1)), superpose.symbol = list(alpha = c(1, 1, 1, 
        1, 1, 1, 1), cex = 0.6, col = c("#F8766D", "#B79F00", 
        "#00BA38", "#00BFC4", "#619CFF", "#F564E3"), fill = c("#CCFFFF", 
        "#FFCCFF", "#CCFFCC", "#FFE5CC", "#CCE6FF", "#FFFFCC", 
        "#FFCCCC"), font = c(1, 1, 1, 1, 1, 1, 1), pch = 19), 
        superpose.polygon = list(alpha = c(1, 1, 1, 1, 1, 1, 
        1), col = c("#F8766D", "#B79F00", "#00BA38", "#00BFC4", 
        "#619CFF", "#F564E3"), border = "transparent", lty = c(1, 
        1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 1, 1, 1)), regions = list(
            alpha = 1, col = c("#3B4FB8", "#3C4EB6", "#3D4DB4", 
            "#3E4DB3", "#404CB1", "#414CB0", "#424BAE", "#434BAC", 
            "#454AAB", "#464AA9", "#4749A8", "#4849A6", "#4A48A4", 
            "#4B48A3", "#4C47A1", "#4D47A0", "#4F469E", "#50469C", 
            "#51459B", "#524599", "#544498", "#554396", "#564394", 
            "#574293", "#594291", "#5A4190", "#5B418E", "#5C408C", 
            "#5E408B", "#5F3F89", "#603F88", "#613E86", "#633E84", 
            "#643D83", "#653D81", "#663C80", "#683C7E", "#693B7C", 
            "#6A3B7B", "#6B3A79", "#6D3978", "#6E3976", "#6F3874", 
            "#703873", "#723771", "#733770", "#74366E", "#75366C", 
            "#77356B", "#783569", "#793468", "#7A3466", "#7C3365", 
            "#7D3363", "#7E3261", "#7F3260", "#81315E", "#82315D", 
            "#83305B", "#843059", "#862F58", "#872E56", "#882E55", 
            "#892D53", "#8B2D51", "#8C2C50", "#8D2C4E", "#8E2B4D", 
            "#902B4B", "#912A49", "#922A48", "#932946", "#952945", 
            "#962843", "#972841", "#982740", "#9A273E", "#9B263D", 
            "#9C263B", "#9D2539", "#9F2438", "#A02436", "#A12335", 
            "#A22333", "#A42231", "#A52230", "#A6212E", "#A7212D", 
            "#A9202B", "#AA2029", "#AB1F28", "#AC1F26", "#AE1E25", 
            "#AF1E23", "#B01D21", "#B11D20", "#B31C1E", "#B41C1D", 
            "#B51B1B", "#B71B1A")), shade.colors = list(alpha = 1, 
            palette = function(irr, ref, height, saturation = .9) {
                             hsv(h = height, s = 1 - saturation * (1 - (1-ref)^0.5), v = irr)
                         }), axis.line = list(alpha = 1, col = "transparent", 
            lty = 1, lwd = 1), axis.text = list(alpha = 1, cex = 0.8, 
            col = "grey50", font = 1, lineheight = 0.9), axis.components = list(
            left = list(tck = 1, pad1 = 1, pad2 = 1), top = list(
                tck = 1, pad1 = 1, pad2 = 1), right = list(tck = 1, 
                pad1 = 1, pad2 = 1), bottom = list(tck = 1, pad1 = 1, 
                pad2 = 1)), layout.heights = list(top.padding = 1, 
            main = 1, main.key.padding = 1, key.top = 1, xlab.top = 1, 
            key.axis.padding = 1, axis.top = 1, strip = 1, panel = 1, 
            axis.panel = 1, between = 1, axis.bottom = 1, axis.xlab.padding = 1, 
            xlab = 1, xlab.key.padding = 0, key.bottom = 1, key.sub.padding = 1, 
            sub = 1, bottom.padding = 1), layout.widths = list(
            left.padding = 1, key.left = 1, key.ylab.padding = 0, 
            ylab = 1, ylab.axis.padding = 1, axis.left = 1, axis.panel = 1, 
            strip.left = 1, panel = 1, between = 1, axis.right = 1, 
            axis.key.padding = 1, ylab.right = 1, key.right = 1, 
            right.padding = 1), box.3d = list(alpha = 1, col = "black", 
            lty = 1, lwd = 1), par.xlab.text = list(alpha = 1, 
            cex = 1, col = "black", font = 1, lineheight = 1), 
        par.ylab.text = list(alpha = 1, cex = 1, col = "black", 
            font = 1, lineheight = 1), par.zlab.text = list(alpha = 1, 
            cex = 1, col = "black", font = 1, lineheight = 1), 
        par.main.text = list(alpha = 1, cex = 1.2, col = "black", 
            font = 2, lineheight = 1), par.sub.text = list(alpha = 1, 
            cex = 1, col = "black", font = 2, lineheight = 1))), 
    channel = quote(list(`FSC-H` = `FSC-H`)), channel.name = quote(c(`FSC-H` = "FSC-H")), 
    frames = quote(<environment>), overlap = quote(0.3), which.channel = quote(c("FSC-H", 
    "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H", 
    "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H")), box.ratio = quote(1), 
    horizontal = quote(TRUE))
 --- call from argument --- 
if (!is.na(bounds)) {
    for (j in seq_along(bounds)) {
        tb <- bounds[[j]]
        if (fitGate) {
            if (ncol(tb) == 1 && colnames(tb) == parm) {
                sel <- xl >= min(tb) & xl <= max(tb)
                if (any(sel)) {
                  afun <- approxfun(xl, yl)
                  xr <- c(min(tb), seq(min(tb), max(tb), len = 100), 
                    max(tb))
                  yr <- c(i, afun(xr[-c(1, length(xr))]), i)
                  gpd <- gp$gate.density
                  panel.polygon(xr, yr, border = gpd$col, col = gpd$fill, 
                    alpha = gpd$alpha, lwd = gpd$lwd, lty = gpd$lty)
                }
            }
        }
        else {
            gpg <- gp$gate
            panel.lines(x = c(tb[1], tb[1]), y = c(i, i + height), 
                col = gpg$col, alpha = gpg$alpha, lwd = gpg$lwd, 
                lty = gpg$lty)
            panel.lines(x = c(tb[2], tb[2]), y = c(i, i + height), 
                col = gpg$col, alpha = gpg$alpha, lwd = gpg$lwd, 
                lty = gpg$lty)
        }
    }
}
 --- R stacktrace ---
where 1: (function(x, y, darg=list(n=50, na.rm=TRUE), frames, channel,
             overlap = 0.3, channel.name, filter=NULL,
             fill=superpose.polygon$col,
             lty=superpose.polygon$lty,
             lwd=superpose.polygon$lwd,
             alpha=superpose.polygon$alpha,
             col=superpose.polygon$border,
             groups=NULL, refline=NULL,
             margin=0.005
			 ,stats=FALSE
			 ,pos=0.5
			 ,digits=2
			 ,abs=FALSE
			 ,fitGate=TRUE
             ,checkName = TRUE
             , plotType = "densityplot"
             , hist.type = "density"
             , breaks = "Sturges"
             ,gp, ...)
{
	
    
    which.channel <- tail(which.packet(), 1)
    
    lc <- length(channel)
    channel <- channel[[which.channel]]
    channel.name <- channel.name[which.channel]
    ycode <- as.numeric(y)
    validName <- !length(grep("\\(", channel.name))
    if(checkName)
      validName <- !(length(grep("\\(", channel.name)) ||
            length(grep("\\(", channel.name)))
    else
      validName <- TRUE
    
    if(!validName)
      warning("Gate will not be plotted because channel names contain '(' character! Try to set checkName to FALSE to skip this check.")

    if (any(duplicated(ycode)))
        warning("Some combinations seem to have multiple samples.  \n  ",
                "Only one will be used.")
    nnm <- as.character(x)
    filter <- .processFilter(filter, nnm, lc = lc, which.channel = which.channel)  
    ny <- nlevels(y)
	superpose.polygon <- flowViz.par.get("superpose.polygon")
    border <- rep(col, length = ny)
    col <- rep(fill, length = ny)
    if(!is.null(groups))
        col <- col[groups]
    lty <- rep(lty, length = ny)
    lwd <- rep(lwd, length = ny)
    alpha <- rep(alpha, length = ny)
    x <- as.character(x)
    height <- (1 + overlap)
    parm <- gsub("`", "", as.character(channel))
	ptList<-plotType("gdensity", parm)
    for (i in rev(seq_len(ny))){
        if (i %in% ycode)
        {
            nm <- x[match(i, ycode)]
            xx <- evalInFlowFrame(channel, frames[[nm]])
            r <- unlist(range(frames[[nm]])[, channel.name])
            
            if(!is.logical(margin)||isTRUE(margin))#when margin is logical FALSE we skip marginal events filtering
            {
              margin <- min(1, max(0, margin))
              pl <- xx<=r[1]
              pr <- xx>=r[2]
              xxt <- xx[!(pl | pr)]
              ## we indicate piled up data by vertical lines (if > 1%) unless
              ## margin=FALSE
              if(margin<1)
                  mbar(xx, list(pl, pr), r, i, col[i], margin)
              }else
                xxt <- xx
            ## we need a smaller bandwidth than the default and keep it constant
            if(length(xxt)){
                
                if(plotType == "densityplot"){
                  #densityplot
                  if(!("adjust" %in% names(darg)))
                    darg[["adjust"]] <- 2
                  
                  h <- do.call(density, c(list(x=xxt), darg))
                  x.val <- h$x
                  y.val <- h$y
                  n <- length(x.val)
                }else{
                  fitGate <- FALSE
                  #histogram
                  h <- lattice:::hist.constructor(xxt, breaks = breaks, ...)
                  y.val <- switch(hist.type, count = h$counts, percent = 100 * h$counts/length(x), density = h$density)
                  x.val <- h$breaks
                  n <- length(x.val)
                  if (length(y.val) != n - 1) 
                    warning("problem with 'hist' computations")
                }

                max.d <- max(y.val)
                xl <- x.val[c(1, 1:n, n)]
                yl <- i + height * c(0, y.val, 0) / max.d
                
                if(plotType == "densityplot")
                  panel.polygon(x=xl,y=yl, col=col[i], border=NA, alpha=alpha[i])
                else
                  panel.rect(x = xl[-n], y = 0, height = yl, width = diff(xl), 
                      col = col[i], alpha = alpha[i], border = border[i], just = c("left", "bottom"), identifier = "histogram")
                
                ## add the filterResult if possible, we get them from the output of
                ## glpolygon (with plot=FALSE)
				
                if(!is.null(filter[[nm]]) && validName){
                  curFilter <- filter[[nm]]
                  
                  if(is.list(stats))
                    curStats <- stats[[nm]]
                  else
                    curStats <- stats
#                browser()
                if(is(curFilter,"filters"))
                {
                  mapply(curFilter,curStats,FUN=function(thisFilter,thisStats){
#                        browser()              
                         names <- .getStats(thisFilter,thisStats, frames[[nm]], digits, ...)
                        

                        #this plot routine is only for 2-d scatter plot
                        #thus set plot as FALSE,just use it to get bounds
                        #add plot stats/names
                        bounds <- glpolygon(thisFilter, frames[[nm]],
                            channels=parm
                            ,ptList=ptList
                            ,verbose=FALSE
                            , plot=FALSE 
                            ,names=names
                            ,xlim=r
                            ,ylim=c(i,i+1)
                            ,strict=FALSE)
                        oo <- options(warn=-1)
                        on.exit(options(oo))
                        if(!is.na(bounds)){
                          ## iterate over gate regions
                          for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
                            if(fitGate)
                            {
                              if(ncol(tb) == 1 && colnames(tb) == parm){
                                sel <- xl >= min(tb) & xl <= max(tb)
                                if(any(sel)){
                                  afun <- approxfun(xl, yl)
                                  xr <- c(min(tb), seq(min(tb), max(tb), len=100),
                                      max(tb))
                                  yr <- c(i, afun(xr[-c(1, length(xr))]), i)
                                  gpd<-gp$gate.density
                                  panel.polygon(xr, yr
                                      , border=gpd$col, col=gpd$fill,
                                      alpha=gpd$alpha, lwd=gpd$lwd,
                                      lty=gpd$lty
                                  )
                                }
                              }	
                            }else
                            {
#								browser()
                              gpg<-gp$gate
                              panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                              panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                            }
                            
                          }
                        }
                        
                        
                        
                        options(oo)
                      })
                }else
                {
					curFilter<-filter[[nm]]
#					browser()
                    if(is.list(stats))
                      thisStats <- stats[[nm]]
                    else
                      thisStats <- stats
                    names <- .getStats(curFilter,thisStats, frames[[nm]], digits, ...)
					
#					browser()
					#this plot routine is only for 2-d scatter plot
					#thus set plot as FALSE,just use it to get bounds
					#add plot stats/names
                    bounds <- glpolygon(curFilter, frames[[nm]],
                                        channels=parm
										,ptList=ptList
                                        ,verbose=FALSE
										, plot=FALSE 
										,names=names
										,xlim=r
										,ylim=c(i,i+1)
										,strict=FALSE)
                    oo <- options(warn=-1)
                    on.exit(options(oo))
                    if(!is.na(bounds)){
                        ## iterate over gate regions
                        for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
							if(fitGate)
							{
								if(ncol(tb) == 1 && colnames(tb) == parm){
									sel <- xl >= min(tb) & xl <= max(tb)
									if(any(sel)){
										afun <- approxfun(xl, yl)
										xr <- c(min(tb), seq(min(tb), max(tb), len=100),
												max(tb))
										yr <- c(i, afun(xr[-c(1, length(xr))]), i)
										gpd<-gp$gate.density
										panel.polygon(xr, yr
												, border=gpd$col, col=gpd$fill,
												alpha=gpd$alpha, lwd=gpd$lwd,
												lty=gpd$lty
												)
									}
								}	
							}else
							{
#								browser()
								gpg<-gp$gate
								panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
								panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
							}
                            
                        }
                    }
					
					
					
                    options(oo)
                }
               }
#				browser()
                panel.lines(x=xl,y=yl, col=border[i], lty=lty[i],lwd=lwd[i])

            }else{
                panel.lines(rl, rep(i,2), col="black")
            }
			
        }
    }
    if(!is.null(refline))
        panel.abline(v=refline)
})(x = quote(1:14), y = quote(1:14), subscripts = quote(1:14), 
    filter = quote(new("curv1Filter", bwFac = 1.2, gridsize = c(401, 
    401), parameters = new("parameters", .Data = list(new("unitytransform", 
        .Data = function () 
        NULL, parameters = "FSC-H", transformationId = "defaultUnityTransform"))), 
        filterId = "defaultCurv1Filter")), plotType = quote("densityplot"), 
    gp = quote(list(gate = list(alpha = 1, cex = NULL, pch = NULL, 
        col = "#9E0142", fill = "transparent", lwd = 1, lty = "solid"), 
        gate.text = list(font = 1, col = "#000000", alpha = 1, 
            cex = 0.8, lineheight = 0.8, background = list(fill = "white", 
                col = "transparent", alpha = 1)), overlay.symbol = list(
            alpha = 0.5, bg.alpha = 0.3, col = "transparent", 
            fill = "red", cex = 0.5, pch = 19), flow.symbol = list(
            alpha = 1, cex = 0.1, pch = 19, col = "black", fill = "transparent"), 
        gate.density = list(alpha = 1, fill = "#FFFFFFB3", col = "black", 
            lwd = 1, lty = "dotted"), argcolramp = function(n) {
            x <- ramp(seq.int(0, 1, length.out = n))
            rgb(x[, 1L], x[, 2L], x[, 3L], maxColorValue = 255, alpha = alpha * 255)
          }, grid.pars = list(), fontsize = list(text = 12, points = 8), 
        background = list(alpha = 1, col = "transparent"), panel.background = list(
            col = "grey90"), clip = list(panel = "on", strip = "on"), 
        add.line = list(alpha = 1, col = "black", lty = 1, lwd = 1), 
        add.text = list(alpha = 1, cex = 0.8, col = "black", 
            font = 1, lineheight = 1.2), plot.polygon = list(
            alpha = 1, col = "grey20", border = "transparent", 
            lty = 1, lwd = 1), box.dot = list(alpha = 1, col = "grey20", 
            cex = 1, font = 1, pch = "|"), box.rectangle = list(
            alpha = 1, col = "grey20", fill = "white", lty = 1, 
            lwd = 1), box.umbrella = list(alpha = 1, col = "grey20", 
            lty = 1, lwd = 1), dot.line = list(alpha = 1, col = "white", 
            lty = 1, lwd = 1), dot.symbol = list(alpha = 1, cex = 0.8, 
            col = "black", font = 1, pch = 19), plot.line = list(
            alpha = 1, col = "black", lty = 1, lwd = 1), plot.symbol = list(
            alpha = 1, cex = 0.6, col = "black", font = 1, pch = 19, 
            fill = "transparent"), reference.line = list(alpha = 1, 
            col = "white", lty = 1, lwd = 1), strip.background = list(
            alpha = 1, col = c("grey80", "grey70", "grey60")), 
        strip.shingle = list(alpha = 1, col = c("grey60", "grey50", 
        "grey40")), strip.border = list(alpha = 1, col = "transparent", 
            lty = c(1, 1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 
            1, 1, 1)), superpose.line = list(alpha = 1, col = c("#F8766D", 
        "#B79F00", "#00BA38", "#00BFC4", "#619CFF", "#F564E3"
        ), lty = c(1, 1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 
        1, 1, 1)), superpose.symbol = list(alpha = c(1, 1, 1, 
        1, 1, 1, 1), cex = 0.6, col = c("#F8766D", "#B79F00", 
        "#00BA38", "#00BFC4", "#619CFF", "#F564E3"), fill = c("#CCFFFF", 
        "#FFCCFF", "#CCFFCC", "#FFE5CC", "#CCE6FF", "#FFFFCC", 
        "#FFCCCC"), font = c(1, 1, 1, 1, 1, 1, 1), pch = 19), 
        superpose.polygon = list(alpha = c(1, 1, 1, 1, 1, 1, 
        1), col = c("#F8766D", "#B79F00", "#00BA38", "#00BFC4", 
        "#619CFF", "#F564E3"), border = "transparent", lty = c(1, 
        1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 1, 1, 1)), regions = list(
            alpha = 1, col = c("#3B4FB8", "#3C4EB6", "#3D4DB4", 
            "#3E4DB3", "#404CB1", "#414CB0", "#424BAE", "#434BAC", 
            "#454AAB", "#464AA9", "#4749A8", "#4849A6", "#4A48A4", 
            "#4B48A3", "#4C47A1", "#4D47A0", "#4F469E", "#50469C", 
            "#51459B", "#524599", "#544498", "#554396", "#564394", 
            "#574293", "#594291", "#5A4190", "#5B418E", "#5C408C", 
            "#5E408B", "#5F3F89", "#603F88", "#613E86", "#633E84", 
            "#643D83", "#653D81", "#663C80", "#683C7E", "#693B7C", 
            "#6A3B7B", "#6B3A79", "#6D3978", "#6E3976", "#6F3874", 
            "#703873", "#723771", "#733770", "#74366E", "#75366C", 
            "#77356B", "#783569", "#793468", "#7A3466", "#7C3365", 
            "#7D3363", "#7E3261", "#7F3260", "#81315E", "#82315D", 
            "#83305B", "#843059", "#862F58", "#872E56", "#882E55", 
            "#892D53", "#8B2D51", "#8C2C50", "#8D2C4E", "#8E2B4D", 
            "#902B4B", "#912A49", "#922A48", "#932946", "#952945", 
            "#962843", "#972841", "#982740", "#9A273E", "#9B263D", 
            "#9C263B", "#9D2539", "#9F2438", "#A02436", "#A12335", 
            "#A22333", "#A42231", "#A52230", "#A6212E", "#A7212D", 
            "#A9202B", "#AA2029", "#AB1F28", "#AC1F26", "#AE1E25", 
            "#AF1E23", "#B01D21", "#B11D20", "#B31C1E", "#B41C1D", 
            "#B51B1B", "#B71B1A")), shade.colors = list(alpha = 1, 
            palette = function(irr, ref, height, saturation = .9) {
                             hsv(h = height, s = 1 - saturation * (1 - (1-ref)^0.5), v = irr)
                         }), axis.line = list(alpha = 1, col = "transparent", 
            lty = 1, lwd = 1), axis.text = list(alpha = 1, cex = 0.8, 
            col = "grey50", font = 1, lineheight = 0.9), axis.components = list(
            left = list(tck = 1, pad1 = 1, pad2 = 1), top = list(
                tck = 1, pad1 = 1, pad2 = 1), right = list(tck = 1, 
                pad1 = 1, pad2 = 1), bottom = list(tck = 1, pad1 = 1, 
                pad2 = 1)), layout.heights = list(top.padding = 1, 
            main = 1, main.key.padding = 1, key.top = 1, xlab.top = 1, 
            key.axis.padding = 1, axis.top = 1, strip = 1, panel = 1, 
            axis.panel = 1, between = 1, axis.bottom = 1, axis.xlab.padding = 1, 
            xlab = 1, xlab.key.padding = 0, key.bottom = 1, key.sub.padding = 1, 
            sub = 1, bottom.padding = 1), layout.widths = list(
            left.padding = 1, key.left = 1, key.ylab.padding = 0, 
            ylab = 1, ylab.axis.padding = 1, axis.left = 1, axis.panel = 1, 
            strip.left = 1, panel = 1, between = 1, axis.right = 1, 
            axis.key.padding = 1, ylab.right = 1, key.right = 1, 
            right.padding = 1), box.3d = list(alpha = 1, col = "black", 
            lty = 1, lwd = 1), par.xlab.text = list(alpha = 1, 
            cex = 1, col = "black", font = 1, lineheight = 1), 
        par.ylab.text = list(alpha = 1, cex = 1, col = "black", 
            font = 1, lineheight = 1), par.zlab.text = list(alpha = 1, 
            cex = 1, col = "black", font = 1, lineheight = 1), 
        par.main.text = list(alpha = 1, cex = 1.2, col = "black", 
            font = 2, lineheight = 1), par.sub.text = list(alpha = 1, 
            cex = 1, col = "black", font = 2, lineheight = 1))), 
    channel = quote(list(`FSC-H` = `FSC-H`)), channel.name = quote(c(`FSC-H` = "FSC-H")), 
    frames = quote(<environment>), overlap = quote(0.3), which.channel = quote(c("FSC-H", 
    "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H", 
    "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H", "FSC-H")), box.ratio = quote(1), 
    horizontal = quote(TRUE))
where 2 at /var/scratch2/tomas/tmp/RtmpOFhoqE/R.INSTALL5725778598b/lattice/R/miscellaneous.R#44: do.call(FUN, args, quote = TRUE)
where 3 at /var/scratch2/tomas/tmp/RtmpOFhoqE/R.INSTALL5725778598b/lattice/R/print.trellis.R#1190: checkArgsAndCall(panel, pargs)
where 4: doTryCatch(return(expr), name, parentenv, handler)
where 5: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 6: tryCatchList(expr, classes, parentenv, handlers)
where 7 at /var/scratch2/tomas/tmp/RtmpOFhoqE/R.INSTALL5725778598b/lattice/R/print.trellis.R#1190: tryCatch(checkArgsAndCall(panel, pargs), error = function(e) panel.error(e))
where 8 at /var/scratch2/tomas/tmp/RtmpOFhoqE/R.INSTALL5725778598b/lattice/R/print.trellis.R#198: printFunction(x, ...)
where 9: print.trellis(x)
where 10: (function (x, ...) 
UseMethod("print"))(x)

 --- value of length: 2 type: logical ---
[1] TRUE TRUE
 --- function from context --- 
function(x, y, darg=list(n=50, na.rm=TRUE), frames, channel,
             overlap = 0.3, channel.name, filter=NULL,
             fill=superpose.polygon$col,
             lty=superpose.polygon$lty,
             lwd=superpose.polygon$lwd,
             alpha=superpose.polygon$alpha,
             col=superpose.polygon$border,
             groups=NULL, refline=NULL,
             margin=0.005
			 ,stats=FALSE
			 ,pos=0.5
			 ,digits=2
			 ,abs=FALSE
			 ,fitGate=TRUE
             ,checkName = TRUE
             , plotType = "densityplot"
             , hist.type = "density"
             , breaks = "Sturges"
             ,gp, ...)
{
	
    
    which.channel <- tail(which.packet(), 1)
    
    lc <- length(channel)
    channel <- channel[[which.channel]]
    channel.name <- channel.name[which.channel]
    ycode <- as.numeric(y)
    validName <- !length(grep("\\(", channel.name))
    if(checkName)
      validName <- !(length(grep("\\(", channel.name)) ||
            length(grep("\\(", channel.name)))
    else
      validName <- TRUE
    
    if(!validName)
      warning("Gate will not be plotted because channel names contain '(' character! Try to set checkName to FALSE to skip this check.")

    if (any(duplicated(ycode)))
        warning("Some combinations seem to have multiple samples.  \n  ",
                "Only one will be used.")
    nnm <- as.character(x)
    filter <- .processFilter(filter, nnm, lc = lc, which.channel = which.channel)  
    ny <- nlevels(y)
	superpose.polygon <- flowViz.par.get("superpose.polygon")
    border <- rep(col, length = ny)
    col <- rep(fill, length = ny)
    if(!is.null(groups))
        col <- col[groups]
    lty <- rep(lty, length = ny)
    lwd <- rep(lwd, length = ny)
    alpha <- rep(alpha, length = ny)
    x <- as.character(x)
    height <- (1 + overlap)
    parm <- gsub("`", "", as.character(channel))
	ptList<-plotType("gdensity", parm)
    for (i in rev(seq_len(ny))){
        if (i %in% ycode)
        {
            nm <- x[match(i, ycode)]
            xx <- evalInFlowFrame(channel, frames[[nm]])
            r <- unlist(range(frames[[nm]])[, channel.name])
            
            if(!is.logical(margin)||isTRUE(margin))#when margin is logical FALSE we skip marginal events filtering
            {
              margin <- min(1, max(0, margin))
              pl <- xx<=r[1]
              pr <- xx>=r[2]
              xxt <- xx[!(pl | pr)]
              ## we indicate piled up data by vertical lines (if > 1%) unless
              ## margin=FALSE
              if(margin<1)
                  mbar(xx, list(pl, pr), r, i, col[i], margin)
              }else
                xxt <- xx
            ## we need a smaller bandwidth than the default and keep it constant
            if(length(xxt)){
                
                if(plotType == "densityplot"){
                  #densityplot
                  if(!("adjust" %in% names(darg)))
                    darg[["adjust"]] <- 2
                  
                  h <- do.call(density, c(list(x=xxt), darg))
                  x.val <- h$x
                  y.val <- h$y
                  n <- length(x.val)
                }else{
                  fitGate <- FALSE
                  #histogram
                  h <- lattice:::hist.constructor(xxt, breaks = breaks, ...)
                  y.val <- switch(hist.type, count = h$counts, percent = 100 * h$counts/length(x), density = h$density)
                  x.val <- h$breaks
                  n <- length(x.val)
                  if (length(y.val) != n - 1) 
                    warning("problem with 'hist' computations")
                }

                max.d <- max(y.val)
                xl <- x.val[c(1, 1:n, n)]
                yl <- i + height * c(0, y.val, 0) / max.d
                
                if(plotType == "densityplot")
                  panel.polygon(x=xl,y=yl, col=col[i], border=NA, alpha=alpha[i])
                else
                  panel.rect(x = xl[-n], y = 0, height = yl, width = diff(xl), 
                      col = col[i], alpha = alpha[i], border = border[i], just = c("left", "bottom"), identifier = "histogram")
                
                ## add the filterResult if possible, we get them from the output of
                ## glpolygon (with plot=FALSE)
				
                if(!is.null(filter[[nm]]) && validName){
                  curFilter <- filter[[nm]]
                  
                  if(is.list(stats))
                    curStats <- stats[[nm]]
                  else
                    curStats <- stats
#                browser()
                if(is(curFilter,"filters"))
                {
                  mapply(curFilter,curStats,FUN=function(thisFilter,thisStats){
#                        browser()              
                         names <- .getStats(thisFilter,thisStats, frames[[nm]], digits, ...)
                        

                        #this plot routine is only for 2-d scatter plot
                        #thus set plot as FALSE,just use it to get bounds
                        #add plot stats/names
                        bounds <- glpolygon(thisFilter, frames[[nm]],
                            channels=parm
                            ,ptList=ptList
                            ,verbose=FALSE
                            , plot=FALSE 
                            ,names=names
                            ,xlim=r
                            ,ylim=c(i,i+1)
                            ,strict=FALSE)
                        oo <- options(warn=-1)
                        on.exit(options(oo))
                        if(!is.na(bounds)){
                          ## iterate over gate regions
                          for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
                            if(fitGate)
                            {
                              if(ncol(tb) == 1 && colnames(tb) == parm){
                                sel <- xl >= min(tb) & xl <= max(tb)
                                if(any(sel)){
                                  afun <- approxfun(xl, yl)
                                  xr <- c(min(tb), seq(min(tb), max(tb), len=100),
                                      max(tb))
                                  yr <- c(i, afun(xr[-c(1, length(xr))]), i)
                                  gpd<-gp$gate.density
                                  panel.polygon(xr, yr
                                      , border=gpd$col, col=gpd$fill,
                                      alpha=gpd$alpha, lwd=gpd$lwd,
                                      lty=gpd$lty
                                  )
                                }
                              }	
                            }else
                            {
#								browser()
                              gpg<-gp$gate
                              panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                              panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                            }
                            
                          }
                        }
                        
                        
                        
                        options(oo)
                      })
                }else
                {
					curFilter<-filter[[nm]]
#					browser()
                    if(is.list(stats))
                      thisStats <- stats[[nm]]
                    else
                      thisStats <- stats
                    names <- .getStats(curFilter,thisStats, frames[[nm]], digits, ...)
					
#					browser()
					#this plot routine is only for 2-d scatter plot
					#thus set plot as FALSE,just use it to get bounds
					#add plot stats/names
                    bounds <- glpolygon(curFilter, frames[[nm]],
                                        channels=parm
										,ptList=ptList
                                        ,verbose=FALSE
										, plot=FALSE 
										,names=names
										,xlim=r
										,ylim=c(i,i+1)
										,strict=FALSE)
                    oo <- options(warn=-1)
                    on.exit(options(oo))
                    if(!is.na(bounds)){
                        ## iterate over gate regions
                        for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
							if(fitGate)
							{
								if(ncol(tb) == 1 && colnames(tb) == parm){
									sel <- xl >= min(tb) & xl <= max(tb)
									if(any(sel)){
										afun <- approxfun(xl, yl)
										xr <- c(min(tb), seq(min(tb), max(tb), len=100),
												max(tb))
										yr <- c(i, afun(xr[-c(1, length(xr))]), i)
										gpd<-gp$gate.density
										panel.polygon(xr, yr
												, border=gpd$col, col=gpd$fill,
												alpha=gpd$alpha, lwd=gpd$lwd,
												lty=gpd$lty
												)
									}
								}	
							}else
							{
#								browser()
								gpg<-gp$gate
								panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
								panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
							}
                            
                        }
                    }
					
					
					
                    options(oo)
                }
               }
#				browser()
                panel.lines(x=xl,y=yl, col=border[i], lty=lty[i],lwd=lwd[i])

            }else{
                panel.lines(rl, rep(i,2), col="black")
            }
			
        }
    }
    if(!is.null(refline))
        panel.abline(v=refline)
}
<bytecode: 0x176dc1b8>
<environment: namespace:flowViz>
 --- function search by body ---
Function panel.densityplot.flowset.stack in namespace flowViz has this body.
 ----------- END OF FAILURE REPORT -------------- 
Fatal error: the condition has length > 1
