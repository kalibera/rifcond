
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "EBS"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('EBS')
EBS v3.1 Loaded 

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("CardE0")
> ### * CardE0
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CardE0
> ### Title: Prior probability of E0
> ### Aliases: CardE0
> 
> ### ** Examples
> 
> # probability that two profiles of size 100 have their 1st and second change-point at same location
> # when segmented into 5 segments: 
> n<-100
> k<-c(1,3)
> K<-c(5,5)
> CardE0(n,k,K,TRUE)
[1] 0.01015484
> 
> 
> 
> cleanEx()
> nameEx("CardMK")
> ### * CardMK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CardMK
> ### Title: Number of segmentations in K segments
> ### Aliases: CardMK
> 
> ### ** Examples
> 
> # number of partitions of {1, 100} in 5 segments: 
> n<-100
> K<-5
> CardMK(n,K)
[1] 3764376
> 
> 
> 
> cleanEx()
> nameEx("Col")
> ### * Col
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Col
> ### Title: Generic function
> ### Aliases: Col
> ### Keywords: methods Col
> 
> ### ** Examples
> 
> x=new("EBSProfiles") # new EBSProfiles object
> Col(x) # retrieves the Col slot from x
list()
> 
> 
> 
> cleanEx()
> nameEx("CompCredibility")
> ### * CompCredibility
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CompCredibility
> ### Title: Comparison of two profiles with credibility intervals
> ### Aliases: CompCredibility CompCredibility.default print.Credibility
> ###   plot.Credibility
> 
> ### ** Examples
> 
> # changes for Poisson model
> set.seed(1)
> x1<-c(rpois(125,1),rpois(100,5),rpois(50,1),rpois(75,5),rpois(50,1))
> x2<-c(rpois(125,3),rpois(75,4),rpois(75,1),rpois(125,8))
> M<-rbind(x1,x2)
> E <- EBSProfiles(M,model=1,K=10)
> out<-CompCredibility(E,Conditions=c(1,2),Tau=c(1,1),K=c(5,4))
> 
> 
> 
> cleanEx()
> nameEx("Data")
> ### * Data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Data
> ### Title: Generic function
> ### Aliases: Data
> ### Keywords: methods Data
> 
> ### ** Examples
> 
> x=new("EBSProfiles") # new EBSProfiles object
> Data(x) # retrieves the Data from x
<0 x 0 matrix>
> 
> 
> 
> cleanEx()
> nameEx("EBS-class")
> ### * EBS-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EBS-class
> ### Title: Class "EBS"
> ### Aliases: EBS-class 'EBS-method, show' EBS-method,getModel
> ###   EBS-method,getLi EBS-method,getCol EBS-method,getLength
> ###   EBS-method,getP EBS-method,getOverdispersion EBS-method,getData
> ###   EBS-method,getKmax EBS-method,getHyperParameters
> ###   EBS-method,getVariance EBS-method,getPriorm
> ### Keywords: classes EBS
> 
> ### ** Examples
> 
> showClass("EBS") # shows the structure of the cpt class
Class "EBS" [package "EBS"]

Slots:
                                                                      
Name:            model            data          length            Kmax
Class:       character         numeric         numeric         numeric
                                                                      
Name:  HyperParameters        Variance  overdispersion              Li
Class:         numeric         numeric         numeric          matrix
                                                      
Name:              Col        matProba            unif
Class:          matrix          matrix         logical
> 
> data<-c(rpois(100,2),rpois(100,5))
> # creates a new EBS object containing the segmentation of x
> E<-EBSegmentation(data) 
> class(E) # verifies the class of E
[1] "EBS"
attr(,"package")
[1] "EBS"
> getModel(E) # retrieves model of the segmentation
[1] "Poisson"
> getLength(E) # retrieves the length of the signal
[1] 200
> 
> 
> 
> cleanEx()
> nameEx("EBS-package")
> ### * EBS-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EBS-package
> ### Title: Contains funcions that run exact bayesian changepoint methods
> ###   and return changepoint probabilities and ICL criteria for model
> ###   selection
> ### Aliases: EBS-package EBS
> ### Keywords: changepoint segmentation exact Bayesian
> 
> ### ** Examples
> 
> # changes for Poisson model
> set.seed(1)
> x<-c(rpois(125,1),rpois(100,5),rpois(50,1),rpois(75,5),rpois(50,1))
> out <- EBSegmentation(x,Kmax=20)
> bic <- EBSBIC(out)
> print(bic$NbBIC)
[1] 7
> icl <- EBSICL(out)
> print(icl$NbICL)
[1] 4
> plot(bic$BIC,type='b',pch=1,col='blue',ylim=c(0,1000))
> lines(icl$ICL,type='b',pch=2,col='red')
> EBSPlotProba(out, icl$NbICL, data=TRUE, file="my-segmentation.pdf")
> 
> # changes for Negative Binomial model, comparison of two profiles
> set.seed(1)
> x1<-c(rnbinom(125,size=0.2,prob=0.8),rnbinom(100,size=0.2, prob=0.1),
+ rnbinom(50,size=0.2,prob=0.6),rnbinom(75,size=0.2, prob=0.95),
+ rnbinom(50,size=0.2,prob=0.25))
> x2<-c(rnbinom(125,size=0.15,prob=0.75),rnbinom(75,size=0.15,prob=0.2),
+ rnbinom(75,size=0.15,prob=0.9),rnbinom(125,size=0.15,prob=0.1))
> M<-rbind(x1,x2)
> E <- EBSProfiles(M,model=3,K=10,homoscedastic=TRUE) 
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpQoY3yD/R.INSTALL44295be1e5f/EBS/R/Profiles.R#82: 
 --- if/while statement is in package --- 
EBS
 --- call (currently evaluated) --- 
EBSProfiles.default(M, model = 3, K = 10, homoscedastic = TRUE)
 --- R stacktrace ---
where 1 at /var/scratch2/tomas/tmp/RtmpQoY3yD/R.INSTALL44295be1e5f/EBS/R/Profiles.R#3: EBSProfiles.default(M, model = 3, K = 10, homoscedastic = TRUE)
where 2: EBSProfiles(M, model = 3, K = 10, homoscedastic = TRUE)

 --- value of length: 2 type: logical ---
[1] FALSE FALSE
 --- function (currently evaluated)--- 
function(data = numeric(), model=1, K=3, hyper = numeric(), theta = numeric(), var = numeric(), homoscedastic = FALSE, unif=TRUE)
{
  if ((model!=1)&(model!=2)&(model!=3)&(model!=4))
    stop("Choose model=1 (Poisson), 2 (Normal Homoscedastic), 3 (Negative Binomial) or 4 (Normal Heteroscedastic)")
  if (length(data)==0)
    stop("Give me a matrix of profiles to segment")
  n=ncol(data)
 	NbConditions<-length(data)/n
  hyp4<-rep(0,(4*NbConditions))
  
  if (length(K)==1)
  	K<-rep(K,NbConditions)
  if (length(K)==0)
  	K<-rep(3,NbConditions)
  if (length(K)!=NbConditions)
  	stop("Give me either one K per profile, or one common for all")
  	
  if (length(theta)==1)
  	theta<-rep(theta,NbConditions)
  if (length(var)==1)
  	var<-rep(var,NbConditions)

  if ((model==2)&(length(var)==0))
  {
  	if (homoscedastic)
  		var<-0 else
			var<-rep(0,NbConditions)
		for (i in 1:NbConditions)
		{
			data1<-data[i,-(1:3)]
			data2<-data[i,-c(1,2,n)]
			data3<-data[i,-c(1,n-1,n)]
			data4<-data[i,-c(n-2,n-1,n)]
			d<-c(0.1942, 0.2809, 0.3832, -0.8582)
			v2<-d[1]*data1+d[2]*data2+d[3]*data3+d[4]*data4
			v2<-v2*v2
			if (homoscedastic)
  			var<-var+sum(v2)/(4*n-12) else
				var[i]<-sum(v2)/(n-3)
	  }
	  if (homoscedastic)
	  	var<-rep(var, NbConditions)
  }

  if ((model==3)&(length(theta)==0))
  {
  	if (homoscedastic)
  		tall<-NULL else
  		theta<-rep(0,NbConditions)
  	for(l in 1:NbConditions)
  	{
		  h2<-15
			Xcum = cumsum(data[l,])
			X2cum = cumsum(data[l,]^2)
			MA = (Xcum[h2:n] - c(0, Xcum[1:(n-h2)])) / h2
			S2 = (X2cum[h2:n] - c(0, X2cum[1:(n-h2)])) / (h2-1) - h2/(h2-1)*MA^2
			K2 = MA^2 / (S2-MA)
			if (homoscedastic)
			{
				tall<-c(tall,K2)
			} else
			{
		  	theta[l] = median(K2[!is.na(K2)])
		  	while ((theta[l]<0)&(h2<(n/2)))
				{
					h2<-2*h2
					MA = (Xcum[h2:n] - c(0, Xcum[1:(n-h2)])) / h2
					S2 = (X2cum[h2:n] - c(0, X2cum[1:(n-h2)])) / (h2-1) - h2/(h2-1)*MA^2
					K2 = MA^2 / (S2-MA)
					theta[l] = median(K2[!is.na(K2)])   	
				}
		 	}
		  
  	}
  	if (homoscedastic)
  	{
  		theta<-rep(median(tall[!is.na(tall)]),NbConditions)
  		while((theta<0)&h2<(n/2))
  		{
  			h2<-2*h2
				for(l in 1:NbConditions)
				{
					Xcum = cumsum(data[l,])
					X2cum = cumsum(data[l,]^2)
					MA = (Xcum[h2:n] - c(0, Xcum[1:(n-h2)])) / h2
					S2 = (X2cum[h2:n] - c(0, X2cum[1:(n-h2)])) / (h2-1) - h2/(h2-1)*MA^2
					K2 = MA^2 / (S2-MA)
					tall<-c(tall,K2)
				}
				theta<-rep(median(tall[!is.na(tall)]),NbConditions)  		
  		}
  	}
  }

  if ((model==4) & (length(hyper)==0))
  	for(i in 1:NbConditions)
  	{
    	me<-median(data[1,])
    	int<-abs(data[1,]-me)
    	OK<-which(int!=0)
    	inverse<-1/int[OK]
    	y<-fitdistr(inverse,"gamma")
    	hyp4[4*(i-1)+2]<-1
    	hyp4[4*(i-1)+3]<-y$estimate[1]
    	hyp4[4*(i-1)+4]<-y$estimate[2]
    }

  if(length(hyper)==0)
    if(model==1)
			hyper=rep(c(1,1),NbConditions) else if(model==3)
			hyper=rep(c(1/2,1/2),NbConditions) else if(model==2)
			hyper=rep(c(0,1),NbConditions) else
			hyper=hyp4
  hyper=as.vector(hyper)
  
  if (((model==1)|(model==2)|(model==3)) & (length(hyper)!=(2*NbConditions)))
    stop("for Poisson, Normal Homoscedastic and Negative Binomial models, two hyper-parameters are needed for each condition")
  if ((model==4) & (length(hyper)!=(4*NbConditions)))
    stop("for Normal Heteroscedastic model four hyper-parameters are needed for each condition")
    
  Lin<-list()
  Coln<-list()
  Pn<-list()
  if ((model==3) &(length(theta)!=NbConditions))
  	stop("Give me either one theta per profile, or one common for all")
  if ((model==2) &(length(var)!=NbConditions))
  	stop("Give me either one variance per profile, or one common for all")
  	
  unif=unif
	
	for (i in 1:NbConditions)
	{
		Km<-K[i]
		Li=matrix(0,nrow=K[i],ncol=(n+1))
		Li = as.vector(Li)
		Col=matrix(0,ncol=K[i],nrow=(n+1))
		Col = as.vector(Col)
		P=matrix(0,nrow=(n+1),ncol=(n+1))
		P=as.vector(P)
		M=as.vector(data[i,])		
		if (model==4)
			hyp<-c(hyper[4*(i-1)+1],hyper[4*(i-1)+2],hyper[4*(i-1)+3],hyper[4*(i-1)+4])  else hyp<-c(hyper[2*(i-1)+1],hyper[2*(i-1)+2]) 
		if (model==3) thei<-theta[i]
		if (model==2)	vari<-var[i]

		if (model==1)
    	Rep<-.C("SegmentPoisson", Size = as.integer(n),KMax = as.integer(Km), hyper = as.double(hyp), Data = as.integer(M), Col = as.double(Col), Li = as.double(Li), P = as.double(P), u = as.logical(unif),  PACKAGE="EBS") else if (model==3)
    	Rep<-.C("SegmentBinNeg", Size = as.integer(n),KMax = as.integer(Km), hyper = as.double(hyp), theta = as.double(thei), Data = as.integer(M), Col = as.double(Col), Li = as.double(Li), P = as.double(P), u = as.logical(unif),  PACKAGE="EBS") else if (model==2)
    	Rep<-.C("SegmentGaussienneHomo", Size = as.integer(n),KMax = as.integer(Km), hyper = as.double(hyp), Var = as.double(vari), Data = as.double(M), Col = as.double(Col), Li = as.double(Li), P = as.double(P), u = as.logical(unif),  PACKAGE="EBS") else if (model==4)
    	Rep<-.C("SegmentGaussienne", Size = as.integer(n),KMax = as.integer(Km), hyper = as.double(hyp), Data = as.double(M), Col = as.double(Col), Li = as.double(Li), P = as.double(P), u = as.logical(unif),  PACKAGE="EBS")


		Lin[[i]]=t(matrix(Rep$Li,ncol=Km))
		Coln[[i]]=matrix(Rep$Col,ncol=Km)
		Pn[[i]]=t(matrix(Rep$P,ncol=(n+1)))
	}
	
	Datasets<-data
	rnames<-NULL
	for (i in 1:NbConditions)
	{
		rnames<-c(rnames,paste("Profile ",i,sep=""))
	}
	row.names(Datasets)<-rnames
  if (model==1) 
  {
      model.dist="Poisson"
      EBSProfiles.res=new("EBSProfiles", model=model.dist, data=Datasets, length=n, NbConditions = NbConditions, K=K, HyperParameters = hyper, Li=Lin, Col=Coln, P=Pn, unif=unif)
  }

  if (model==3) 
  {
      model.dist="Negative Binomial"
      EBSProfiles.res=new("EBSProfiles", model=model.dist, data=Datasets, length=n, NbConditions = NbConditions, K=K, HyperParameters = hyper, overdispersion = theta, Li=Lin, Col=Coln, P=Pn, unif=unif)
  }

  if (model==2) 
  {
      model.dist="Normal Homoscedastic"
      EBSProfiles.res=new("EBSProfiles", model=model.dist, data=Datasets, length=n, NbConditions = NbConditions, K=K, HyperParameters = hyper, Variance = var, Li=Lin, Col=Coln, P=Pn, unif=unif)
  }

  if (model==4) 
  {
      model.dist="Normal Heteroscedastic"
      EBSProfiles.res=new("EBSProfiles", model=model.dist, data=Datasets, length=n, NbConditions = NbConditions, K=K, HyperParameters = hyper, Li=Lin, Col=Coln, P=Pn, unif=unif)
  }

  EBSProfiles.res
}
<bytecode: 0x14b09c8>
<environment: namespace:EBS>
 --- function (body) search ---
Function EBSProfiles.default in namespace EBS has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
