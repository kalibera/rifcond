
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(testthat)
> library(waver)
Loading required package: rgdal
Loading required package: sp
rgdal: version: 1.2-16, (SVN revision 701)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.1.3, released 2017/20/01
 Path to GDAL shared files: /usr/share/gdal
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
WARNING: no proj_defs.dat in PROJ.4 shared files
 Linking to sp version: 1.2-7 
> 
> test_check("waver")
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpuOI1Kj/R.INSTALLc3385bc777ca/waver/R/fetch_len.R#211: 
 --- if/while statement is in package --- 
waver
 --- call (currently evaluated) --- 
fetch_len_multi(pts, bearings, lands, dmax)
 --- R stacktrace ---
where 1: fetch_len_multi(pts, bearings, lands, dmax)
where 2: withCallingHandlers(expr, warning = function(w) invokeRestart("muffleWarning"))
where 3: suppressWarnings(fetch_len_multi(pts, bearings, lands, dmax))
where 4 at /var/scratch2/tomas/tmp/RtmpBSpEFw/R.INSTALLd6806e63e92c/rlang/R/eval.R#66: .Call(rlang_eval, expr, env)
where 5 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/expectation.R#90: eval_bare(get_expr(quo), get_env(quo))
where 6 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/expect-equality.R#51: quasi_label(enquo(object), label)
where 7 at testthat/test_fetch_len.R#91: expect_equal(suppressWarnings(fetch_len_multi(pts, bearings, 
    lands, dmax)), `rownames<-`(rbind(fexp1, fexp2, fexp3), NULL), 
    tolerance = tol)
where 8: eval(code, test_env)
where 9: eval(code, test_env)
where 10: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error)
where 11: doTryCatch(return(expr), name, parentenv, handler)
where 12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 13: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 14: doTryCatch(return(expr), name, parentenv, handler)
where 15: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
    names[nh], parentenv, handlers[[nh]])
where 16: tryCatchList(expr, classes, parentenv, handlers)
where 17: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error), error = handle_fatal, 
    skip = function(e) {
    })
where 18 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-that.R#31: test_code(desc, code, env = parent.frame())
where 19 at testthat/test_fetch_len.R#90: test_that("fetch_len_multi matches fetch_len results", {
    expect_equal(suppressWarnings(fetch_len_multi(pts, bearings, 
        lands, dmax)), `rownames<-`(rbind(fexp1, fexp2, fexp3), 
        NULL), tolerance = tol)
    expect_equal(suppressWarnings(fetch_len_multi(pts, bearings, 
        lands, dmax, method = "clip")), `rownames<-`(rbind(fexp1, 
        fexp2, fexp3), NULL), tolerance = tol)
    expect_equal(suppressWarnings(fetch_len_multi(pts, bearings, 
        lands, dmax, spread)), `rownames<-`(rbind(fexp1spr, fexp2spr, 
        fexp3), NULL), tolerance = tol)
    expect_equal(suppressWarnings(fetch_len_multi(p13_prj, bearings, 
        land1_prj, dmax, projected = TRUE)), `rownames<-`(rbind(fexp1, 
        fexp3), NULL), tolerance = tol)
})
where 20: eval(code, test_env)
where 21 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-that.R#152: eval(code, test_env)
where 22: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error)
where 23: doTryCatch(return(expr), name, parentenv, handler)
where 24: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 25: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 26: doTryCatch(return(expr), name, parentenv, handler)
where 27: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
    names[nh], parentenv, handlers[[nh]])
where 28: tryCatchList(expr, classes, parentenv, handlers)
where 29 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-that.R#149: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error), error = handle_fatal, 
    skip = function(e) {
    })
where 30 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/source.R#42: test_code(NULL, exprs, env)
where 31 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-files.R#131: source_file(path, new.env(parent = env), chdir = TRUE, wrap = wrap)
where 32 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/reporter-zzz.R#53: force(code)
where 33 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-files.R#125: with_reporter(reporter = reporter, start_end_reporter = start_end_reporter, 
    {
        lister$start_file(basename(path))
        source_file(path, new.env(parent = env), chdir = TRUE, 
            wrap = wrap)
        end_context()
    })
where 34: FUN(X[[i]], ...)
where 35: lapply(paths, test_file, env = env, reporter = current_reporter, 
    start_end_reporter = FALSE, load_helpers = FALSE, wrap = wrap)
where 36 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/reporter-zzz.R#53: force(code)
where 37 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-files.R#25: with_reporter(reporter = current_reporter, results <- lapply(paths, 
    test_file, env = env, reporter = current_reporter, start_end_reporter = FALSE, 
    load_helpers = FALSE, wrap = wrap))
where 38 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-directory.R#86: test_files(paths, reporter = reporter, env = env, stop_on_failure = stop_on_failure, 
    stop_on_warning = stop_on_warning, wrap = wrap)
where 39 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-directory.R#190: test_dir(path = test_path, reporter = reporter, env = env, filter = filter, 
    ..., stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning, 
    wrap = wrap)
where 40 at /var/scratch2/tomas/tmp/Rtmpri1Vbr/R.INSTALLb8033c63809/testthat/R/test-directory.R#171: test_package_dir(package = package, test_path = test_path, filter = filter, 
    reporter = reporter, ..., stop_on_failure = stop_on_failure, 
    stop_on_warning = stop_on_warning, wrap = wrap)
where 41: test_check("waver")

 --- value of length: 2 type: logical ---
[1]  TRUE FALSE
 --- function (currently evaluated)--- 
function(pts, bearings, shoreline, dmax,
                     spread = 0, method = c("btree", "clip"), projected = FALSE) {
    # Check inputs
    match.arg(method)
    if (!is(pts, "SpatialPoints")) stop("pts must be a SpatialPoints* object.")
    pts <- as(pts, "SpatialPoints")  # remove DataFrame part if there is one
    if (is(shoreline, "SpatialLines")) {
        shoreline <- as(shoreline, "SpatialLines")
    } else if (is(shoreline, "SpatialPolygons")) {
        shoreline <- as(shoreline, "SpatialPolygons")
    } else {
        stop("shoreline must be a SpatialLines* or SpatialPolygons* object.")
    }
    if (projected) {
        if (!is.projected(pts) || !is.projected(shoreline)) {
            stop("cannot use long/lat coordinates if projected = TRUE.")
        }
        if (proj4string(pts) != proj4string(shoreline)) {
            stop("projections of pts and shoreline do not match.")
        }
    } else if (is.projected(pts) || is.projected(shoreline)) {
            stop(paste("pts and shoreline must have unprojected (long/lat)",
                       "coordinates if projected = FALSE."))
    }
    if (!is.vector(bearings, "numeric")) stop("bearings must be a numeric vector.")
    if (!is.vector(spread, "numeric")) stop("spread must be a numeric vector.")
    if (!is.vector(dmax, "numeric") || length(dmax) != 1 || dmax <= 0) {
        stop("dmax must be a single number greater than 0.")
    }

    # Create rectangular buffers around each point
    rect_list <- lapply(1:length(pts),
                        function(i) get_clip_rect(pts[i], dmax, projected))
    rect_buf <- do.call(rbind, c(rect_list, makeUniqueIDs = TRUE))

    if (method == "btree") {
        # Generate list of shoreline polygon IDs with bounding box overlap for each rectangle
        btree <- rgeos::gBinarySTRtreeQuery(shoreline, rect_buf)
        # Calculate fetch for point at index i using btree
        fetch_i <- function(i) {
            if (is.null(btree[[i]])) {
                setNames(rep(dmax, length(bearings)), bearings)
            } else {
                fetch_len(pts[i], bearings, shoreline[btree[[i]]], dmax,
                          spread, projected, check_inputs = FALSE)
            }
        }
        # Calculate fetch for all points and return a (points x bearings) matrix
        fetch_res <- t(vapply(1:length(pts), fetch_i, rep(0, length(bearings))))
    } else { # method == "clip"
        # Clip shoreline to a merged buffer around all points
        rect_buf <- rgeos::gUnaryUnion(rect_buf)
        sub_shore <- rgeos::gIntersection(shoreline, rect_buf, byid = TRUE)
        fetch_res <- t(
            vapply(1:length(pts),
                   function(i) fetch_len(pts[i], bearings, sub_shore, dmax,
                                         spread, projected, check_inputs = FALSE),
                   rep(0, length(bearings)))
        )
    }
    fetch_res
}
<environment: namespace:waver>
 --- function (body) search ---
Function fetch_len_multi in namespace waver has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
