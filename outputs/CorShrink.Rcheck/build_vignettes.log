Due to absence of package REBayes, switching to EM algorithm
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpqVuzKQ/R.INSTALLea9d68eaad72/CorShrink/R/CorShrinkMatrix.R#217: 
 --- if/while statement is in package --- 
CorShrink
 --- call (currently evaluated) --- 
CorShrinkMatrix(cormat, nsamp, zscore_sd = NULL, thresh_up = thresh_up, 
    thresh_down = thresh_down, image_original = image_original, 
    image_corshrink = image_corshrink, tol = tol, image.control = image.control, 
    optmethod = optmethod, ash.control = ash.control)
 --- R stacktrace ---
where 1 at /var/scratch2/tomas/tmp/RtmpqVuzKQ/R.INSTALLea9d68eaad72/CorShrink/R/CorShrinkData.R#67: CorShrinkMatrix(cormat, nsamp, zscore_sd = NULL, thresh_up = thresh_up, 
    thresh_down = thresh_down, image_original = image_original, 
    image_corshrink = image_corshrink, tol = tol, image.control = image.control, 
    optmethod = optmethod, ash.control = ash.control)
where 2: CorShrinkData(data, sd_boot = FALSE, image_original = TRUE, image_corshrink = TRUE, 
    optmethod = "mixEM", image.control = list(x.cex = 0.3, y.cex = 0.3))
where 3: eval(expr, envir, enclos)
where 4: eval(expr, envir, enclos)
where 5: withVisible(eval(expr, envir, enclos))
where 6: withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, 
    error = eHandler, message = mHandler)
where 7: handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, 
    enclos)), warning = wHandler, error = eHandler, message = mHandler))
where 8: timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, 
    envir, enclos)), warning = wHandler, error = eHandler, message = mHandler)))
where 9: evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, 
    debug = debug, last = i == length(out), use_try = stop_on_error != 
        2L, keep_warning = keep_warning, keep_message = keep_message, 
    output_handler = output_handler, include_timing = include_timing)
where 10 at /var/scratch2/tomas/tmp/RtmpJ3m6tZ/R.INSTALL62535b5d8aec/knitr/R/hooks.R#17: evaluate::evaluate(...)
where 11: evaluate(code, envir = env, new_device = FALSE, keep_warning = !isFALSE(options$warning), 
    keep_message = !isFALSE(options$message), stop_on_error = if (options$error && 
        options$include) 0L else 2L, output_handler = knit_handlers(options$render, 
        options))
where 12: in_dir(input_dir(), evaluate(code, envir = env, new_device = FALSE, 
    keep_warning = !isFALSE(options$warning), keep_message = !isFALSE(options$message), 
    stop_on_error = if (options$error && options$include) 0L else 2L, 
    output_handler = knit_handlers(options$render, options)))
where 13: block_exec(params)
where 14 at /var/scratch2/tomas/tmp/RtmpJ3m6tZ/R.INSTALL62535b5d8aec/knitr/R/block.R#6: call_block(x)
where 15 at /var/scratch2/tomas/tmp/RtmpJ3m6tZ/R.INSTALL62535b5d8aec/knitr/R/block.R#3: process_group.block(group)
where 16: process_group(group)
where 17 at /var/scratch2/tomas/tmp/RtmpJ3m6tZ/R.INSTALL62535b5d8aec/knitr/R/output.R#314: withCallingHandlers(if (tangle) process_tangle(group) else process_group(group), 
    error = function(e) {
        setwd(wd)
        cat(res, sep = "\n", file = output %n% "")
        message("Quitting from lines ", paste(current_lines(i), 
            collapse = "-"), " (", knit_concord$get("infile"), 
            ") ")
    })
where 18 at /var/scratch2/tomas/tmp/RtmpJ3m6tZ/R.INSTALL62535b5d8aec/knitr/R/output.R#258: process_file(text, output)
where 19 at /var/scratch2/tomas/tmp/RtmpiFnhvf/R.INSTALL2032429d4002/rmarkdown/R/render.R#486: knitr::knit(knit_input, knit_output, envir = envir, quiet = quiet, 
    encoding = encoding)
where 20 at /var/scratch2/tomas/tmp/RtmpJ3m6tZ/R.INSTALL62535b5d8aec/knitr/R/utils-vignettes.R#40: rmarkdown::render(file, encoding = encoding, quiet = quiet, envir = globalenv())
where 21 at /var/scratch2/tomas/tmp/RtmpJ3m6tZ/R.INSTALL62535b5d8aec/knitr/R/utils-vignettes.R#92: vweave_rmarkdown(...)
where 22: engine$weave(file, quiet = quiet, encoding = enc)
where 23: doTryCatch(return(expr), name, parentenv, handler)
where 24: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 25: tryCatchList(expr, classes, parentenv, handlers)
where 26: tryCatch({
    engine$weave(file, quiet = quiet, encoding = enc)
    setwd(startdir)
    find_vignette_product(name, by = "weave", engine = engine)
}, error = function(e) {
    stop(gettextf("processing vignette '%s' failed with diagnostics:\n%s", 
        file, conditionMessage(e)), domain = NA, call. = FALSE)
})
where 27: buildVignettes(dir = "/var/scratch2/tomas/test/mine/R-ifc4/check/CorShrink.Rcheck/vign_test/CorShrink")

 --- value of length: 10 type: logical ---
 [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 --- function (currently evaluated)--- 
function(cormat, nsamp = NULL,
                        zscore_sd = NULL,
                        thresh_up = 0.99, thresh_down = - 0.99,
                        image_original=FALSE, image_corshrink = FALSE,
                        tol=1e-06,
                        image.control = list(),
                        optmethod = "mixEM",
                        ash.control = list())
{
  image.control.default <- list(x.las = 2,
                                x.cex = 0.7,
                                y.las = 2,
                                y.cex = 0.7,
                                main_original = "sample corr matrix",
                                main_corshrink = "CorShrink matrix",
                                cex.main = 1,
                                col=c(rev(rgb(seq(1,0,length=1000),1,seq(1,0,length=1000))),
                                      rgb(1,seq(1,0,length=1000),seq(1,0,length=1000))))
  image.control <- modifyList(image.control.default, image.control)

  if(is.null(zscore_sd) && is.null(nsamp)){
    stop("User must provide wither an nsamp or a zscore_sd arguments")
  }

  cormat[is.na(cormat)] = 0

  if(is.null(rownames(cormat))){
    rownames(cormat) <- 1:dim(cormat)[1]
  }

  if(is.null(colnames(cormat))){
    colnames(cormat) <- 1:dim(cormat)[2]
  }

  if(!is.null(zscore_sd)){
    zscore_sd[is.na(zscore_sd)] = 0
  }

  if(!is.null(nsamp)){
    nsamp[is.na(nsamp)] <- 0
  }

  ##############  Set control parameters for adaptive shrinkage  ################

  ash.control.default = list(pointmass = TRUE,
                             mixcompdist = "normal", nullweight = 10,
                             fixg = FALSE, mode = 0,
                             prior = "nullbiased", gridmult = sqrt(2),
                             outputlevel = 2, alpha = 0,
                             df = NULL)
  ash.control <- modifyList(ash.control.default, ash.control)

  ##################   vectorise the correlation matrix  ###################

  cor_table <- reshape2::melt(cormat);
  cor_table_non_diag <- cor_table[which(cor_table[,1] != cor_table[,2]),];

  ##################  thresholding very low or very high correlations ##########

  cor_table_non_diag.val <- cor_table_non_diag[,3];
  cor_table_non_diag.val[which(cor_table_non_diag.val >= thresh_up)]= thresh_up;
  cor_table_non_diag.val[which(cor_table_non_diag.val <= thresh_down)]= thresh_down;

  ##################  Compute Fisher z-transform  ###########################

  cor_transform_mean_vec=0.5*log((1+cor_table_non_diag.val)/(1-cor_table_non_diag.val))

  ################ Compute standard errors of Fisher z-transform  ############


  if(is.null(zscore_sd) && (length(nsamp) == 1)){
    nsamples <- as.numeric(round(nsamp))
    if(nsamples <= 2){
      stop("the number of samples <=2 for all cells, will result in Identity correlation matrix in CorShrink")
    }
    cor_transform_sd_vec=rep(sqrt(1/(nsamples-1) + 2/(nsamples - 1)^2), dim(cor_table_non_diag)[1]);
  }else if(is.null(zscore_sd) && is.matrix(nsamp)){

    nsamp_tab <- reshape2::melt(nsamp)
    nsamp_tab_non_diag <- nsamp_tab[which(nsamp_tab[,1] != nsamp_tab[,2]),];
    nsamp_vec <- nsamp_tab_non_diag[,3]
    index_zeros <- which(nsamp_vec <= 2)
    cor_transform_mean_vec[index_zeros] = 0;
    nsamp_vec_2 <- nsamp_vec
    nsamp_vec_2[index_zeros] <- 1.00001
    cor_transform_sd_vec <- sqrt(1/(nsamp_vec_2-1) + 2/(nsamp_vec_2 - 1)^2);

  }else{
    if(is.null(zscore_sd)){
      stop("if sd_boot is not NULL, the user needs to provide a cor trasform sd vector")
    }
    cor_transform_sd_mat <- reshape2::melt(as.matrix(zscore_sd))
    cor_transform_sd_non_diag <- cor_transform_sd_mat[which(cor_transform_sd_mat[,1] != cor_transform_sd_mat[,2]),];
    cor_transform_sd_vec <- cor_transform_sd_non_diag[,3]
    index_zeros <- which(cor_transform_sd_vec  == 0)
    cor_transform_sd_vec[index_zeros] <- 10^8
  }

  options(warn=-1)

  ##################   Adaptive Shrinkage (Fisher Z scores) ################

  fit=do.call(ashr::ash, append(list(betahat = cor_transform_mean_vec,
                                     sebetahat = cor_transform_sd_vec,
                                     optmethod = optmethod),
                                ash.control))


  ###############   Inverse Fisher z-score transformation  ##################

  ash_cor_vec=(exp(2*fit$result$PosteriorMean)-1)/(exp(2*fit$result$PosteriorMean)+1);

  newdata.table <- cor_table_non_diag;
  newdata.table[,3] <- ash_cor_vec;
  ash_cor_only <- reshape2::dcast(newdata.table, Var1~Var2, value.var = "value")[,-1];
  ash_cor_only[is.na(ash_cor_only)]=1;
  rownames(ash_cor_only) <- rownames(cormat)
  colnames(ash_cor_only) <- colnames(cormat)


  ###############  Positive definite matrix completion of corShrink #############

  pd_completion <- Matrix::nearPD(as.matrix(ash_cor_only), conv.tol=tol);
  ash_cor_PD <- sweep(pd_completion$mat,diag(as.matrix(pd_completion$mat)), MARGIN=1,"/")


  if(is.null(rownames(cormat))){
    rownames(cormat) <- 1:dim(cormat)[1]
  }
  if(is.null(colnames(cormat))){
    colnames(cormat) <- 1:dim(cormat)[2]
  }

  row_labs <- rownames(cormat)
  col_labs <- colnames(cormat)

   if(image_original) {
      image(as.matrix(cormat), col=image.control$col, main = image.control$main_original,
            cex.main=image.control$cex.main, xaxt = "n", yaxt = "n", zlim=c(-1,1))
      axis(1, at = seq(0, 1, length.out = ncol(cormat)),
           labels = row_labs, las=image.control$x.las, cex.axis = image.control$x.cex)
      axis(2, at = seq(0, 1, length.out = ncol(cormat)),
           labels = col_labs, las=image.control$y.las, cex.axis = image.control$y.cex)
   }

    if(image_corshrink){
      image(as.matrix(ash_cor_PD), col=image.control$col, main=image.control$main_corshrink,
            cex.main=image.control$cex.main, xaxt = "n", yaxt = "n", zlim=c(-1,1))
      axis(1, at = seq(0, 1, length.out = ncol(cormat)),
           labels = row_labs, las=image.control$x.las, cex.axis = image.control$x.cex)
      axis(2, at = seq(0, 1, length.out = ncol(cormat)),
           labels = col_labs, las=image.control$y.las, cex.axis = image.control$y.cex)
    }

  if(all.equal(target=ash_cor_only, current=ash_cor_PD, tolerance=tol)==TRUE){
    message("ash cor only and ash cor PD matrices are same")
  }else{
    message("ash cor only and ash cor PD matrices are different")
  }
  ll <- list("ash_cor_only"= ash_cor_only, "ash_cor_PD"=as.matrix(ash_cor_PD))
  return(ll)
}
<environment: namespace:CorShrink>
 --- function (body) search ---
Function CorShrinkMatrix in namespace CorShrink has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
