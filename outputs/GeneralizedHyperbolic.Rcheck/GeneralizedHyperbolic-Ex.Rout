
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "GeneralizedHyperbolic"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('GeneralizedHyperbolic')
Loading required package: DistributionUtils
Loading required package: RUnit
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("ArkansasRiver")
> ### * ArkansasRiver
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ArkansasRiver
> ### Title: Soil Electrical Conductivity
> ### Aliases: ArkansasRiver
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(ArkansasRiver)
> lapply(ArkansasRiver, summary)
$upstream
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.107   2.767   3.255   4.104   4.602  18.977 

$downstream
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  2.296   4.360   5.361   5.986   7.009  15.182 

> upstream <- ArkansasRiver[[1]]
> downstream <- ArkansasRiver[[2]]
> ## Fit normal inverse Gaussian
> ## Hyperbolic can also be fitted but fit is not as good
> fitUpstream <- nigFit(upstream)
> summary(fitUpstream)

Data:      upstream 
Parameter estimates:
    mu   delta   alpha    beta  
2.5557  0.6616  1.5825  1.4551  
Likelihood:         -1441.33 
Method:             Nelder-Mead 
Convergence code:   0 
Iterations:         223 
> par(mfrow = c(2,2))
> plot(fitUpstream)
> fitDownstream <- nigFit(downstream)
> summary(fitDownstream)

Data:      downstream 
Parameter estimates:
   mu  delta  alpha   beta  
3.052  1.292  3.649  3.340  
Likelihood:         -880.0715 
Method:             Nelder-Mead 
Convergence code:   0 
Iterations:         293 
> plot(fitDownstream)
> par(mfrow = c(1,1))
> ## Combined plot to compare
> ## Reproduces Figure 3 from Morway and Gates (2011)
> hist(upstream, col = "grey", xlab = "", ylab = "", cex.axis = 1.25,
+      main = "", breaks = seq(0,20, by = 1), xlim = c(0,15), las = 1,
+      ylim = c(0,0.5), freq = FALSE)
> param <- coef(fitUpstream)
> nigDens <- function(x) dnig(x, param = param)
> curve(nigDens, 0, 15, n = 201, add = TRUE,
+       ylab = NULL, col = "red", lty = 1, lwd = 1.7)
> 
> hist(downstream, add = TRUE, col = "black", angle = 45, density = 15,
+      breaks = seq(0,20, by = 1), freq = FALSE)
> param <- coef(fitDownstream)
> nigDens <- function(x) dnig(x, param = param)
> curve(nigDens, 0, 15, n = 201, add = TRUE,
+       ylab = NULL, col = "red", lty = 1, lwd = 1.7)
> 
> mtext(expression(EC[e]), side = 1, line = 3, cex = 1.25)
> mtext("Frequency", side = 2, line = 3, cex = 1.25)
> legend(x = 7.5, y = 0.250, c("Upstream Region","Downstream Region"),
+        col = c("black","black"), density = c(NA,25),
+        fill = c("grey","black"), angle = c(NA,45),
+        cex = 1.25, bty = "n", xpd = TRUE)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("SandP500")
> ### * SandP500
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SandP500
> ### Title: S&P 500
> ### Aliases: SandP500
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(SandP500)
> ### Consider proportional changes in the index
> change <- SandP500[-length(SandP500)] / SandP500[-1]
> hist(change)
> ### Fit hyperbolic distribution to changes
> hyperbFit(change)

Data:      change 
Parameter estimates:
     mu    delta    alpha     beta  
 0.8352   0.1734  15.9594   7.3532  
Likelihood:         85.05974 
criterion :         MLE 
Method:             Nelder-Mead 
Convergence code:   0 
Iterations:         361 
> 
> 
> 
> 
> cleanEx()
> nameEx("dghyp")
> ### * dghyp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GeneralizedHyperbolicDistribution
> ### Title: Generalized Hyperbolic Distribution
> ### Aliases: dghyp pghyp qghyp rghyp ddghyp
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(0, 1, 3, 1, 1/2)
> ghypRange <- ghypCalcRange(param = param, tol = 10^(-3))
> par(mfrow = c(1, 2))
> 
> ### curves of density and distribution
> curve(dghyp(x, param = param), ghypRange[1], ghypRange[2], n = 1000)
> title("Density of the \n Generalized  Hyperbolic Distribution")
> curve(pghyp(x, param = param), ghypRange[1], ghypRange[2], n = 500)
> title("Distribution Function of the \n Generalized Hyperbolic Distribution")
> 
> ### curves of density and log density
> par(mfrow = c(1, 2))
> data <- rghyp(1000, param = param)
> curve(dghyp(x, param = param), range(data)[1], range(data)[2],
+       n = 1000, col = 2)
> hist(data, freq = FALSE, add = TRUE)
> title("Density and Histogram of the\n Generalized Hyperbolic Distribution")
> logHist(data, main = "Log-Density and Log-Histogram of\n the Generalized
+       Hyperbolic Distribution")
> curve(log(dghyp(x, param = param)),
+       range(data)[1], range(data)[2],
+       n = 500, add = TRUE, col = 2)
> 
> ### plots of density and derivative
> par(mfrow = c(2, 1))
> curve(dghyp(x, param = param), ghypRange[1], ghypRange[2], n = 1000)
> title("Density of the\n Generalized  Hyperbolic Distribution")
> curve(ddghyp(x, param = param), ghypRange[1], ghypRange[2], n = 1000)
> title("Derivative of the Density of the\n Generalized Hyperbolic Distribution")
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("dgig")
> ### * dgig
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Generalized Inverse Gaussian
> ### Title: Generalized Inverse Gaussian Distribution
> ### Aliases: dgig pgig qgig rgig rgig1 ddgig
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(2, 3, 1)
> gigRange <- gigCalcRange(param = param, tol = 10^(-3))
> par(mfrow = c(1, 2))
> curve(dgig(x, param = param), from = gigRange[1], to = gigRange[2],
+       n = 1000)
> title("Density of the\n Generalized Inverse Gaussian")
> curve(pgig(x, param = param), from = gigRange[1], to = gigRange[2],
+       n = 1000)
> title("Distribution Function of the\n Generalized Inverse Gaussian")
> dataVector <- rgig(500, param = param)
> curve(dgig(x, param = param), range(dataVector)[1], range(dataVector)[2],
+       n = 500)
> hist(dataVector, freq = FALSE, add = TRUE)
> title("Density and Histogram\n of the Generalized Inverse Gaussian")
> logHist(dataVector, main =
+         "Log-Density and Log-Histogram\n of the Generalized Inverse Gaussian")
> curve(log(dgig(x, param = param)), add = TRUE,
+       range(dataVector)[1], range(dataVector)[2], n = 500)
> par(mfrow = c(2, 1))
> curve(dgig(x, param = param), from = gigRange[1], to = gigRange[2],
+       n = 1000)
> title("Density of the\n Generalized Inverse Gaussian")
> curve(ddgig(x, param = param), from = gigRange[1], to = gigRange[2],
+       n = 1000)
> title("Derivative of the Density\n of the Generalized Inverse Gaussian")
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("dhyperb")
> ### * dhyperb
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Hyperbolic
> ### Title: Hyperbolic Distribution
> ### Aliases: dhyperb phyperb qhyperb rhyperb ddhyperb
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(0, 2, 1, 0)
> hyperbRange <- hyperbCalcRange(param = param, tol = 10^(-3))
> par(mfrow = c(1, 2))
> curve(dhyperb(x, param = param), from = hyperbRange[1], to = hyperbRange[2],
+       n = 1000)
> title("Density of the\n Hyperbolic Distribution")
> curve(phyperb(x, param = param), from = hyperbRange[1], to = hyperbRange[2],
+       n = 1000)
> title("Distribution Function of the\n Hyperbolic Distribution")
> dataVector <- rhyperb(500, param = param)
> curve(dhyperb(x, param = param), range(dataVector)[1], range(dataVector)[2],
+       n = 500)
> hist(dataVector, freq = FALSE, add =TRUE)
> title("Density and Histogram\n of the Hyperbolic Distribution")
> logHist(dataVector, main =
+         "Log-Density and Log-Histogram\n of the Hyperbolic Distribution")
> curve(log(dhyperb(x, param = param)), add = TRUE,
+       range(dataVector)[1], range(dataVector)[2], n = 500)
> par(mfrow = c(2, 1))
> curve(dhyperb(x, param = param), from = hyperbRange[1], to = hyperbRange[2],
+       n = 1000)
> title("Density of the\n Hyperbolic Distribution")
> curve(ddhyperb(x, param = param), from = hyperbRange[1], to = hyperbRange[2],
+       n = 1000)
> title("Derivative of the Density\n of the Hyperbolic Distribution")
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("dnig")
> ### * dnig
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NIG
> ### Title: Normal Inverse Gaussian Distribution
> ### Aliases: dnig pnig qnig rnig ddnig
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(0, 2, 1, 0)
> nigRange <- nigCalcRange(param = param, tol = 10^(-3))
> par(mfrow = c(1, 2))
> curve(dnig(x, param = param), from = nigRange[1], to = nigRange[2],
+       n = 1000)
> title("Density of the\n Normal Inverse Gaussian Distribution")
> curve(pnig(x, param = param), from = nigRange[1], to = nigRange[2],
+       n = 1000)
> title("Distribution Function of the\n Normal Inverse Gaussian Distribution")
> dataVector <- rnig(500, param = param)
> curve(dnig(x, param = param), range(dataVector)[1], range(dataVector)[2],
+       n = 500)
> hist(dataVector, freq = FALSE, add =TRUE)
> title("Density and Histogram\n of the Normal Inverse Gaussian Distribution")
> logHist(dataVector, main =
+         "Log-Density and Log-Histogram\n of the Normal Inverse Gaussian Distribution")
> curve(log(dnig(x, param = param)), add = TRUE,
+       range(dataVector)[1], range(dataVector)[2], n = 500)
> par(mfrow = c(2, 1))
> curve(dnig(x, param = param), from = nigRange[1], to = nigRange[2],
+       n = 1000)
> title("Density of the\n Normal Inverse Gaussian Distribution")
> curve(ddnig(x, param = param), from = nigRange[1], to = nigRange[2],
+       n = 1000)
> title("Derivative of the Density\n of the Normal Inverse Gaussian Distribution")
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("dskewlap")
> ### * dskewlap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SkewLaplace
> ### Title: Skew-Laplace Distribution
> ### Aliases: dskewlap pskewlap qskewlap rskewlap
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(1, 1, 2)
> par(mfrow = c(1, 2))
> curve(dskewlap(x, param = param), from = -5, to = 8, n = 1000)
> title("Density of the\n Skew-Laplace Distribution")
> curve(pskewlap(x, param = param), from = -5, to = 8, n = 1000)
> title("Distribution Function of the\n Skew-Laplace Distribution")
> dataVector <- rskewlap(500, param = param)
> curve(dskewlap(x, param = param), range(dataVector)[1], range(dataVector)[2],
+       n = 500)
> hist(dataVector, freq = FALSE, add = TRUE)
> title("Density and Histogram\n of the Skew-Laplace Distribution")
> logHist(dataVector, main =
+         "Log-Density and Log-Histogram\n of the Skew-Laplace Distribution")
> curve(log(dskewlap(x, param = param)), add = TRUE,
+       range(dataVector)[1], range(dataVector)[2], n = 500)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("ghypCalcRange")
> ### * ghypCalcRange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ghypCalcRange
> ### Title: Range of a Generalized Hyperbolic Distribution
> ### Aliases: ghypCalcRange
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(0, 1, 5, 3, 1)
> maxDens <- dghyp(ghypMode(param = param), param = param)
> ghypRange <- ghypCalcRange(param = param, tol = 10^(-3) * maxDens)
> ghypRange
[1] -1.126003  5.216412
> curve(dghyp(x, param = param), ghypRange[1], ghypRange[2])
> ## Not run: ghypCalcRange(param = param, tol = 10^(-3), density = FALSE)
> 
> 
> 
> cleanEx()
> nameEx("ghypChangePars")
> ### * ghypChangePars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ghypChangePars
> ### Title: Change Parameterizations of the Generalized Hyperbolic
> ###   Distribution
> ### Aliases: ghypChangePars
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param1 <- c(0, 3, 2, 1, 2)               # Parameterization 1
> param2 <- ghypChangePars(1, 2, param1)   # Convert to parameterization 2
> param2                                   # Parameterization 2
      mu    delta      rho     zeta   lambda 
0.000000 3.000000 0.500000 5.196152 2.000000 
> ghypChangePars(2, 1, param2)             # Back to parameterization 1
    mu  delta  alpha   beta lambda 
     0      3      2      1      2 
> 
> 
> 
> cleanEx()
> nameEx("ghypCheckPars")
> ### * ghypCheckPars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ghypCheckPars
> ### Title: Check Parameters of the Generalized Hyperbolic Distribution
> ### Aliases: ghypCheckPars
> ### Keywords: distribution
> 
> ### ** Examples
> 
> ghypCheckPars(c(0, 2.5, -0.5, 1, 0))      # error
$case
[1] "error"

$errMessage
[1] "alpha must not be less than zero"

> ghypCheckPars(c(0, 2.5, 0.5, 0, 0))       # normal
$case
[1] "normal"

$errMessage
[1] ""

> ghypCheckPars(c(0, 1, 1, -1, 0))          # error
$case
[1] "error"

$errMessage
[1] "absolute value of beta must be less than alpha when lambda = 0"

> ghypCheckPars(c(2, 0, 1, 0.5, 0))         # error
$case
[1] "error"

$errMessage
[1] "delta must be greater than zero when lambda = 0"

> ghypCheckPars(c(0, 5, 2, 1.5, 0))         # normal
$case
[1] "normal"

$errMessage
[1] ""

> ghypCheckPars(c(0, -2.5, -0.5, 1, 1))     # error
$case
[1] "error"

$errMessage
[1] "alpha must not be less than zero"

> ghypCheckPars(c(0, -1, 0.5, 1, 1))        # error
$case
[1] "error"

$errMessage
[1] "absolute value of beta must be less than alpha and delta must be less than zero when lambda > 0"

> ghypCheckPars(c(0, 0, -0.5, -1, 1))       # error
$case
[1] "error"

$errMessage
[1] "alpha must not be less than zero"

> ghypCheckPars(c(2, 0, 0.5, 0, -1))        # error
$case
[1] "error"

$errMessage
[1] "delta must be greater than zero when lambda < 0"

> ghypCheckPars(c(2, 0, 1, 0.5, 1))         # skew laplace
$case
[1] "skew laplace"

$errMessage
[1] ""

> ghypCheckPars(c(0, 1, 1, 1, -1))          # skew hyperbolic
$case
[1] "skew hyperbolic"

$errMessage
[1] ""

> 
> 
> 
> cleanEx()
> nameEx("ghypMeanVarMode")
> ### * ghypMeanVarMode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Specific Generalized Hyperbolic Moments and Mode
> ### Title: Moments and Mode of the Generalized Hyperbolic Distribution
> ### Aliases: ghypMean ghypVar ghypSkew ghypKurt ghypMode
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(2, 2, 2, 1, 2)
> ghypMean(param = param)
[1] 4.125532
> ghypVar(param = param)
[1] 3.192044
> ghypSkew(param = param)
[1] 0.7928604
> ghypKurt(param = param)
[1] 1.343511
> ghypMode(param = param)
[1] 3.499997
> maxDens <- dghyp(ghypMode(param = param), param = param)
> ghypRange <- ghypCalcRange(param = param, tol = 10^(-3) * maxDens)
> curve(dghyp(x, param = param), ghypRange[1], ghypRange[2])
> abline(v = ghypMode(param = param), col = "blue")
> abline(v = ghypMean(param = param), col = "red")
> 
> 
> 
> cleanEx()
> nameEx("ghypMom")
> ### * ghypMom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ghypMom
> ### Title: Calculate Moments of the Generalized Hyperbolic Distribution
> ### Aliases: ghypMom
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(1, 2, 2, 1, 2)
> mu <- param[1]
> ### mu moments
> m1 <- ghypMean(param = param)
> m1 - mu
[1] 2.125532
> ghypMom(1, param = param, momType = "mu")
[1] 2.125532
> momIntegrated("ghyp", order = 1, param = param, about = mu)
[1] 2.125532
> ghypMom(2, param = param, momType = "mu")
[1] 7.709928
> momIntegrated("ghyp", order = 2, param = param, about = mu)
[1] 7.709928
> ghypMom(10, param = param, momType = "mu")
[1] 82423263
> momIntegrated("ghyp", order = 10, param = param, about = mu)
[1] 82423263
> 
> ### raw moments
> ghypMean(param = param)
[1] 3.125532
> ghypMom(1, param = param, momType = "raw")
[1] 3.125532
> momIntegrated("ghyp", order = 1, param = param, about = 0)
[1] 3.125532
> ghypMom(2, param = param, momType = "raw")
[1] 12.96099
> momIntegrated("ghyp", order = 2, param = param, about = 0)
[1] 12.96099
> ghypMom(10, param = param, momType = "raw")
[1] 198600687
> momIntegrated("ghyp", order = 10, param = param, about = 0)
[1] 198600687
> 
> ### central moments
> ghypMom(1, param = param, momType = "central")
[1] 0
> momIntegrated("ghyp", order = 1, param = param, about = m1)
[1] -2.814589e-16
> ghypVar(param = param)
[1] 3.192044
> ghypMom(2, param = param, momType = "central")
[1] 3.192044
> momIntegrated("ghyp", order = 2, param = param, about = m1)
[1] 3.192044
> ghypMom(10, param = param, momType = "central")
[1] 12276439
> momIntegrated("ghyp", order = 10, param = param, about = m1)
[1] 12276439
> 
> 
> 
> cleanEx()
> nameEx("ghypParam")
> ### * ghypParam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ghypParam
> ### Title: Parameter Sets for the Generalized Hyperbolic Distribution
> ### Aliases: ghypParam ghypSmallShape ghypLargeShape ghypSmallParam
> ###   ghypLargeParam
> 
> ### ** Examples
> 
> data(ghypParam)
> plotShapeTriangle()
> xis <- rep(c(0.1,0.3,0.5,0.7,0.9), 1:5)
> chis <- c(0,-0.25,0.25,-0.45,0,0.45,-0.65,-0.3,0.3,0.65,
+           -0.85,-0.4,0,0.4,0.85)
> points(chis, xis, pch = 20, col = "red")
> 
> 
> ## Testing the accuracy of ghypMean
> for (i in 1:nrow(ghypSmallParam)) {
+   param <- ghypSmallParam[i, ]
+   x <- rghyp(1000, param = param)
+   sampleMean <- mean(x)
+   funMean <- ghypMean(param = param)
+   difference <- abs(sampleMean - funMean)
+   print(difference)
+ }
[1] 0.0007656615
[1] 0.002179907
[1] 0.002830429
[1] 0.02345217
[1] 0.02203922
[1] 0.01529674
[1] 0.006106988
[1] 0.02421479
[1] 0.02968868
[1] 0.1776781
[1] 0.0292802
[1] 0.1731409
[1] 0.02658014
[1] 0.03096756
[1] 0.07622426
[1] 0.06365596
[1] 0.03155036
[1] 0.04787357
[1] 0.02203252
[1] 0.08401065
[1] 0.0280612
[1] 0.02415693
[1] 0.01220221
[1] 0.02123322
[1] 0.05407458
[1] 0.08574988
[1] 0.006894978
[1] 0.01818246
[1] 0.06142889
[1] 0.06127915
[1] 0.3777894
[1] 0.1478741
[1] 0.2894925
[1] 0.0151065
[1] 0.3097523
[1] 0.009386032
[1] 0.09922299
[1] 0.2409683
[1] 0.1103253
[1] 0.7306051
[1] 0.0515213
[1] 0.03797593
[1] 0.004762017
[1] 0.001170212
[1] 0.001174192
[1] 0.00344049
[1] 0.05429
[1] 0.01061508
[1] 0.01405142
[1] 0.01859159
[1] 0.02401503
[1] 0.06978022
[1] 0.2033961
[1] 0.1577259
[1] 0.0181277
[1] 0.01843048
[1] 0.1010207
[1] 0.03069699
[1] 0.04947148
[1] 0.003326429
[1] 0.09023308
[1] 0.07954656
[1] 0.1368037
[1] 0.02517571
[1] 0.02429347
[1] 0.01010252
[1] 0.1350758
[1] 0.0009427295
[1] 0.01542779
[1] 0.04645932
[1] 0.06808225
[1] 0.1792687
[1] 0.4779941
[1] 0.4726623
[1] 0.5841348
[1] 0.1004915
[1] 0.003417105
[1] 0.3309655
[1] 0.2482701
[1] 0.2549097
[1] 0.4343007
[1] 0.3106815
[1] 0.4285235
[1] 0.6039167
> 
> 
> 
> 
> cleanEx()
> nameEx("ghypScale")
> ### * ghypScale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ghypScale
> ### Title: Rescale a generalized hyperbolic distribution
> ### Aliases: ghypScale
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(2,10,0.1,0.07,-0.5) # a normal inverse Gaussian
> ghypMean(param = param)
[1] 11.80196
> ghypVar(param = param)
[1] 274.5647
> ## convert to standardized parameters
> (newParam <- ghypScale(0, 1, param = param))
        mu      delta      alpha       beta     lambda 
-0.5915488  0.6035005  1.6569995  1.1598996 -0.5000000 
> ghypMean(param = newParam)
[1] 0
> ghypVar(param = newParam)
[1] 1
> 
> ## try some other mean and sd
> (newParam <- ghypScale(1, 1, param = param))
        mu      delta      alpha       beta     lambda 
 0.4084512  0.6035005  1.6569995  1.1598996 -0.5000000 
> ghypMean(param = newParam)
[1] 1
> sqrt(ghypVar(param = newParam))
[1] 1
> (newParam <- ghypScale(10, 2, param = param))
        mu      delta      alpha       beta     lambda 
 8.8169024  1.2070010  0.8284997  0.5799498 -0.5000000 
> ghypMean(param = newParam)
[1] 10
> sqrt(ghypVar(param = newParam))
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("gigCalcRange")
> ### * gigCalcRange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gigCalcRange
> ### Title: Range of a Generalized Inverse Gaussian Distribution
> ### Aliases: gigCalcRange
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(2.5, 0.5, 5)
> maxDens <- dgig(gigMode(param = param), param = param)
> gigRange <- gigCalcRange(param = param, tol = 10^(-3) * maxDens)
> gigRange
[1]  1.400674 66.709821
> curve(dgig(x, param = param), gigRange[1], gigRange[2])
> ## Not run: gigCalcRange(param = param, tol = 10^(-3), density = FALSE)
> 
> 
> 
> cleanEx()
> nameEx("gigChangePars")
> ### * gigChangePars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gigChangePars
> ### Title: Change Parameterizations of the Generalized Inverse Gaussian
> ###   Distribution
> ### Aliases: gigChangePars
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param1 <- c(2.5, 0.5, 5)                # Parameterisation 1
> param2 <- gigChangePars(1, 2, param1)   # Convert to parameterization 2
> param2                                  # Parameterization 2
    delta     gamma    lambda 
1.5811388 0.7071068 5.0000000 
> gigChangePars(2, 1, as.numeric(param2)) # Convert back to parameterization 1
   chi    psi lambda 
   2.5    0.5    5.0 
> 
> 
> 
> cleanEx()
> nameEx("gigCheckPars")
> ### * gigCheckPars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gigCheckPars
> ### Title: Check Parameters of the Generalized Inverse Gaussian
> ###   Distribution
> ### Aliases: gigCheckPars
> ### Keywords: distribution
> 
> ### ** Examples
> 
> gigCheckPars(c(5, 2.5, -0.5))      # normal
$case
[1] "normal"

$errMessage
[1] ""

> gigCheckPars(c(-5, 2.5, 0.5))      # error
$case
[1] "error"

$errMessage
[1] "chi must be non-negative"

> gigCheckPars(c(5, -2.5, 0.5))      # error
$case
[1] "error"

$errMessage
[1] "psi must be non-negative"

> gigCheckPars(c(-5, -2.5, 0.5))     # error
$case
[1] "error"

$errMessage
[1] "chi must be non-negative"

> gigCheckPars(c(0, 2.5, 0.5))       # gamma
$case
[1] "gamma"

$errMessage
[1] ""

> gigCheckPars(c(0, 2.5, -0.5))      # error
$case
[1] "error"

$errMessage
[1] "lambda must be positive when chi = 0"

> gigCheckPars(c(0, 0, 0.5))         # error
$case
[1] "error"

$errMessage
[1] "psi and chi cannot both be 0"

> gigCheckPars(c(0, 0, -0.5))        # error
$case
[1] "error"

$errMessage
[1] "lambda must be positive when chi = 0"

> gigCheckPars(c(5, 0, 0.5))         # error
$case
[1] "error"

$errMessage
[1] "lambda must be negative when psi = 0"

> gigCheckPars(c(5, 0, -0.5))        # invgamma
$case
[1] "invgamma"

$errMessage
[1] ""

> 
> 
> 
> cleanEx()
> nameEx("gigFit")
> ### * gigFit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gigFit
> ### Title: Fit the Generalized Inverse Gausssian Distribution to Data
> ### Aliases: gigFit print.gigFit plot.gigFit coef.gigFit vcov.gigFit
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(1, 1, 1)
> dataVector <- rgig(500, param = param)
> ## See how well gigFit works
> gigFit(dataVector)

Data:      dataVector 
Parameter estimates:
      chi        psi     lambda  
0.0008274  1.4184836  1.8386314  
Likelihood:         -596.2934 
Method:             Nelder-Mead 
Convergence code:   0 
Iterations:         114 
> ##gigFit(dataVector, plots = TRUE)
> 
> ## See how well gigFit works in the limiting cases
> ## Gamma case
> dataVector2 <- rgamma(500, shape = 1, rate = 1)
> gigFit(dataVector2)

Data:      dataVector2 
Parameter estimates:
      chi        psi     lambda  
7.367e-09  1.969e+00  9.389e-01  
Likelihood:         -490.2254 
Method:             Nelder-Mead 
Convergence code:   0 
Iterations:         172 
> 
> ## Inverse gamma
> require(actuar)
Loading required package: actuar

Attaching package: ‘actuar’

The following object is masked from ‘package:grDevices’:

    cm

> dataVector3 <- rinvgamma(500, shape = 1, rate = 1)
> gigFit(dataVector3)

Data:      dataVector3 
Parameter estimates:
     chi       psi    lambda  
 2.02533   0.00282  -1.00950  
Likelihood:         443.4219 
Method:             Nelder-Mead 
Convergence code:   0 
Iterations:         142 
> 
> ## Use nlm instead of default
> gigFit(dataVector, method = "nlm")
Warning in nlm(llfunc, paramStart, iterlim = maxitNLM, ...) :
  NA/Inf replaced by maximum positive value
Warning in nlm(llfunc, paramStart, iterlim = maxitNLM, ...) :
  NA/Inf replaced by maximum positive value

Data:      dataVector 
Parameter estimates:
   chi     psi  lambda  
0.8689  1.0581  1.0522  
Likelihood:         -590.1332 
Method:             nlm 
Convergence code:    
Iterations:         NA 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:actuar’

> nameEx("gigFitStart")
> ### * gigFitStart
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gigFitStart
> ### Title: Find Starting Values for Fitting a Generalized Inverse Gaussian
> ###   Distribution
> ### Aliases: gigFitStart gigFitStartMoM gigFitStartLM
> ### Keywords: distribution
> 
> ### ** Examples
> 
> param <- c(1, 1, 1)
> dataVector <- rgig(500, param = param)
> gigFitStart(dataVector)
$paramStart
       chi        psi     lambda 
0.01000000 0.02947305 1.99840921 

$breaks
 [1]  0  1  2  3  4  5  6  7  8  9 10 11

$midpoints
 [1]  0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5

$empDens
 [1] 0.232 0.264 0.174 0.116 0.090 0.072 0.020 0.008 0.012 0.008 0.004

$svName
[1] "Linear Models"

> 
> 
> 
> cleanEx()
> nameEx("gigHessian")
> ### * gigHessian
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gigHessian
> ### Title: Calculate Two-Sided Hessian for the Generalized Inverse Gaussian
> ###   Distribution
> ### Aliases: gigHessian
> 
> ### ** Examples
> 
> ### Calculate the approximate Hessian using gigHessian:
> param <- c(1,1,1)
> dataVector <- rgig(500, param = param)
> fit <- gigFit(dataVector)
> coef <- coef(fit)
> gigHessian(x = dataVector, param = coef, hessianMethod = "tsHessian",
+               whichParam = 1)
            chi        psi    lambda
[1,]   62.00785   213.9809 -111.2925
[2,]  213.98093 -2463.5269  388.5244
[3,] -111.29252   388.5244 -173.4169
> 
> ### Or calculate the approximate Hessian using summary.gigFit method:
> summary(fit, hessian = TRUE)
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmppcdfDQ/R.INSTALL22f6277e6730/GeneralizedHyperbolic/R/gigHessian.R#4: 
 --- if/while statement is in package --- 
GeneralizedHyperbolic
 --- call (currently evaluated) --- 
gigHessian(obs, param, hessianMethod = hessianMethod, whichParam = 1)
 --- R stacktrace ---
where 1 at /var/scratch2/tomas/tmp/RtmppcdfDQ/R.INSTALL22f6277e6730/GeneralizedHyperbolic/R/summary.gigFit.R#15: gigHessian(obs, param, hessianMethod = hessianMethod, whichParam = 1)
where 2: summary.gigFit(fit, hessian = TRUE)
where 3: summary(fit, hessian = TRUE)

 --- value of length: 2 type: logical ---
[1] FALSE  TRUE
 --- function (currently evaluated)--- 
function(x, param, hessianMethod = c("tsHessian", "exact"),
                       whichParam = 1) {
  if (hessianMethod == "exact") {
    stop("Exact hessian not available yet. Use method tsHessian instead.")
  }
  if (whichParam != 1){
    stop("Only parameterization 1 has been implemented at present")
  }
  if (hessianMethod == "tsHessian") {
    llfuncH <- function(param) {
      loggigDens <- param[3]/2*log(exp(param[2])/exp(param[1])) -
                    log(2*besselK(sqrt(exp(param[1])*exp(param[2])),
                                  nu = param[3])) + (param[3] - 1)*log(x) -
                    1/2*(exp(param[1])*x^-1 + exp(param[2])*x)
      as.numeric(loggigDens)
      return(sum(loggigDens))
    }
  }

  hessian <- tsHessian(param = param, fun = llfuncH)
  return(hessian)
}
<bytecode: 0x98a4b8>
<environment: namespace:GeneralizedHyperbolic>
 --- function (body) search ---
Function gigHessian in namespace GeneralizedHyperbolic has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
