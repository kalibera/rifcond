
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "vitality"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('vitality')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("vitality.4p")
> ### * vitality.4p
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vitality.4p
> ### Title: Fitting routine for the 2-process, 4-parameter vitality model
> ###   (no childhood hook).
> ### Aliases: vitality.4p
> 
> ### ** Examples
> 
> data(swedish_females)
> swe <- swedish_females
> initial_age <- 20 # Could be adjusted
> time <- initial_age:max(swedish_females$age)
> survival_fraction <- swe$lx / swe$lx[1]
> survival_fraction <- survival_fraction[time] # when first element <1 data is adjusted
> sample_size <- swe$Lx[initial_age] #sample size
> 
> results.4par <- vitality.4p(time = time,
+                             sdata = survival_fraction,
+                             #init.params=FALSE,
+                             init.params=c(0.012, 0.01, 0.1, 0.1),
+                             lower = c(0, 0, 0, 0), upper = c(100,50,1,50),
+                             rc.data = TRUE, 
+                             se = sample_size, 
+                             datatype = "CUM", 
+                             ttol = 1e-06,
+                             pplot = TRUE,
+                             Iplot = TRUE,
+                             Mplot = TRUE,
+                             tlab = "years",
+                             silent = FALSE)
                      rsk    
[1,] "Initial r"      "0.012"
[2,] "initial s"      "0.01" 
[3,] "initial lambda" "0.1"  
[4,] "initial beta"   "0.1"  
Warning in nlminb(start = rsk, objective = logLikelihood.4p, lower = lower,  :
  NA/NaN function evaluation
Warning in nlminb(start = rsk, objective = logLikelihood.4p, lower = lower,  :
  NA/NaN function evaluation
     [,1]                           [,2]                 
[1,] "estimated r"                  "0.0104720788600492" 
[2,] "estimated s"                  "0.00769381248811434"
[3,] "estimated lambda"             "0.147910425934361"  
[4,] "estimated beta"               "0.108353549812955"  
[5,] "minimum -loglikelihood value" "3.74526359685208"   
                     s.e.                  
[1,] "sd for r"      "1.9570328643684e-05" 
[2,] "sd for s"      "7.54580901422932e-05"
[3,] "sd for lambda" "0.00507488778293214" 
[4,] "sd for beta"   "0.000820922381960018"
> 
> 
> 
> cleanEx()
> nameEx("vitality.6p")
> ### * vitality.6p
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vitality.6p
> ### Title: Fitting routine for the 2-process, 6-parameter vitality model
> ###   (with childhood hook).
> ### Aliases: vitality.6p
> 
> ### ** Examples
> 
> data(swedish_females)
> swe <- swedish_females
> initial_age <- 0 
> time <- swedish_females$age
> survival_fraction <- swe$lx / swe$lx[1]
> sample_size <- swe$Lx[1] #sample size
> 
> results.6par <- vitality.6p(time = time,
+                             sdata = survival_fraction,
+                             #init.params=FALSE,
+                             init.params=c(0.012, 0.01, 0.1, 0.1, 0.1, 1),
+                             lower = c(0, 0, 0, 0, 0, 0), upper = c(100,50,1,50,50,50),
+                             rc.data = TRUE, 
+                             se=FALSE,
+                             #se = sample_size, 
+                             datatype = "CUM", 
+                             ttol = 1e-06,
+                             pplot = TRUE,
+                             Iplot = TRUE,
+                             Mplot = TRUE,
+                             tlab = "years",
+                             silent = FALSE)
                      rsk    
[1,] "Initial r"      "0.012"
[2,] "Initial s"      "0.01" 
[3,] "Initial lambda" "0.1"  
[4,] "Initial beta"   "0.1"  
[5,] "Initial gamma"  "0.1"  
[6,] "Initial alpha"  "1"    
Warning in nlminb(start = rsk, objective = logLikelihood.6p, lower = lower,  :
  NA/NaN function evaluation
Warning in nlminb(start = rsk, objective = logLikelihood.6p, lower = lower,  :
  NA/NaN function evaluation
Warning in nlminb(start = rsk, objective = logLikelihood.6p, lower = lower,  :
  NA/NaN function evaluation
Warning in nlminb(start = rsk, objective = logLikelihood.6p, lower = lower,  :
  NA/NaN function evaluation
     [,1]                           [,2]                 
[1,] "estimated r"                  "0.0106766993752509" 
[2,] "estimated s"                  "0.00772310796722416"
[3,] "estimated lambda"             "0.122995103866105"  
[4,] "estimated beta"               "0.11525919001918"   
[5,] "estimated gamma"              "0.00764930434357127"
[6,] "estimated alpha"              "2.55022414571299"   
[7,] "minimum -loglikelihood value" "3.78556654614674"   
> 
> 
> 
> cleanEx()
> nameEx("vitality")
> ### * vitality
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vitality
> ### Title: Fitting routines for the Vitality family of mortality models.
> ### Aliases: vitality vitality-package
> 
> ### ** Examples
> 
> # vitality.k
> data(daphnia)
> time <- daphnia$days
> survival_fraction <- daphnia$lx
> 
> results.modk <- vitality.k(time = time,
+                            sdata = survival_fraction,
+                            rc.data=TRUE, 
+                            se=FALSE,
+                            gfit=FALSE, 
+                            datatype="CUM", 
+                            ttol=.000001, 
+                            init.params=FALSE, 
+                            lower=c(0,-1,0), upper=c(100,50,50), 
+                            pplot=TRUE, 
+                            tlab="days", 
+                            lplot=TRUE, 
+                            cplot=TRUE, 
+                            Iplot=TRUE, 
+                            silent=TRUE)
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpE45lTo/R.INSTALL5c4d500a09ec/vitality/R/vitality.k.R#459: 
 --- if/while statement is in package --- 
vitality
 --- call (currently evaluated) --- 
plotting.k(r.final, s.final, k.final, mlv, time, sfract, x1, 
    x2, Ni, pplot, tlab, lplot, cplot, Iplot, gfit, rc.data)
 --- R stacktrace ---
where 1 at /var/scratch2/tomas/tmp/RtmpE45lTo/R.INSTALL5c4d500a09ec/vitality/R/vitality.k.R#259: plotting.k(r.final, s.final, k.final, mlv, time, sfract, x1, 
    x2, Ni, pplot, tlab, lplot, cplot, Iplot, gfit, rc.data)
where 2: vitality.k(time = time, sdata = survival_fraction, rc.data = TRUE, 
    se = FALSE, gfit = FALSE, datatype = "CUM", ttol = 1e-06, 
    init.params = FALSE, lower = c(0, -1, 0), upper = c(100, 
        50, 50), pplot = TRUE, tlab = "days", lplot = TRUE, cplot = TRUE, 
    Iplot = TRUE, silent = TRUE)

 --- value of length: 28 type: logical ---
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 --- function (currently evaluated)--- 
function(r.final,s.final,k.final,mlv,time,sfract,x1,x2,Ni,pplot,tlab,lplot,cplot,Iplot,gfit,rc.data){
  #  Function to provide plotting and goodness of fit computations
  #
  
  # --plot cumulative survival---
  if (pplot != F) {
    ext<-max(pplot,1)
    par(mfrow=c(1,1))
    len<-length(time)
    tmax <-ext*time[len]
    plot(time,sfract,xlab=tlab,ylab="survival fraction",ylim=c(0,1),xlim=c(0,tmax))
    xxx<-seq(0,tmax,length=200)
    lines(xxx,SurvFn.k(xxx,r.final,s.final,k.final))
    title("Cumulative Survival Data and Vitality Model Fitting")
  }
  
    # --likelihood and likelihood contour plots---
    if(lplot != F) {
      profilePlot <- function(r.f,s.f,k.f,x1,x2,Ni,mlv,cplot){

        SLL <- function(r,s,k,x1,x2,Ni){sum(logLikelihood.k(c(r,s,k),x1,x2,Ni))}
        
        rf<-.2; sf<-.5; kf<-1.0; fp<-40 # rf,sf,kf - set profile plot range (.2 => plot +-20%), 2*fp+1 points
        rseq <-seq((1-rf)*r.f,(1+rf)*r.f, (rf/fp)*r.f)
        sseq <-seq((1-sf)*s.f,(1+sf)*s.f, (sf/fp)*s.f)
        if (k.f > 0) {
          kseq <-seq((1-kf)*k.f,(1+kf)*k.f, (kf/fp)*k.f)
        } else {  #if k=0..
          kseq <-seq(.00000001,.1,length=(2*fp+1))
        }
        
        rl <-length(rseq)
        tmpLLr <-rep(0,rl)
        tmpLLs <-tmpLLr
        tmpLLk <-tmpLLr
        for (i in 1:rl) {
          tmpLLr[i] <-SLL(rseq[i],s.f,k.f,x1,x2,Ni)
          tmpLLs[i] <-SLL(r.f,sseq[i],k.f,x1,x2,Ni)	
          tmpLLk[i] <-SLL(r.f,s.f,kseq[i],x1,x2,Ni)
        }
        
        par(mfrow=c(1,3))
        
        rlim1 <-rseq[1]
        rlim2 <-rseq[rl]
        if (r.f < 0) {  #even though r should not be <0
          rlim2 <-rseq[1]
          rlim1 <-rseq[rl]
        }
        
        plot(r.f,LL<-SLL(r.f,s.f,k.f,x1,x2,Ni),
             xlim=c(rlim1,rlim2), xlab="r",ylab="Likelihood");  
        lines(rseq,tmpLLr)
        legend(x="topright", legend=c("r.final", "Likelihood varying r"), pch=c(1,NA), lty=c(NA, 1))
        plot(s.f,LL,xlim=c(sseq[1],sseq[rl]), xlab="s",ylab="Likelihood");  
        lines(sseq,tmpLLs)
        legend(x="topright", legend=c("s.final", "Likelihood varying s"), pch=c(1,NA), lty=c(NA, 1))
        title("Likelihood Plots")
        plot(k.f,LL,xlim=c(kseq[1],kseq[rl]), 
             ylim=c(1.1*min(tmpLLk)-.1*(mLk<-max(tmpLLk)),mLk),xlab="k",ylab="Likelihood"); 
        lines(kseq,tmpLLk)
        legend(x="topright", legend=c("k.final", "Likelihood varying k"), pch=c(1,NA), lty=c(NA, 1))
        
        
        # --  for contour plotting  ----------------------------------------
        
        if (cplot==T) {
          rl2<-(rl+1)/2; rl4<-20; st<-rl2-rl4; nr<-2*rl4+1
          tmpLLrs <-matrix(rep(0,nr*nr),nrow=nr,ncol=nr)
          for(i in 1:nr) {
            for(j in 1:nr) {
              tmpLLrs[i,j] <-SLL(rseq[i+st-1],sseq[j+st-1],k.f,x1,x2,Ni)
            }
          }
          
          lvv<-seq(mlv,1.02*mlv,length=11)  #99.8%, 99.6% ... 98%
          par(mfrow=c(1,1))
          contour(rseq[st:(rl2+rl4)],sseq[st:(rl2+rl4)],tmpLLrs,levels=lvv,xlab="r",ylab="s")
          title("Likelihood Contour Plot of r and s",  "Outermost ring is likelihhod 98% (of max) level, innermost is 99.8% level.")
          points(r.f,s.f,pch="*",cex=3.0)
          points(c(rseq[st],r.f),c(s.f,sseq[st]),pch="+",cex=1.5)
        }
        
      }
      profilePlot(r.final,s.final,k.final,x1,x2,Ni,mlv,cplot)
    }
    
  # --calculations for goodness of fit---
  if(gfit!=F) { # then gfit must supply the population number
    isp <-survProbInc.k(r.final,s.final,k.final,x1,x2)
    C1.calc<-function(pop, isp, Ni){
        #  Routine to calculate goodness of fit (Pearson's C -type test)
        #  pop - population number of sample
        #  isp  - Modeled: incemental survivor Probability 
        #  Ni   - Data:  incemental survivor fraction (prob)
        #
        # Returns:  a list containing:
        # C1, dof, Chi2    (retrieve each from list as ..$C1   etc.)
        
        if(pop<35){
          if(pop<25){
            warning(paste("WARNING: sample population (",as.character(pop),") is too small for 
                          meaningful goodness of fit measure.  Goodness of fit not being computed"))
            return()
          } else {
            warning(paste("WARNING: sample population (",as.character(pop),") may be too small for 
                          meaningful goodness of fit measure"))
          }
          }
        np <- pop * isp # modeled population at each survival probability level.
        tmpC1 <- 0
        i1<-1; i<-1; cnt<-0
        len <- length(np)
        while(i <= len) {
          idx <- i1:i
          # It is recommended that each np[i] >5 for meningful results.  Where np<5
          #   points are grouped to attain that level.   I have fudged it to 4.5 ... 
          #  (as some leeway is allowed, and exact populations are sometimes unknown).
          if(sum(np[idx]) > 4.5) {
            cnt <-cnt+1
            # Check if enough points remain.  If not, they are glommed onto previous grouping.
            if(i < len && sum(np[(i + 1):len]) < 4.5) {
              idx <- i1:len
              i <- len
            }
            
            sNi <- sum(Ni[idx])
            sisp <- sum(isp[idx])
            tmpC1 <- tmpC1 + (pop * (sNi - sisp)^2)/sisp
            i1 <-i+1			
          }
          
          i <-i+1
        }
        C1 <- tmpC1
        dof <-cnt-1-3    # degrees of freedom (3 is number of parameters).
        if (dof < 1) {
          warning(paste("WARNING: sample population (",as.character(pop),") is too small for 
		meaningful goodness of fit measure (DoF<1).  Goodness of fit not being computed"))
          return()
        }
        
        chi2<-qchisq(.95,dof)
        return(list(C1=C1,dof=dof,chi2=chi2))
        }
    C1dof <- C1.calc(gfit,isp,Ni)
    C1 <-C1dof$C1
    dof <-C1dof$dof
    chi2 <-C1dof$chi2
    
    print(paste("Pearson's C1=",as.character(round(C1,3)),"   chisquared =", as.character(round(chi2,3)),"on",as.character(dof),"degrees of freedom"))
    
    #   Note: The hypothesis being tested is whether the data could reasonably have come 
    #   from the assumed (vitality) model.
    if(C1 > chi2){
      print("C1 > chiSquared;   should reject the hypothesis becasue C1 falls outside the 95% confidence interval.")
    } else {
      print("C1 < chiSquared;   should Not reject the hypothesis because C1 falls inside the 95% confidence interval")		
    }
  }
  
  # --Incremental mortality plot
  if (Iplot != F) {
    par(mfrow=c(1,1))
    if (rc.data != F) {
      ln <-length(Ni)-1
      x1 <-x1[1:ln]
      x2 <-x2[1:ln]
      Ni <-Ni[1:ln]
    }
    ln <-length(Ni)
    #scale<-(x2-x1)[Ni==max(Ni)]
    scale<-max( (x2-x1)[Ni==max(Ni)] )
    
    ext<-max(pplot,1)
    
    npt<-200*ext
    xxx <-seq(x1[1],x2[ln]*ext,length=npt)
    xx1 <-xxx[1:(npt-1)]
    xx2 <-xxx[2:npt]
    sProbI <-survProbInc.k(r.final[1],s.final[1],k.final[1],xx1,xx2)
    
    ytop <-1.1*max( max(sProbI/(xx2-xx1)),Ni/(x2-x1) )*scale		
    plot((x1+x2)/2,Ni*scale/(x2-x1),ylim=c(0,ytop),xlim=c(0,ext*x2[ln]),xlab=tlab,ylab="incremental mortality")
    title("Probability Density Function")
    lines((xx1+xx2)/2,sProbI*scale/(xx2-xx1))
  }
  
  return()	 
}
<environment: namespace:vitality>
 --- function (body) search ---
Function plotting.k in namespace vitality has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
