
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(nlsr)

Attaching package: 'nlsr'

The following object is masked from 'package:base':

    isFALSE

> 
> # Various derivatives 
> 
> fnDeriv(quote(1 + x + y), c("x", "y"))
function (x, y) 
{
    .value <- 1 + x + y
    .grad <- array(0, c(length(.value), 2L), list(NULL, c("x", 
    "y")))
    .grad[, "x"] <- 1
    .grad[, "y"] <- 1
    attr(.value, "gradient") <- .grad
    .value
}
> 
> nlsDeriv( ~ log(x), "x")
1/x
> nlsDeriv( ~ log(x, base=3), "x" )
1/(x * 1.09861228866811)
> 
> nlsDeriv( ~ exp(x), "x")
exp(x)
> nlsDeriv( ~ sin(x), "x")
cos(x)
> nlsDeriv( ~ cos(x), "x")
-sin(x)
> nlsDeriv( ~ tan(x), "x")
1/cos(x)^2
> nlsDeriv( ~ sinh(x), "x")
cosh(x)
> nlsDeriv( ~ cosh(x), "x")
sinh(x)
> nlsDeriv( ~ sqrt(x), "x")
0.5/sqrt(x)
> nlsDeriv( ~ pnorm(q), "q")
dnorm(q)
> nlsDeriv( ~ dnorm(x, mean), "mean")
dnorm(x - mean) * (x - mean)
> nlsDeriv( ~ asin(x), "x")
1/sqrt(1 + x^2)
> nlsDeriv( ~ acos(x), "x")
-1/sqrt(1 + x^2)
> nlsDeriv( ~ atan(x), "x")
1/(1 + x^2)
> nlsDeriv( ~ gamma(x), "x")
gamma(x) * digamma(x)
> nlsDeriv( ~ lgamma(x), "x")
digamma(x)
> nlsDeriv( ~ digamma(x), "x")
trigamma(x)
> nlsDeriv( ~ trigamma(x), "x")
psigamma(x, 2L)
> nlsDeriv( ~ psigamma(x, deriv = 5), "x")
psigamma(x, 6)
> nlsDeriv( ~ x*y, "x")
y
> nlsDeriv( ~ x/y, "x")
1/y
> nlsDeriv( ~ x^y, "x")
y * x^(y - 1)
> nlsDeriv( ~ (x), "x")
[1] 1
> nlsDeriv( ~ +x, "x")
[1] 1
> nlsDeriv( ~ -x, "x")
[1] -1
> nlsDeriv( ~ abs(x), "x")
sign(x)
> nlsDeriv( ~ sign(x), "x")
[1] 0
> 
> # Various simplifications
> 
> nlsSimplify(quote(+(a+b)))
a + b
> nlsSimplify(quote(-5))
[1] -5
> nlsSimplify(quote(--(a+b)))
a + b
> 
> nlsSimplify(quote(exp(log(a+b))))
a + b
> nlsSimplify(quote(exp(1)))
[1] 2.718282
> 
> nlsSimplify(quote(log(exp(a+b))))
a + b
> nlsSimplify(quote(log(1)))
[1] 0
> 
> nlsSimplify(quote(!TRUE))
[1] FALSE
> nlsSimplify(quote(!FALSE))
[1] TRUE
> 
> nlsSimplify(quote((a+b)))
a + b
> 
> nlsSimplify(quote(a + b + 0))
a + b
> nlsSimplify(quote(0 + a + b))
a + b
> nlsSimplify(quote((a+b) + (a+b)))
2 * (a + b)
> nlsSimplify(quote(1 + 4))
[1] 5
> 
> nlsSimplify(quote(a + b - 0))
a + b
> nlsSimplify(quote(0 - a - b))
-a - b
> nlsSimplify(quote((a+b) - (a+b)))
[1] 0
> nlsSimplify(quote(5 - 3))
[1] 2
> 
> nlsSimplify(quote(0*(a+b)))
[1] 0
> nlsSimplify(quote((a+b)*0))
[1] 0
> nlsSimplify(quote(1L * (a+b)))
a + b
> nlsSimplify(quote((a+b) * 1))
a + b
> nlsSimplify(quote((-1)*(a+b)))
-(a + b)
> nlsSimplify(quote((a+b)*(-1)))
-(a + b)
> nlsSimplify(quote(2*5))
[1] 10
> 
> nlsSimplify(quote((a+b) / 1))
a + b
> nlsSimplify(quote((a+b) / (-1)))
-(a + b)
> nlsSimplify(quote(0/(a+b)))
[1] 0
> nlsSimplify(quote(1/3))
[1] 0.3333333
> 
> nlsSimplify(quote((a+b) ^ 1))
a + b
> nlsSimplify(quote(2^10))
[1] 1024
> 
> nlsSimplify(quote(log(exp(a), 3)))
a/1.09861228866811
> 
> nlsSimplify(quote(FALSE && b))
[1] FALSE
> nlsSimplify(quote(a && TRUE))
a
> nlsSimplify(quote(TRUE && b))
b
> 
> nlsSimplify(quote(a || TRUE))
[1] TRUE
> nlsSimplify(quote(FALSE || b))
b
> nlsSimplify(quote(a || FALSE))
a
> 
> nlsSimplify(quote(if (TRUE) a+b))
a + b
> nlsSimplify(quote(if (FALSE) a+b))
NULL
> 
> nlsSimplify(quote(if (TRUE) a+b else a*b))
a + b
> nlsSimplify(quote(if (FALSE) a+b else a*b))
a * b
> nlsSimplify(quote(if (cond) a+b else a+b))
a + b
> 
> # This one was wrong...
> nlsSimplify(quote(--(a+b)))
a + b
> 
> 
> # From the Weeds problem
> 
>   modelformula <- y ~ ms * b1/(1 + b2 * exp(-b3 * tt))
>   pvec <- c(b1=1, b2=1, b3=1)
>   cat("model2rjfunx: modelformula = ")
model2rjfunx: modelformula = >   print(modelformula)
y ~ ms * b1/(1 + b2 * exp(-b3 * tt))
>   print(class(modelformula))
[1] "formula"
> 
>   if (length(modelformula) == 2) {
+        residexpr <- modelformula[[2]]
+   } else if (length(modelformula) == 3) {
+        residexpr <- call("-", modelformula[[3]], modelformula[[2]])
+   } else stop("Unrecognized formula")
>     
>   if (is.null(names(pvec)))
+     names(pvec) <- paste0("p", seq_along(pvec))
>     
>   residexpr1 <- nlsDeriv( ~ residexpr, names(pvec))
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpAmzppR/R.INSTALL1ac1d2a21fb/nlsr/R/derivs.R#124: 
 --- if/while statement is in package --- 
nlsr
 --- call (currently evaluated) --- 
nlsDeriv(~residexpr, names(pvec))
 --- R stacktrace ---
where 1: nlsDeriv(~residexpr, names(pvec))

 --- value of length: 3 type: logical ---
[1] FALSE FALSE FALSE
 --- function (currently evaluated)--- 
function(expr, name, derivEnv = sysDerivs, do_substitute = FALSE, verbose = FALSE, ...) {
    Recurse <- function(expr) {
    	if (is.call(expr)) {
    	    if (as.character(expr[[1]]) == "D")
    	    	expr <- nlsDeriv(expr[[2]], name, derivEnv, do_substitute = FALSE, verbose = verbose, ...)
    	    else
    	    	for (i in seq_along(expr)[-1])
    	    	    expr[[i]] <- Recurse(expr[[i]])
    	}
    	expr
    }
    expr <- dex(expr, do_substitute = do_substitute, verbose = verbose)
    if (is.expression(expr))
    	return(as.expression(lapply(expr, nlsDeriv, name = name, derivEnv = derivEnv, do_substitute = FALSE, verbose = verbose, ...)))
    else if (is.numeric(expr) || is.logical(expr))
    	return(0)
    else if (is.call(expr)) {
    	fn <- as.character(expr[[1]])
	if (fn == "expression")
	    return(as.expression(lapply(as.list(expr)[-1], nlsDeriv, name = name, derivEnv = derivEnv, do_substitute = FALSE, verbose = verbose, ...)))
    	model <- derivEnv[[fn]]
    	if (is.null(model))
    	    stop("no derivative known for '", fn, "'")
 	if (missing(name) || verbose) {
 	    message(paste("Expr:", deparse(expr)))
 	    message(if (missing(name)) "Pattern for" else "Using pattern")
 	    message(paste("  ", deparse(model$expr), collapse = "\n"))
 	    message("is")
 	    message(paste("  ", deparse(model$deriv), collapse = "\n"))
 	    if (missing(name))
 	    	return(invisible(NULL))
 	}
        args <- expr[-1]
        argnames <- names(args)
        if (is.null(argnames)) 
            argnames <- rep("", length(args))
        modelnames <- model$argnames
        argnum <- pmatch(argnames, modelnames)
        if (any(bad <- is.na(argnum) & argnames != ""))
            stop("Argument names not matched: ", paste(argnames[bad], collapse = ", "))
        unused <- setdiff(seq_along(modelnames), argnum)
        nonamecount <- sum(is.na(argnum))
        length(unused) <- nonamecount
        argnum[which(is.na(argnum))] <- unused
        default <- setdiff(seq_along(modelnames), argnum)
        if (length(bad <- setdiff(model$required, argnum)))
            stop("Missing required arguments: ", paste(modelnames[bad], collapse = ", "))
        
        # Now do the substitutions
        subst <- list()
        subst[argnum] <- as.list(args)
        subst[default] <- as.list(model$expr[-1])[default]
        names(subst) <- modelnames
        result <- do.call(substitute, list(model$deriv, subst))
        result <- Recurse(result)
        nlsSimplify(result, verbose = verbose, ...)
    } else if (is.name(expr))
    	if (as.character(expr) == name)
    	    return(1)
    	else
    	    return(0)        
}
<environment: namespace:nlsr>
 --- function (body) search ---
Function nlsDeriv in namespace nlsr has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
