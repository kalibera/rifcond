
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "EcoHydRology"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('EcoHydRology')
Loading required package: operators

Attaching package: ‘operators’

The following objects are masked from ‘package:base’:

    options, strrep

Loading required package: topmodel
Loading required package: DEoptim
Loading required package: parallel

DEoptim package
Differential Evolution algorithm in R
Authors: D. Ardia, K. Mullen, B. Peterson and J. Ulrich

Loading required package: XML
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AtmosphericEmissivity")
> ### * AtmosphericEmissivity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AtmosphericEmissivity
> ### Title: Atmospheric Emissivity
> ### Aliases: AtmosphericEmissivity
> 
> ### ** Examples
> 
> 
> temp=15
> clouds=.5
> AtmEm=AtmosphericEmissivity(temp,clouds)
> print(AtmEm)
[1] 0.8811
> 
> 
> 
> cleanEx()
> nameEx("BaseflowSeparation")
> ### * BaseflowSeparation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BaseflowSeparation
> ### Title: Baseflow Separation
> ### Aliases: BaseflowSeparation
> 
> ### ** Examples
> 
> #########	Look at a dataset for Owasco Lake in NY:
> data(OwascoInlet)
> summary(OwascoInlet)
      date                 P_mm         Streamflow_m3s    baseflow_m3s   
 Min.   :2009-04-22   Min.   :  0.000   Min.   : 0.310   Min.   : 0.000  
 1st Qu.:2009-11-29   1st Qu.:  0.000   1st Qu.: 1.590   1st Qu.: 1.329  
 Median :2010-07-09   Median :  0.000   Median : 3.060   Median : 2.516  
 Mean   :2010-07-17   Mean   :  3.121   Mean   : 4.647   Mean   : 3.212  
 3rd Qu.:2011-03-16   3rd Qu.:  2.540   3rd Qu.: 5.077   3rd Qu.: 3.960  
 Max.   :2011-10-26   Max.   :112.522   Max.   :56.350   Max.   :15.737  
     Tmax_C            Tmin_C       
 Min.   :-12.220   Min.   :-26.110  
 1st Qu.:  8.193   1st Qu.: -1.670  
 Median : 18.330   Median :  6.670  
 Mean   : 15.977   Mean   :  5.059  
 3rd Qu.: 25.000   3rd Qu.: 12.220  
 Max.   : 36.670   Max.   : 23.330  
> 
> ##	Get an approximation for baseflow using a 3 pass filter:
> bfs<-BaseflowSeparation(OwascoInlet$Streamflow_m3s, passes=3)
> 
> ##	You can check out how this looks with the hydrograph function:
> hydrograph(input=OwascoInlet,streamflow2=bfs[,1])
> 
> 
> 
> cleanEx()
> nameEx("ConvertFlowUnits")
> ### * ConvertFlowUnits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ConvertFlowUnits
> ### Title: Unit conversion for flow rates
> ### Aliases: ConvertFlowUnits
> 
> ### ** Examples
> 
> data(OwascoInlet)
> OwascoInlet$Streamflow_mmd<-ConvertFlowUnits(cms=OwascoInlet$Streamflow_m3s,WA=271.,AREAunits="km2")
> 
> ##  The following commented example isn't currently working in Linux systems, but should 
> ##  work in windows/macs
> ##
> ##  Get some streamflow (reported in cubic meters per day here):
> # OI <- get_usgs_gage("04235299", "2013-03-01", "2013-05-20")
> # FC <- get_usgs_gage("04234000", "2013-03-01", "2013-05-20")
> 
> ##  Convert to mm/d
> # OwascoInlet_mmd <- ConvertFlowUnits(cmd=OI$flowdata$flow, WA=OI$area, AREAunits="km2")
> # FallCreek_mmd <- ConvertFlowUnits(cmd=FC$flowdata$flow, WA=FC$area, AREAunits="km2")
> 
> ##  Compare the watershed area normalized flow depth for two watersheds near Ithaca NY :
> # hydrograph(streamflow=OwascoInlet_mmd, streamflow2=FallCreek_mmd, timeSeries=FC$flowdata$mdate, 
> # stream.label="flow depth (mm/d)")
> # legend("topright", legend=c("Owasco Inlet", "Fall Creek"), lty=c(1,2), col=c("black", "red"))
> 
> 
> 
> cleanEx()
> nameEx("EnvirEnergy")
> ### * EnvirEnergy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EnvirEnergy
> ### Title: The Surface Net Energy Budget
> ### Aliases: EnvirEnergy
> 
> ### ** Examples
> 
> ## The function is currently defined as
> function(lat,Jday,Tx,Tn,wind,relativehumidity,cloudiness,albedo,forest,
+ slope,aspect,surftemp,surfemissivity){
+ if(cloudiness<0){cloudiness<-EstCloudiness(lat,Jday,Tx,Tn)}
+ 
+ airtemp<-(Tx+Tn)/2 #average daily air temperature [C]
+ 
+ return(Solar(lat,Jday,Tx,Tn,albedo,forest,slope,aspect)+
+ Longwave(AtmosphericEmissivity(airtemp,cloudiness),airtemp)-
+ Longwave(surfemissivity,surftemp)+SensibleHeat(surftemp,airtemp,wind)+
+ EvapHeat(surftemp,airtemp,relativehumidity,Tn,wind)+
+ RainHeat(airtemp,rain)+GroundHeat())
+   }
function (lat, Jday, Tx, Tn, wind, relativehumidity, cloudiness, 
    albedo, forest, slope, aspect, surftemp, surfemissivity) 
{
    if (cloudiness < 0) {
        cloudiness <- EstCloudiness(lat, Jday, Tx, Tn)
    }
    airtemp <- (Tx + Tn)/2
    return(Solar(lat, Jday, Tx, Tn, albedo, forest, slope, aspect) + 
        Longwave(AtmosphericEmissivity(airtemp, cloudiness), 
            airtemp) - Longwave(surfemissivity, surftemp) + SensibleHeat(surftemp, 
        airtemp, wind) + EvapHeat(surftemp, airtemp, relativehumidity, 
        Tn, wind) + RainHeat(airtemp, rain) + GroundHeat())
}
> 
> 
> 
> cleanEx()
> nameEx("EstCloudiness")
> ### * EstCloudiness
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EstCloudiness
> ### Title: Estimated Cloudiness
> ### Aliases: EstCloudiness
> 
> ### ** Examples
> 
> EstCloudiness(trans=0.2)
[1] 0.9166667
> EstCloudiness(20,12,opt="Black")
[1] 0.4054344
> 
> 
> 
> cleanEx()
> nameEx("EvapHeat")
> ### * EvapHeat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EvapHeat
> ### Title: Evaporative heat exchange between a wet surface and the
> ###   surrounding air
> ### Aliases: EvapHeat
> 
> ### ** Examples
> 
> 	EvapHeat(surftemp=15, airtemp=5, relativehumidity=0.7)
[1] 11045
>  
> 
> 
> cleanEx()
> nameEx("GSOD_history")
> ### * GSOD_history
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GSOD_history
> ### Title: ish-history.txt
> ### Aliases: GSOD_history
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(GSOD_history)
> 
> 
> 
> cleanEx()
> nameEx("GroundHeat")
> ### * GroundHeat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GroundHeat
> ### Title: Heat conducted to the bottom of a snowpack
> ### Aliases: GroundHeat
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function(){
+ # the heat conducted to the bottom of a snowpack, assumed constant [kJ m-2 d-1]
+ 
+ return(173)
+   }
function () 
{
    return(173)
}
> 
> 
> 
> cleanEx()
> nameEx("Lumped_VSA_model")
> ### * Lumped_VSA_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Lumped_VSA_model
> ### Title: Lumped Variable Source Area (VSA) Watershed Model
> ### Aliases: Lumped_VSA_model
> 
> ### ** Examples
> 
> data(OwascoInlet)
> # First get rain and snow-melt input: 
> rsm <- SnowMelt(Date=OwascoInlet$date, precip_mm=OwascoInlet$P_mm, Tmax_C=OwascoInlet$Tmax_C, 
+ Tmin_C=OwascoInlet$Tmin_C, lat_deg=42.66)
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
: 
 --- if/while statement is in package --- 
EcoHydRology
 --- call (currently evaluated) --- 
withCallingHandlers(expr, warning = function(w) invokeRestart("muffleWarning"))
 --- R stacktrace ---
where 1: withCallingHandlers(expr, warning = function(w) invokeRestart("muffleWarning"))
where 2 at /var/scratch2/tomas/tmp/RtmpGR1Spj/R.INSTALL44ac238bced0/EcoHydRology/R/EstCloudiness.R#3: suppressWarnings(if ((Tx == -999 | Tn == -999) & is.null(trans)) {
    print("Error: Please enter either Max&Min temp or transmissivity")
} else {
    if (is.null(trans)) 
        trans <- transmissivity(Tx, Tn)
    if (opt == "Black") {
        cl <- (0.34 - sqrt(0.34^2 + 4 * 0.458 * (0.803 - trans)))/(-2 * 
            0.458)
        cl[which(trans > 0.803)] <- 0
    }
    else {
        cl <- 1 - (trans - transMin)/(transMax - transMin)
    }
    cl[which(cl > 1)] <- 1
    cl[which(cl < 0)] <- 0
    return(cl)
})
where 3 at /var/scratch2/tomas/tmp/RtmpGR1Spj/R.INSTALL44ac238bced0/EcoHydRology/R/SnowMelt.R#24: EstCloudiness(Tmax_C, Tmin_C)
where 4: SnowMelt(Date = OwascoInlet$date, precip_mm = OwascoInlet$P_mm, 
    Tmax_C = OwascoInlet$Tmax_C, Tmin_C = OwascoInlet$Tmin_C, 
    lat_deg = 42.66)

 --- value of length: 888 type: logical ---
  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[805] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[817] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[829] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[841] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[853] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[865] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[877] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 --- function (currently evaluated)--- 
function (expr, ...) 
{
    handlers <- list(...)
    classes <- names(handlers)
    parentenv <- parent.frame()
    if (length(classes) != length(handlers)) 
        stop("bad handler specification")
    .Internal(.addCondHands(classes, handlers, parentenv, NULL, 
        TRUE))
    expr
}
<bytecode: 0x2ae9b00>
<environment: namespace:base>
 --- function (body) search ---
Function withCallingHandlers in namespace base has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
