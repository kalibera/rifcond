
R Under development (unstable) (2018-01-22 r74151) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "AnalyzeFMRI"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('AnalyzeFMRI')
Loading required package: tcltk
Loading required package: R.matlab
R.matlab v3.6.1 (2016-10-19) successfully loaded. See ?R.matlab for help.

Attaching package: ‘R.matlab’

The following objects are masked from ‘package:base’:

    getOption, isOpen

Loading required package: fastICA
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("EC.3D")
> ### * EC.3D
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EC.3D
> ### Title: Expected Euler Characteristic for a 3D Random Field
> ### Aliases: EC.3D
> ### Keywords: utilities
> 
> ### ** Examples
> 
> EC.3D(4.6, sigma = diag(1, 3), voxdim = c(1, 1, 1), num.vox = 10000)
[1] 0.04589339
> 
> EC.3D(4.6, sigma = diag(1, 3), voxdim = c(1, 1, 1), num.vox = 10000, type = "t", df = 100)
[1] 0.1335733
> 
> 
> 
> 
> cleanEx()
> nameEx("GaussSmoothArray")
> ### * GaussSmoothArray
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GaussSmoothArray
> ### Title: Spatially smooth an array with Gaussian kernel.
> ### Aliases: GaussSmoothArray
> ### Keywords: utilities
> 
> ### ** Examples
> 
> d <- c(10, 10, 10, 20)
> mat <- array(rnorm(cumprod(d)[length(d)]), dim = d)
> mat[, , 6:10, ] <- mat[, , 6:10, ] + 3
> mask <- array(0, dim = d[1:3])
> mask[3:8, 3:8, 3:8] <- 1
> b <- GaussSmoothArray(mat, mask = mask, voxdim = c(1, 1, 1), ksize = 5, sigma = diag(1, 3))      
> 
> 
> 
> cleanEx()
> nameEx("GaussSmoothKernel")
> ### * GaussSmoothKernel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GaussSmoothKernel
> ### Title: Calculates a discrete Gaussian smoothing kernel.
> ### Aliases: GaussSmoothKernel
> ### Keywords: utilities
> 
> ### ** Examples
> 
> a <- GaussSmoothKernel(voxdim=c(1,1,1), ksize=5, sigma=diag(1,3))
> 
> 
> 
> cleanEx()
> nameEx("ICAspat")
> ### * ICAspat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ICAspat
> ### Title: ICAspat
> ### Aliases: ICAspat
> ### Keywords: utilities
> 
> ### ** Examples
> 
> # TODO!!
> 
> 
> 
> cleanEx()
> nameEx("ICAtemp")
> ### * ICAtemp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ICAtemp
> ### Title: ICAtemp
> ### Aliases: ICAtemp
> ### Keywords: utilities
> 
> ### ** Examples
> 
> # TODO!!
> 
> 
> 
> cleanEx()
> nameEx("N2G")
> ### * N2G
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: N2G
> ### Title: Fits the N2G model
> ### Aliases: N2G
> ### Keywords: utilities
> 
> ### ** Examples
> 
> par <- c(3, 2, 3, 2, .3, .4)
> data <- c(rnorm(10000), rgamma(2000, 10, 1), -rgamma(1400, 10, 1))
> hist(data, n = 100, freq = FALSE)
> 
> q <- N2G.Fit(data, par, maxit = 10000, method = "BFGS")
Warning in dgamma(data[pos], par[1], par[2]) : NaNs produced
> p <- seq(-50, 50, .1)
> lines(p, N2G.Density(p, q), col = 2)
> 
> 
> 
> cleanEx()
> nameEx("N2G.Spatial.Mixture")
> ### * N2G.Spatial.Mixture
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: N2G.Spatial.Mixture
> ### Title: fMRI Spatial Mixture Modelling
> ### Aliases: N2G.Spatial.Mixture
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> ## simulate image
> d <- c(100, 100, 1)
> y <- array(0, dim = d)
> m <- y
> m[, , ] <- 1
> 
> z.init <- 2 * m
> z.init[20:40, 20:40, 1] <- 1
> z.init[50:70, 50:70, 1] <- 3
> 
> y[z.init == 1] <- -rgamma(sum(z.init == 1), 4, 1)
> y[z.init == 2] <- rnorm(sum(z.init == 2))
> y[z.init == 3] <- rgamma(sum(z.init == 3), 4, 1)
> 
> mask <- 1 * (y < 1000)
> 
> ## fit spatial mixture model
> ans <- N2G.Spatial.Mixture(y, par.start = c(4, 2, 4, 2, 0.9, 0.05), ksize = 3, ktype = "2D", mask = m) 
> 
> ## plot original image, standard mixture model estimate and spatial mixture
> ## model estimate
> 
> par(mfrow = c(1, 3))
> image(y[, , 1])
> image(y[, , 1] > ans$lims[1]) ## this line plots the results of a Non-Spatial Mixture Model
> image(ans$p.map[, , 1] > 0.5) ## this line plots the results of the Spatial Mixture Model
> 
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("NonLinearSmoothArray")
> ### * NonLinearSmoothArray
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NonLinearSmoothArray
> ### Title: Non-linear spatial smmothing of 3D and 4D arrays.
> ### Aliases: NonLinearSmoothArray
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> #3D array
> d<-rep(10,3)
> a<-array(3,dim=d)
> a[,5:10,5:10]<-7
> a<-a+array(rnorm(n=1000,sd=1),dim=d)
> 
> h<-NonLinearSmoothArray(a,voxdim=c(1,1,1),radius=2,sm=3)
> 
> par(mfrow=c(2,2))
> image(a[1,,],zlim=c(-1,12));title("Before smoothing")
> image(h[1,,],zlim=c(-1,12));title("After smoothing")
> persp(a[1,,],zlim=c(-1,12))
> persp(h[1,,],zlim=c(-1,12))
> 
> #4D array
> d<-c(10,10,10,20)
> a<-array(1,dim=d)
> a[,,6:10,]<-2
> a<-a+array(rnorm(20000,sd=.1),dim=d)
> 
> h<-NonLinearSmoothArray(a,voxdim=c(1,1,1),radius=2,sm=3)
> 
> par(mfrow=c(2,2),mar=c(0,0,0,0))
> for(i in 1:10){
+     for(j in 10:1){
+         plot(a[1,i,j,],type="l",ylim=c(0,3),axes=FALSE);box()
+         lines(h[1,i,j,],col=2)
+     }}
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("Q2R")
> ### * Q2R
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Q2R
> ### Title: Quaternion to rotation
> ### Aliases: Q2R
> ### Keywords: utilities
> 
> ### ** Examples
> 
> L <- f.read.nifti.header(system.file("example-nifti.hdr", package="AnalyzeFMRI"))
> Q <- c(L$quatern.b,L$quatern.c,L$quatern.d)
> Q2R(Q,L$pixdim[1])
     [,1] [,2] [,3]
[1,]   -1    0    0
[2,]    0    1    0
[3,]    0    0    1
> 
> 
> 
> cleanEx()
> nameEx("R2Q")
> ### * R2Q
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: R2Q
> ### Title: Rotation to quaternion
> ### Aliases: R2Q
> ### Keywords: utilities
> 
> ### ** Examples
> 
> L <- f.read.nifti.header(system.file("example-nifti.hdr", package="AnalyzeFMRI"))
> Q <- c(L$quatern.b,L$quatern.c,L$quatern.d)
> R <- Q2R(Q,L$pixdim[1])
> Q
[1] 0 1 0
> R2Q(R)
[1] 0 1 0 0
> 
> 
> 
> cleanEx()
> nameEx("Sim.3D.GRF")
> ### * Sim.3D.GRF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sim.3D.GRF
> ### Title: Simulate a GRF
> ### Aliases: Sim.3D.GRF
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> d <- c(64, 64, 21)
> FWHM <- 9
> sigma <- diag(FWHM^2, 3) / (8 * log(2))
> voxdim <- c(2, 2, 4)
> msk <- array(1, dim = d)
> 
> field <- Sim.3D.GRF(d = d, voxdim = voxdim, sigma = sigma, ksize = 9, mask = msk, type = "max")
> 
> 
> 
> 
> cleanEx()
> nameEx("Sim.3D.GammaRF")
> ### * Sim.3D.GammaRF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sim.3D.GammaRF
> ### Title: Simulate Gamma distributed Random Field
> ### Aliases: Sim.3D.GammaRF
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> d <- c(64, 64, 21)
> FWHM <- 9
> sigma <- diag(FWHM^2, 3) / (8 * log(2))
> voxdim <- c(2, 2, 4)
> m <- array(1, dim = d)
> 
> a <- Sim.3D.GammaRF(d = d, voxdim = voxdim, sigma = sigma, 
+                     ksize = 9, mask = m, shape = 6, rate = 1)
> 
> 
> 
> 
> cleanEx()
> nameEx("SmoothEst")
> ### * SmoothEst
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SmoothEst
> ### Title: Estimate the variance-covariance matrix of a Gaussian random
> ###   field
> ### Aliases: SmoothEst
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> ###############
> ## EXAMPLE 1 ##
> ###############
> ## example that illustrates the bias of the Friston
> ## method when smoothing is small compared to voxel size
> ## NB. The presence of bias becomes clearer if the
> ##     simulations below are run about 100 times and
> ##     the results averaged
> 
> ksize <- 13
> d <- c(64, 64, 64)
> voxdim <- c(1, 1, 1)
> FWHM <- 2 ## using a small value of FWHM (=2) compared to voxel size (=1)
> sigma <- diag(FWHM^2, 3) / (8 * log(2))
> mask <- array(1, dim = d)
> num.vox <- sum(mask)
> 
> grf <- Sim.3D.GRF(d = d, voxdim = voxdim, sigma = sigma, ksize = ksize, mask = mask, type = "field")$mat
>                
> sigma
          [,1]      [,2]      [,3]
[1,] 0.7213475 0.0000000 0.0000000
[2,] 0.0000000 0.7213475 0.0000000
[3,] 0.0000000 0.0000000 0.7213475
> SmoothEst(grf, mask, voxdim, method = "Friston")
          [,1]      [,2]      [,3]
[1,] 0.8512329 0.0000000 0.0000000
[2,] 0.0000000 0.8444554 0.0000000
[3,] 0.0000000 0.0000000 0.8522466
> SmoothEst(grf, mask, voxdim, method = "Forman") ## compared to sigma
          [,1]      [,2]      [,3]
[1,] 0.7169178 0.0000000 0.0000000
[2,] 0.0000000 0.7100873 0.0000000
[3,] 0.0000000 0.0000000 0.7179393
> ##the Forman estimator is better (on average) than the Friston estimator
> 
> ###############
> ## EXAMPLE 2 ##
> ###############
> ## increasing the amount of smoothing decreases the bias of the Friston estimator
> 
> ksize <- 13
> d <- c(64, 64, 64)
> voxdim <- c(1, 1, 1)
> FWHM <- 5 ## using a large value of FWHM (=5) compared to voxel size (=1)
> sigma <- diag(FWHM^2, 3) / (8 * log(2))
> mask <- array(1, dim = d)
> num.vox <- sum(mask)
> 
> grf <- Sim.3D.GRF(d = d, voxdim = voxdim, sigma = sigma, ksize = ksize, mask = mask, type = "field")$mat
> 
> SmoothEst(grf, mask, voxdim, method = "Friston")
         [,1]     [,2]     [,3]
[1,] 4.704813 0.000000 0.000000
[2,] 0.000000 5.002093 0.000000
[3,] 0.000000 0.000000 4.788262
> SmoothEst(grf, mask, voxdim, method = "Forman")                
         [,1]     [,2]    [,3]
[1,] 4.530062 0.000000 0.00000
[2,] 0.000000 4.824341 0.00000
[3,] 0.000000 0.000000 4.61267
> sigma
         [,1]     [,2]     [,3]
[1,] 4.508422 0.000000 0.000000
[2,] 0.000000 4.508422 0.000000
[3,] 0.000000 0.000000 4.508422
> 
> 
> 
> 
> cleanEx()
> nameEx("Threshold.Bonferroni")
> ### * Threshold.Bonferroni
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Threshold.Bonferroni
> ### Title: Calculates Bonferroni Threshold
> ### Aliases: Threshold.Bonferroni
> ### Keywords: utilities
> 
> ### ** Examples
> 
> Threshold.Bonferroni(0.05, 1000)
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/Rtmpl75vrP/R.INSTALLd82c74cc56c5/AnalyzeFMRI/R/threshold.R#126: 
 --- if/while statement is in package --- 
AnalyzeFMRI
 --- call (currently evaluated) --- 
Threshold.Bonferroni(0.05, 1000)
 --- R stacktrace ---
where 1: Threshold.Bonferroni(0.05, 1000)

 --- value of length: 3 type: logical ---
[1]  TRUE FALSE FALSE
 --- function (currently evaluated)--- 
function(p.val, n, type = c("Normal", "t", "F"), df1 = NULL, df2 = NULL) {

    ## calculate the Bonferroni threshold for n iid tests to give a p-value of p.val
    ## type specifies the univariate distribution of the test statistics under consideration
    
    if(type == "Normal") return(qnorm(1 - p.val / n))
    if(type == "t") return(qt(1 - p.val / n, df = df1))
    if(type == "F") return(qf(1 - p.val / n, df1 = df1, df2 = df2))

}
<environment: namespace:AnalyzeFMRI>
 --- function (body) search ---
Function Threshold.Bonferroni in namespace AnalyzeFMRI has this body.
 ----------- END FAILURE REPORT -------------- 
Fatal error: the condition has length > 1 and only the first element will be used XXXXXX
