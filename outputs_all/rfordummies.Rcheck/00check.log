* using log directory ‘/var/scratch2/tomas/test/mine/R-svn-dev-75396/check/rfordummies.Rcheck’
* using R Under development (unstable) (2018-10-04 r75396)
* using platform: x86_64-pc-linux-gnu (64-bit)
* using session charset: UTF-8
* checking for file ‘rfordummies/DESCRIPTION’ ... OK
* this is package ‘rfordummies’ version ‘0.1.3’
* checking package namespace information ... OK
* checking package dependencies ... OK
* checking if this is a source package ... OK
* checking if there is a namespace ... OK
* checking for executable files ... OK
* checking for hidden files and directories ... OK
* checking for portable file names ... OK
* checking for sufficient/correct file permissions ... OK
* checking whether package ‘rfordummies’ can be installed ... OK
* checking package directory ... OK
* checking DESCRIPTION meta-information ... OK
* checking top-level files ... OK
* checking for left-over files ... OK
* checking index information ... OK
* checking package subdirectories ... OK
* checking R files for non-ASCII characters ... OK
* checking R files for syntax errors ... OK
* checking whether the package can be loaded ... OK
* checking whether the package can be loaded with stated dependencies ... OK
* checking whether the package can be unloaded cleanly ... OK
* checking whether the namespace can be loaded with stated dependencies ... OK
* checking whether the namespace can be unloaded cleanly ... OK
* checking loading without being on the library search path ... OK
* checking dependencies in R code ... OK
* checking S3 generic/method consistency ... OK
* checking replacement functions ... OK
* checking foreign function calls ... OK
* checking R code for possible problems ... OK
* checking Rd files ... OK
* checking Rd metadata ... OK
* checking Rd cross-references ... OK
* checking for missing documentation entries ... OK
* checking for code/documentation mismatches ... OK
* checking Rd \usage sections ... OK
* checking Rd contents ... OK
* checking for unstated dependencies in examples ... OK
* checking contents of ‘data’ directory ... OK
* checking data for non-ASCII characters ... OK
* checking data for ASCII and uncompressed saves ... OK
* checking examples ... ERROR
Running examples in ‘rfordummies-Ex.R’ failed
The error most likely occurred in:

> ### Name: ch09
> ### Title: Print examples of chapter 9 of 'R for Dummies'.
> ### Aliases: ch09 ch9
> 
> ### ** Examples
> 
> # Chapter 9
> # Controlling the Logical Flow
> 
> #Making Choices with if Statements
> 
> priceCalculator <- function(hours, pph=40){
+     net.price <- hours * pph
+     round(net.price)
+ }
> 
> priceCalculator <- function(hours, pph=40){
+     net.price <- hours * pph
+     if(hours > 100) {
+       net.price <- net.price * 0.9
+     }
+     round(net.price)
+ }
> 
> priceCalculator(hours = 55)
[1] 2200
> priceCalculator(hours = 110)
[1] 3960
> 
> priceCalculator <- function(hours, pph=40){
+     net.price <- hours * pph
+     if(hours > 100) net.price <- net.price * 0.9
+     round(net.price)
+ }
> 
> ?'if'
Control                  package:base                  R Documentation

_C_o_n_t_r_o_l _F_l_o_w

_D_e_s_c_r_i_p_t_i_o_n:

     These are the basic control-flow constructs of the R language.
     They function in much the same way as control statements in any
     Algol-like language.  They are all reserved words.

_U_s_a_g_e:

     if(cond) expr
     if(cond) cons.expr  else  alt.expr
     
     for(var in seq) expr
     while(cond) expr
     repeat expr
     break
     next
     
_A_r_g_u_m_e_n_t_s:

    cond: A length-one logical vector that is not ‘NA’.  Conditions of
          length greater than one are currently accepted with a
          warning, but only the first element is used.  An error is
          signalled instead when the environment variable
          ‘_R_CHECK_LENGTH_1_CONDITION_’ is set to true.  Other types
          are coerced to logical if possible, ignoring any class.

     var: A syntactical name for a variable.

     seq: An expression evaluating to a vector (including a list and an
          expression) or to a pairlist or ‘NULL’.  A factor value will
          be coerced to a character vector.

expr, cons.expr, alt.expr: An _expression_ in a formal sense.  This is
          either a simple expression or a so called _compound
          expression_, usually of the form ‘{ expr1 ; expr2 }’.

_D_e_t_a_i_l_s:

     ‘break’ breaks out of a ‘for’, ‘while’ or ‘repeat’ loop; control
     is transferred to the first statement outside the inner-most loop.
     ‘next’ halts the processing of the current iteration and advances
     the looping index.  Both ‘break’ and ‘next’ apply only to the
     innermost of nested loops.

     Note that it is a common mistake to forget to put braces (‘{ ..
     }’) around your statements, e.g., after ‘if(..)’ or ‘for(....)’.
     In particular, you should not have a newline between ‘}’ and
     ‘else’ to avoid a syntax error in entering a ‘if ... else’
     construct at the keyboard or via ‘source’.  For that reason, one
     (somewhat extreme) attitude of defensive programming is to always
     use braces, e.g., for ‘if’ clauses.

     The ‘seq’ in a ‘for’ loop is evaluated at the start of the loop;
     changing it subsequently does not affect the loop.  If ‘seq’ has
     length zero the body of the loop is skipped. Otherwise the
     variable ‘var’ is assigned in turn the value of each element of
     ‘seq’. You can assign to ‘var’ within the body of the loop, but
     this will not affect the next iteration.  When the loop
     terminates, ‘var’ remains as a variable containing its latest
     value.

_V_a_l_u_e:

     ‘if’ returns the value of the expression evaluated, or ‘NULL’
     invisibly if none was (which may happen if there is no ‘else’).

     ‘for’, ‘while’ and ‘repeat’ return ‘NULL’ invisibly.  ‘for’ sets
     ‘var’ to the last used element of ‘seq’, or to ‘NULL’ if it was of
     length zero.

     ‘break’ and ‘next’ do not return a value as they transfer control
     within the loop.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘Syntax’ for the basic R syntax and operators, ‘Paren’ for
     parentheses and braces.

     ‘ifelse’, ‘switch’ for other ways to control flow.

_E_x_a_m_p_l_e_s:

     for(i in 1:5) print(1:i)
     for(n in c(2,5,10,20,50)) {
        x <- stats::rnorm(n)
        cat(n, ": ", sum(x^2), "\n", sep = "")
     }
     f <- factor(sample(letters[1:5], 10, replace = TRUE))
     for(i in unique(f)) print(i)
     

> ?"if"
Control                  package:base                  R Documentation

_C_o_n_t_r_o_l _F_l_o_w

_D_e_s_c_r_i_p_t_i_o_n:

     These are the basic control-flow constructs of the R language.
     They function in much the same way as control statements in any
     Algol-like language.  They are all reserved words.

_U_s_a_g_e:

     if(cond) expr
     if(cond) cons.expr  else  alt.expr
     
     for(var in seq) expr
     while(cond) expr
     repeat expr
     break
     next
     
_A_r_g_u_m_e_n_t_s:

    cond: A length-one logical vector that is not ‘NA’.  Conditions of
          length greater than one are currently accepted with a
          warning, but only the first element is used.  An error is
          signalled instead when the environment variable
          ‘_R_CHECK_LENGTH_1_CONDITION_’ is set to true.  Other types
          are coerced to logical if possible, ignoring any class.

     var: A syntactical name for a variable.

     seq: An expression evaluating to a vector (including a list and an
          expression) or to a pairlist or ‘NULL’.  A factor value will
          be coerced to a character vector.

expr, cons.expr, alt.expr: An _expression_ in a formal sense.  This is
          either a simple expression or a so called _compound
          expression_, usually of the form ‘{ expr1 ; expr2 }’.

_D_e_t_a_i_l_s:

     ‘break’ breaks out of a ‘for’, ‘while’ or ‘repeat’ loop; control
     is transferred to the first statement outside the inner-most loop.
     ‘next’ halts the processing of the current iteration and advances
     the looping index.  Both ‘break’ and ‘next’ apply only to the
     innermost of nested loops.

     Note that it is a common mistake to forget to put braces (‘{ ..
     }’) around your statements, e.g., after ‘if(..)’ or ‘for(....)’.
     In particular, you should not have a newline between ‘}’ and
     ‘else’ to avoid a syntax error in entering a ‘if ... else’
     construct at the keyboard or via ‘source’.  For that reason, one
     (somewhat extreme) attitude of defensive programming is to always
     use braces, e.g., for ‘if’ clauses.

     The ‘seq’ in a ‘for’ loop is evaluated at the start of the loop;
     changing it subsequently does not affect the loop.  If ‘seq’ has
     length zero the body of the loop is skipped. Otherwise the
     variable ‘var’ is assigned in turn the value of each element of
     ‘seq’. You can assign to ‘var’ within the body of the loop, but
     this will not affect the next iteration.  When the loop
     terminates, ‘var’ remains as a variable containing its latest
     value.

_V_a_l_u_e:

     ‘if’ returns the value of the expression evaluated, or ‘NULL’
     invisibly if none was (which may happen if there is no ‘else’).

     ‘for’, ‘while’ and ‘repeat’ return ‘NULL’ invisibly.  ‘for’ sets
     ‘var’ to the last used element of ‘seq’, or to ‘NULL’ if it was of
     length zero.

     ‘break’ and ‘next’ do not return a value as they transfer control
     within the loop.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘Syntax’ for the basic R syntax and operators, ‘Paren’ for
     parentheses and braces.

     ‘ifelse’, ‘switch’ for other ways to control flow.

_E_x_a_m_p_l_e_s:

     for(i in 1:5) print(1:i)
     for(n in c(2,5,10,20,50)) {
        x <- stats::rnorm(n)
        cat(n, ": ", sum(x^2), "\n", sep = "")
     }
     f <- factor(sample(letters[1:5], 10, replace = TRUE))
     for(i in unique(f)) print(i)
     

> ?`if`
Control                  package:base                  R Documentation

_C_o_n_t_r_o_l _F_l_o_w

_D_e_s_c_r_i_p_t_i_o_n:

     These are the basic control-flow constructs of the R language.
     They function in much the same way as control statements in any
     Algol-like language.  They are all reserved words.

_U_s_a_g_e:

     if(cond) expr
     if(cond) cons.expr  else  alt.expr
     
     for(var in seq) expr
     while(cond) expr
     repeat expr
     break
     next
     
_A_r_g_u_m_e_n_t_s:

    cond: A length-one logical vector that is not ‘NA’.  Conditions of
          length greater than one are currently accepted with a
          warning, but only the first element is used.  An error is
          signalled instead when the environment variable
          ‘_R_CHECK_LENGTH_1_CONDITION_’ is set to true.  Other types
          are coerced to logical if possible, ignoring any class.

     var: A syntactical name for a variable.

     seq: An expression evaluating to a vector (including a list and an
          expression) or to a pairlist or ‘NULL’.  A factor value will
          be coerced to a character vector.

expr, cons.expr, alt.expr: An _expression_ in a formal sense.  This is
          either a simple expression or a so called _compound
          expression_, usually of the form ‘{ expr1 ; expr2 }’.

_D_e_t_a_i_l_s:

     ‘break’ breaks out of a ‘for’, ‘while’ or ‘repeat’ loop; control
     is transferred to the first statement outside the inner-most loop.
     ‘next’ halts the processing of the current iteration and advances
     the looping index.  Both ‘break’ and ‘next’ apply only to the
     innermost of nested loops.

     Note that it is a common mistake to forget to put braces (‘{ ..
     }’) around your statements, e.g., after ‘if(..)’ or ‘for(....)’.
     In particular, you should not have a newline between ‘}’ and
     ‘else’ to avoid a syntax error in entering a ‘if ... else’
     construct at the keyboard or via ‘source’.  For that reason, one
     (somewhat extreme) attitude of defensive programming is to always
     use braces, e.g., for ‘if’ clauses.

     The ‘seq’ in a ‘for’ loop is evaluated at the start of the loop;
     changing it subsequently does not affect the loop.  If ‘seq’ has
     length zero the body of the loop is skipped. Otherwise the
     variable ‘var’ is assigned in turn the value of each element of
     ‘seq’. You can assign to ‘var’ within the body of the loop, but
     this will not affect the next iteration.  When the loop
     terminates, ‘var’ remains as a variable containing its latest
     value.

_V_a_l_u_e:

     ‘if’ returns the value of the expression evaluated, or ‘NULL’
     invisibly if none was (which may happen if there is no ‘else’).

     ‘for’, ‘while’ and ‘repeat’ return ‘NULL’ invisibly.  ‘for’ sets
     ‘var’ to the last used element of ‘seq’, or to ‘NULL’ if it was of
     length zero.

     ‘break’ and ‘next’ do not return a value as they transfer control
     within the loop.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘Syntax’ for the basic R syntax and operators, ‘Paren’ for
     parentheses and braces.

     ‘ifelse’, ‘switch’ for other ways to control flow.

_E_x_a_m_p_l_e_s:

     for(i in 1:5) print(1:i)
     for(n in c(2,5,10,20,50)) {
        x <- stats::rnorm(n)
        cat(n, ": ", sum(x^2), "\n", sep = "")
     }
     f <- factor(sample(letters[1:5], 10, replace = TRUE))
     for(i in unique(f)) print(i)
     

> 
> ## Doing Something Else with an if...else Statement
> 
> priceCalculator <- function(hours, pph=40, public=TRUE){
+     net.price <- hours * pph
+     if(hours > 100) net.price <- net.price * 0.9
+     if(public) {
+       tot.price <- net.price * 1.06
+     } else {
+       tot.price <- net.price * 1.12
+     }
+     round(tot.price)
+ }
> 
> priceCalculator(25,public=TRUE)
[1] 1060
> priceCalculator(25,public=FALSE)
[1] 1120
> 
> priceCalculator <- function(hours, pph=40, public=TRUE){
+     net.price <- hours * pph
+     if(hours > 100) net.price <- net.price * 0.9
+     if(public) tot.price <- net.price * 1.06 else
+                tot.price <- net.price * 1.12
+     round(tot.price)
+ }
> 
> priceCalculator <- function(hours, pph=40, public=TRUE){
+     net.price <- hours * pph
+     if(hours > 100) net.price <- net.price * 0.9
+     tot.price <- net.price * if(public) 1.06 else 1.12
+     round(tot.price)
+ }
> 
> # Vectorizing Choices
> 
> ## Looking at the problem
> 
> priceCalculator(c(25,110))
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
: 
 --- package (from environment) --- 
package:rfordummies
 --- call from context --- 
priceCalculator(c(25, 110))
 --- call from argument --- 
if (hours > 100) net.price <- net.price * 0.9
 --- R stacktrace ---
where 1: priceCalculator(c(25, 110))

 --- value of length: 2 type: logical ---
[1] FALSE  TRUE
 --- function from context --- 
function (hours, pph = 40, public = TRUE) 
{
    net.price <- hours * pph
    if (hours > 100) 
        net.price <- net.price * 0.9
    tot.price <- net.price * if (public) 
        1.06
    else 1.12
    round(tot.price)
}
 --- function search by body ---
Function .Last.value in namespace base has this body.
 ----------- END OF FAILURE REPORT -------------- 
Fatal error: the condition has length > 1
* checking PDF version of manual ... OK
* DONE
Status: 1 ERROR
