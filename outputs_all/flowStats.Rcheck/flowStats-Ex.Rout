
R Under development (unstable) (2018-10-04 r75396) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "flowStats"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('flowStats')
Loading required package: flowCore
Loading required package: fda
Loading required package: splines
Loading required package: Matrix

Attaching package: ‘Matrix’

The following object is masked from ‘package:flowCore’:

    %&%


Attaching package: ‘fda’

The following object is masked from ‘package:graphics’:

    matplot

Loading required package: cluster
Loading required package: flowWorkspace
Loading required package: ncdfFlow
Loading required package: RcppArmadillo
Loading required package: BH
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("autoGate")
> ### * autoGate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoGate
> ### Title: Automated gating of single populations in 2D
> ### Aliases: autoGate
> ### Keywords: misc
> 
> ### ** Examples
> 
> 
> data(GvHD)
> flowStats:::autoGate(GvHD[10:15], "FSC-H"=c(100,500), "SSC-H"=c(0, 400))
$x
A flowSet with 6 experiments.

An object of class 'AnnotatedDataFrame'
  rowNames: s6a03 s6a04 ... s7a01 (6 total)
  varLabels: Patient Visit ... name (5 total)
  varMetadata: labelDescription

  column names:
  FSC-H SSC-H FL1-H FL2-H FL3-H FL2-A FL4-H Time

$n2gate
norm2Filter 'defaultNorm2Filter' in dimensions FSC-H and SSC-H with parameters:
  method: covMcd 
  scale.factor: 2.5 
  n: 50000 


$n2gateResults
A list of filterResults for a flowSet containing 6 frames
produced by the filter named 'defaultNorm2Filter'

> 
> 
> 
> 
> cleanEx()
> nameEx("binByRef")
> ### * binByRef
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: binByRef
> ### Title: Bin a test data set using bins previously created by probability
> ###   binning a control dataset
> ### Aliases: binByRef
> ### Keywords: misc
> 
> ### ** Examples
> 
> 
> data(GvHD)
> resCtrl<-proBin(GvHD[[1]],200)  
> resSample<-binByRef(resCtrl,GvHD[[2]])
> ls(resSample)
 [1] "1"  "10" "11" "12" "13" "14" "15" "16" "17" "18" "19" "2"  "20" "21" "22"
[16] "23" "24" "25" "26" "27" "28" "29" "3"  "30" "31" "32" "4"  "5"  "6"  "7" 
[31] "8"  "9" 
> 
> 
> 
> cleanEx()
> nameEx("calcPBChiSquare")
> ### * calcPBChiSquare
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calcPBChiSquare
> ### Title: Probability binning metirc for comparing the probability binned
> ###   datasets
> ### Aliases: calcPBChiSquare
> ### Keywords: misc
> 
> ### ** Examples
> 
> 
> data(GvHD)
> # flow frame 1 is treated as  control dataset and used to generate bins
> resCtrl<-proBin(GvHD[[1]][,c("FSC-H","SSC-H","Time")],200)  
> plotBins(resCtrl,GvHD[[1]],channels=c("FSC-H","SSC-H","Time"),title="Binned control data")
> # Same bins are applied to flowFrame 16
> resSample<-binByRef(resCtrl,GvHD[[16]][,c("FSC-H","SSC-H","Time")])
> ctrlCount<-nrow(GvHD[[1]])
> sampCount<-nrow(GvHD[[16]])
> stat<-calcPBChiSquare(resCtrl,resSample,ctrlCount,sampCount)
> 
> 
> 
> cleanEx()
> nameEx("calcPearsonChi")
> ### * calcPearsonChi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calcPearsonChi
> ### Title: Pearsons chi-square statistic for comparing the probability
> ###   binned datasets
> ### Aliases: calcPearsonChi
> ### Keywords: misc
> 
> ### ** Examples
> 
> 
> data(GvHD)
> # flow frame 1 is treated as  control dataset and used to generate bins
> resCtrl<-proBin(GvHD[[1]][,c("FSC-H","SSC-H","Time")],200)  
> plotBins(resCtrl,GvHD[[1]],channels=c("FSC-H","SSC-H","Time"),title="Binned control data")
> # Same bins are applied to flowFrame 16
> resSample<-binByRef(resCtrl,GvHD[[16]][,c("FSC-H","SSC-H","Time")])
> stat<-calcPearsonChi(resCtrl,resSample)
> 
> 
> 
> cleanEx()
> nameEx("curv1Filter-class")
> ### * curv1Filter-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: curv1Filter-class
> ### Title: Class "curv1Filter"
> ### Aliases: curv1Filter-class curv1Filter show,curv1Filter-method
> ###   %in%,flowFrame,curv1Filter-method
> ###   summarizeFilter,multipleFilterResult,curv1Filter-method
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> 
> library(flowStats)
> ## Loading example data
> dat <- read.FCS(system.file("extdata","0877408774.B08",
+ package="flowCore"))
> 
> ## Create directly. Most likely from a command line
> curv1Filter("FSC-H", filterId="myCurv1Filter", bwFac=2)
1D curvature filter 'myCurv1Filter' in dimension FSC-H
with settings:
  bwFac=2
  gridsize=401,401
> 
> ## To facilitate programmatic construction we also have the following
> c1f <- curv1Filter(filterId="myCurv1Filter", x=list("FSC-H"), bwFac=2)
> 
> ## Filtering using curv1Filter
> fres <- filter(dat, c1f)
> fres
A filterResult produced by the filter named 'myCurv1Filter'
 resulting in multiple populations:
	 rest
	 peak 1
	 peak 2
	 peak 3
	 peak 4
> summary(fres)
rest: 3581 of 10000 events (35.81%)
peak 1: 331 of 10000 events (3.31%)
peak 2: 5575 of 10000 events (55.75%)
peak 3: 455 of 10000 events (4.55%)
peak 4: 58 of 10000 events (0.58%)
> names(fres)
[1] "rest"   "peak 1" "peak 2" "peak 3" "peak 4"
> 
> ## The result of curv1 filtering are multiple sub-populations
> ## and we can split our data set accordingly
> split(dat, fres)
$rest
flowFrame object '0877408774.B08 (rest)'
with 3581 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

$`peak 1`
flowFrame object '0877408774.B08 (peak 1)'
with 331 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

$`peak 2`
flowFrame object '0877408774.B08 (peak 2)'
with 5575 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

$`peak 3`
flowFrame object '0877408774.B08 (peak 3)'
with 455 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

$`peak 4`
flowFrame object '0877408774.B08 (peak 4)'
with 58 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

> 
> ## We can limit the splitting to one or several sub-populations
> split(dat, fres, population="rest")
$rest
flowFrame object '0877408774.B08 (rest)'
with 3581 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

> split(dat, fres, population=list(keep=c("peak 2", "peak 3")))
Warning in subsetKeywords(x, j) : NAs introduced by coercion
$keep
flowFrame object '0877408774.B08 (peak 2,peak 3)'
with 6030 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
3 keywords are stored in the 'description' slot

> 
> 
> 
> 
> cleanEx()
> nameEx("curv2Filter-class")
> ### * curv2Filter-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: curv2Filter-class
> ### Title: Class "curv2Filter"
> ### Aliases: curv2Filter-class curv2Filter show,curv2Filter-method
> ###   %in%,flowFrame,curv2Filter-method
> ###   summarizeFilter,multipleFilterResult,curv2Filter-method
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> 
> ## Loading example data
> dat <- read.FCS(system.file("extdata","0877408774.B08",
+ package="flowCore"))
> 
> ## Create directly. Most likely from a command line
> curv2Filter("FSC-H", "SSC-H", filterId="myCurv2Filter")
2D curvature filter 'myCurv2Filter' in dimensions FSC-H and SSC-H
with settings:
  bwFac=1.2
  gridsize=151,151
> 
> ## To facilitate programmatic construction we also have the following
> c2f <- curv2Filter(filterId="myCurv2Filter", x=list("FSC-H", "SSC-H"),
+ bwFac=2)
> c2f <- curv2Filter(filterId="myCurv2Filter", x=c("FSC-H", "SSC-H"),
+ bwFac=2)
> 
> ## Filtering using curv2Filter
> fres <- filter(dat, c2f)
> fres
A filterResult produced by the filter named 'myCurv2Filter'
 resulting in multiple populations:
	 rest
	 area 1
	 area 2
	 area 3
	 area 4
	 area 5
> summary(fres)
rest: 5764 of 10000 events (57.64%)
area 1: 225 of 10000 events (2.25%)
area 2: 95 of 10000 events (0.95%)
area 3: 3916 of 10000 events (39.16%)
area 4: 0 of 10000 events (0.00%)
area 5: 0 of 10000 events (0.00%)
> names(fres)
[1] "rest"   "area 1" "area 2" "area 3" "area 4" "area 5"
> 
> ## The result of curv2 filtering are multiple sub-populations
> ## and we can split our data set accordingly
> split(dat, fres)
$rest
flowFrame object '0877408774.B08 (rest)'
with 5764 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

$`area 1`
flowFrame object '0877408774.B08 (area 1)'
with 225 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

$`area 2`
flowFrame object '0877408774.B08 (area 2)'
with 95 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

$`area 3`
flowFrame object '0877408774.B08 (area 3)'
with 3916 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

$`area 4`
flowFrame object '0877408774.B08 (area 4)'
with 0 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

$`area 5`
flowFrame object '0877408774.B08 (area 5)'
with 0 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

> 
> ## We can limit the splitting to one or several sub-populations
> split(dat, fres, population="rest")
$rest
flowFrame object '0877408774.B08 (rest)'
with 5764 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
165 keywords are stored in the 'description' slot

> split(dat, fres, population=list(keep=c("area 2", "area 3")))
Warning in subsetKeywords(x, j) : NAs introduced by coercion
$keep
flowFrame object '0877408774.B08 (area 2,area 3)'
with 4011 cells and 8 observables:
     name              desc range minRange maxRange
$P1 FSC-H             FSC-H  1024        0     1023
$P2 SSC-H             SSC-H  1024        0     1023
$P3 FL1-H              <NA>  1024        1    10000
$P4 FL2-H              <NA>  1024        1    10000
$P5 FL3-H              <NA>  1024        1    10000
$P6 FL1-A              <NA>  1024        0     1023
$P7 FL4-H              <NA>  1024        1    10000
$P8  Time Time (51.20 sec.)  1024        0     1023
3 keywords are stored in the 'description' slot

> 
> 
> curv2Filter("FSC-H", "SSC-H", filterId="test filter")
2D curvature filter 'test filter' in dimensions FSC-H and SSC-H
with settings:
  bwFac=1.2
  gridsize=151,151
> 
> 
> 
> 
> cleanEx()
> nameEx("curvPeaks")
> ### * curvPeaks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: curvPeaks
> ### Title: Parse curv1Filter output
> ### Aliases: curvPeaks
> 
> ### ** Examples
> 
> 
> data(GvHD)
> tmp <- filter(GvHD[[10]], curv1Filter("FSC-H"))
> res <-  flowStats:::curvPeaks(tmp, exprs(GvHD[[10]])[, "FSC-H"])
> 
> 
> 
> 
> cleanEx()
> nameEx("density1d")
> ### * density1d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: density1d
> ### Title: Find most likely separation between positive and negative
> ###   populations in 1D
> ### Aliases: density1d
> 
> ### ** Examples
> 
> 
> data(GvHD)
> dat <- GvHD[pData(GvHD)$Patient==10]
> dat <- transform(dat, "FL4-H"=asinh(`FL4-H`), "FL3-H"=asinh(`FL3-H`))
> d <- flowStats:::density1d(dat, "FL4-H", plot=TRUE)
Warning in subsetKeywords(x, j) : NAs introduced by coercion
> if(require(flowViz))
+ densityplot(~`FL4-H`, dat, refline=d)
Loading required package: flowViz
Loading required package: lattice

Attaching package: ‘lattice’

The following objects are masked from ‘package:ncdfFlow’:

    densityplot, histogram, xyplot

> 
> ## tweaking the location
> flowStats:::density1d(dat, "FL4-H", plot=TRUE, alpha=0.8)
Warning in subsetKeywords(x, j) : NAs introduced by coercion
[1] 3.705714
> 
> ## only a single population
> flowStats:::density1d(dat, "FL3-H", plot=TRUE)
Warning in subsetKeywords(x, j) : NAs introduced by coercion
[1] 4.53325
> flowStats:::density1d(dat, "FL3-H", plot=TRUE, sd=2)
Warning in subsetKeywords(x, j) : NAs introduced by coercion
[1] 4.53325
> 
> 
> 
> 
> cleanEx()

detaching ‘package:flowViz’, ‘package:lattice’

> nameEx("gaussNorm")
> ### * gaussNorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gaussNorm
> ### Title: Per-channel normalization based on landmark registration
> ### Aliases: gaussNorm
> 
> ### ** Examples
> 
> 
> data(ITN)
> dat <- transform(ITN, "CD4"=asinh(CD4), "CD3"=asinh(CD3), "CD8"=asinh(CD8))
> lg <- lymphGate(dat, channels=c("CD3", "SSC"),
+ preselection="CD4",scale=1.5)
Warning in subsetKeywords(x, j) : NAs introduced by coercion
Warning in subsetKeywords(x, j) : NAs introduced by coercion
Warning in subsetKeywords(x, j) : NAs introduced by coercion
> dat <- Subset(dat, lg$n2gate)
> datr <- gaussNorm(dat, "CD8")$flowset

Adjusting the distance between landmarks
...............
> if(require(flowViz)){
+ d1 <- densityplot(~CD8, dat, main="original", filter=curv1Filter("CD8"))
+ d2 <- densityplot(~CD8, datr, main="normalized", filter=curv1Filter("CD8"))
+ plot(d1, split=c(1,1,2,1))
+ plot(d2, split=c(2,1,2,1), newpage=FALSE)
+ }
Loading required package: flowViz
Loading required package: lattice

Attaching package: ‘lattice’

The following objects are masked from ‘package:ncdfFlow’:

    densityplot, histogram, xyplot

 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpbHQ8UV/R.INSTALL78365b3ce3e1/flowViz/R/densityplot.R#411: 
 --- package (from environment) --- 
flowViz
 --- call from context --- 
(function(x, y, darg=list(n=50, na.rm=TRUE), frames, channel,
             overlap = 0.3, channel.name, filter=NULL,
             fill=superpose.polygon$col,
             lty=superpose.polygon$lty,
             lwd=superpose.polygon$lwd,
             alpha=superpose.polygon$alpha,
             col=superpose.polygon$border,
             groups=NULL, refline=NULL,
             margin=0.005
			 ,stats=FALSE
			 ,pos=0.5
			 ,digits=2
			 ,abs=FALSE
			 ,fitGate=TRUE
             ,checkName = TRUE
             , plotType = "densityplot"
             , hist.type = "density"
             , breaks = "Sturges"
             ,gp, ...)
{
	
    
    which.channel <- tail(which.packet(), 1)
    
    lc <- length(channel)
    channel <- channel[[which.channel]]
    channel.name <- channel.name[which.channel]
    ycode <- as.numeric(y)
    validName <- !length(grep("\\(", channel.name))
    if(checkName)
      validName <- !(length(grep("\\(", channel.name)) ||
            length(grep("\\(", channel.name)))
    else
      validName <- TRUE
    
    if(!validName)
      warning("Gate will not be plotted because channel names contain '(' character! Try to set checkName to FALSE to skip this check.")

    if (any(duplicated(ycode)))
        warning("Some combinations seem to have multiple samples.  \n  ",
                "Only one will be used.")
    nnm <- as.character(x)
    filter <- .processFilter(filter, nnm, lc = lc, which.channel = which.channel)  
    ny <- nlevels(y)
	superpose.polygon <- flowViz.par.get("superpose.polygon")
    border <- rep(col, length = ny)
    col <- rep(fill, length = ny)
    if(!is.null(groups))
        col <- col[groups]
    lty <- rep(lty, length = ny)
    lwd <- rep(lwd, length = ny)
    alpha <- rep(alpha, length = ny)
    x <- as.character(x)
    height <- (1 + overlap)
    parm <- gsub("`", "", as.character(channel))
	ptList<-plotType("gdensity", parm)
    for (i in rev(seq_len(ny))){
        if (i %in% ycode)
        {
            nm <- x[match(i, ycode)]
            xx <- evalInFlowFrame(channel, frames[[nm]])
            r <- unlist(range(frames[[nm]])[, channel.name])
            
            if(!is.logical(margin)||isTRUE(margin))#when margin is logical FALSE we skip marginal events filtering
            {
              margin <- min(1, max(0, margin))
              pl <- xx<=r[1]
              pr <- xx>=r[2]
              xxt <- xx[!(pl | pr)]
              ## we indicate piled up data by vertical lines (if > 1%) unless
              ## margin=FALSE
              if(margin<1)
                  mbar(xx, list(pl, pr), r, i, col[i], margin)
              }else
                xxt <- xx
            ## we need a smaller bandwidth than the default and keep it constant
            if(length(xxt)){
                
                if(plotType == "densityplot"){
                  #densityplot
                  if(!("adjust" %in% names(darg)))
                    darg[["adjust"]] <- 2
                  
                  h <- do.call(density, c(list(x=xxt), darg))
                  x.val <- h$x
                  y.val <- h$y
                  n <- length(x.val)
                }else{
                  fitGate <- FALSE
                  #histogram
                  h <- lattice:::hist.constructor(xxt, breaks = breaks, ...)
                  y.val <- switch(hist.type, count = h$counts, percent = 100 * h$counts/length(x), density = h$density)
                  x.val <- h$breaks
                  n <- length(x.val)
                  if (length(y.val) != n - 1) 
                    warning("problem with 'hist' computations")
                }

                max.d <- max(y.val)
                xl <- x.val[c(1, 1:n, n)]
                yl <- i + height * c(0, y.val, 0) / max.d
                
                if(plotType == "densityplot")
                  panel.polygon(x=xl,y=yl, col=col[i], border=NA, alpha=alpha[i])
                else
                  panel.rect(x = xl[-n], y = 0, height = yl, width = diff(xl), 
                      col = col[i], alpha = alpha[i], border = border[i], just = c("left", "bottom"), identifier = "histogram")
                
                ## add the filterResult if possible, we get them from the output of
                ## glpolygon (with plot=FALSE)
				
                if(!is.null(filter[[nm]]) && validName){
                  curFilter <- filter[[nm]]
                  
                  if(is.list(stats))
                    curStats <- stats[[nm]]
                  else
                    curStats <- stats
#                browser()
                if(is(curFilter,"filters"))
                {
                  mapply(curFilter,curStats,FUN=function(thisFilter,thisStats){
#                        browser()              
                         names <- .getStats(thisFilter,thisStats, frames[[nm]], digits, ...)
                        

                        #this plot routine is only for 2-d scatter plot
                        #thus set plot as FALSE,just use it to get bounds
                        #add plot stats/names
                        bounds <- glpolygon(thisFilter, frames[[nm]],
                            channels=parm
                            ,ptList=ptList
                            ,verbose=FALSE
                            , plot=FALSE 
                            ,names=names
                            ,xlim=r
                            ,ylim=c(i,i+1)
                            ,strict=FALSE)
                        oo <- options(warn=-1)
                        on.exit(options(oo))
                        if(!is.na(bounds)){
                          ## iterate over gate regions
                          for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
                            if(fitGate)
                            {
                              if(ncol(tb) == 1 && colnames(tb) == parm){
                                sel <- xl >= min(tb) & xl <= max(tb)
                                if(any(sel)){
                                  afun <- approxfun(xl, yl)
                                  xr <- c(min(tb), seq(min(tb), max(tb), len=100),
                                      max(tb))
                                  yr <- c(i, afun(xr[-c(1, length(xr))]), i)
                                  gpd<-gp$gate.density
                                  panel.polygon(xr, yr
                                      , border=gpd$col, col=gpd$fill,
                                      alpha=gpd$alpha, lwd=gpd$lwd,
                                      lty=gpd$lty
                                  )
                                }
                              }	
                            }else
                            {
#								browser()
                              gpg<-gp$gate
                              panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                              panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                            }
                            
                          }
                        }
                        
                        
                        
                        options(oo)
                      })
                }else
                {
					curFilter<-filter[[nm]]
#					browser()
                    if(is.list(stats))
                      thisStats <- stats[[nm]]
                    else
                      thisStats <- stats
                    names <- .getStats(curFilter,thisStats, frames[[nm]], digits, ...)
					
#					browser()
					#this plot routine is only for 2-d scatter plot
					#thus set plot as FALSE,just use it to get bounds
					#add plot stats/names
                    bounds <- glpolygon(curFilter, frames[[nm]],
                                        channels=parm
										,ptList=ptList
                                        ,verbose=FALSE
										, plot=FALSE 
										,names=names
										,xlim=r
										,ylim=c(i,i+1)
										,strict=FALSE)
                    oo <- options(warn=-1)
                    on.exit(options(oo))
                    if(!is.na(bounds)){
                        ## iterate over gate regions
                        for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
							if(fitGate)
							{
								if(ncol(tb) == 1 && colnames(tb) == parm){
									sel <- xl >= min(tb) & xl <= max(tb)
									if(any(sel)){
										afun <- approxfun(xl, yl)
										xr <- c(min(tb), seq(min(tb), max(tb), len=100),
												max(tb))
										yr <- c(i, afun(xr[-c(1, length(xr))]), i)
										gpd<-gp$gate.density
										panel.polygon(xr, yr
												, border=gpd$col, col=gpd$fill,
												alpha=gpd$alpha, lwd=gpd$lwd,
												lty=gpd$lty
												)
									}
								}	
							}else
							{
#								browser()
								gpg<-gp$gate
								panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
								panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
							}
                            
                        }
                    }
					
					
					
                    options(oo)
                }
               }
#				browser()
                panel.lines(x=xl,y=yl, col=border[i], lty=lty[i],lwd=lwd[i])

            }else{
                panel.lines(rl, rep(i,2), col="black")
            }
			
        }
    }
    if(!is.null(refline))
        panel.abline(v=refline)
})(x = quote(1:15), y = quote(1:15), subscripts = quote(1:15), 
    filter = quote(new("curv1Filter", bwFac = 1.2, gridsize = c(401, 
    401), parameters = new("parameters", .Data = list(new("unitytransform", 
        .Data = function () 
        NULL, parameters = "CD8", transformationId = "defaultUnityTransform"))), 
        filterId = "defaultCurv1Filter")), plotType = quote("densityplot"), 
    gp = quote(list(gate = list(alpha = 1, cex = NULL, pch = NULL, 
        col = "#9E0142", fill = "transparent", lwd = 1, lty = "solid"), 
        gate.text = list(font = 1, col = "#000000", alpha = 1, 
            cex = 0.8, lineheight = 0.8, background = list(fill = "white", 
                col = "transparent", alpha = 1)), overlay.symbol = list(
            alpha = 0.5, bg.alpha = 0.3, col = "transparent", 
            fill = "red", cex = 0.5, pch = 19), flow.symbol = list(
            alpha = 1, cex = 0.1, pch = 19, col = "black", fill = "transparent"), 
        gate.density = list(alpha = 1, fill = "#FFFFFFB3", col = "black", 
            lwd = 1, lty = "dotted"), argcolramp = function(n) {
            x <- ramp(seq.int(0, 1, length.out = n))
            rgb(x[, 1L], x[, 2L], x[, 3L], maxColorValue = 255, alpha = alpha * 255)
          }, grid.pars = list(), fontsize = list(text = 12, points = 8), 
        background = list(alpha = 1, col = "transparent"), panel.background = list(
            col = "grey90"), clip = list(panel = "on", strip = "on"), 
        add.line = list(alpha = 1, col = "black", lty = 1, lwd = 1), 
        add.text = list(alpha = 1, cex = 0.8, col = "black", 
            font = 1, lineheight = 1.2), plot.polygon = list(
            alpha = 1, col = "grey20", border = "transparent", 
            lty = 1, lwd = 1), box.dot = list(alpha = 1, col = "grey20", 
            cex = 1, font = 1, pch = "|"), box.rectangle = list(
            alpha = 1, col = "grey20", fill = "white", lty = 1, 
            lwd = 1), box.umbrella = list(alpha = 1, col = "grey20", 
            lty = 1, lwd = 1), dot.line = list(alpha = 1, col = "white", 
            lty = 1, lwd = 1), dot.symbol = list(alpha = 1, cex = 0.8, 
            col = "black", font = 1, pch = 19), plot.line = list(
            alpha = 1, col = "black", lty = 1, lwd = 1), plot.symbol = list(
            alpha = 1, cex = 0.6, col = "black", font = 1, pch = 19, 
            fill = "transparent"), reference.line = list(alpha = 1, 
            col = "white", lty = 1, lwd = 1), strip.background = list(
            alpha = 1, col = c("grey80", "grey70", "grey60")), 
        strip.shingle = list(alpha = 1, col = c("grey60", "grey50", 
        "grey40")), strip.border = list(alpha = 1, col = "transparent", 
            lty = c(1, 1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 
            1, 1, 1)), superpose.line = list(alpha = 1, col = c("#F8766D", 
        "#B79F00", "#00BA38", "#00BFC4", "#619CFF", "#F564E3"
        ), lty = c(1, 1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 
        1, 1, 1)), superpose.symbol = list(alpha = c(1, 1, 1, 
        1, 1, 1, 1), cex = 0.6, col = c("#F8766D", "#B79F00", 
        "#00BA38", "#00BFC4", "#619CFF", "#F564E3"), fill = c("#CCFFFF", 
        "#FFCCFF", "#CCFFCC", "#FFE5CC", "#CCE6FF", "#FFFFCC", 
        "#FFCCCC"), font = c(1, 1, 1, 1, 1, 1, 1), pch = 19), 
        superpose.polygon = list(alpha = c(1, 1, 1, 1, 1, 1, 
        1), col = c("#F8766D", "#B79F00", "#00BA38", "#00BFC4", 
        "#619CFF", "#F564E3"), border = "transparent", lty = c(1, 
        1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 1, 1, 1)), regions = list(
            alpha = 1, col = c("#3B4FB8", "#3C4EB6", "#3D4DB4", 
            "#3E4DB3", "#404CB1", "#414CB0", "#424BAE", "#434BAC", 
            "#454AAB", "#464AA9", "#4749A8", "#4849A6", "#4A48A4", 
            "#4B48A3", "#4C47A1", "#4D47A0", "#4F469E", "#50469C", 
            "#51459B", "#524599", "#544498", "#554396", "#564394", 
            "#574293", "#594291", "#5A4190", "#5B418E", "#5C408C", 
            "#5E408B", "#5F3F89", "#603F88", "#613E86", "#633E84", 
            "#643D83", "#653D81", "#663C80", "#683C7E", "#693B7C", 
            "#6A3B7B", "#6B3A79", "#6D3978", "#6E3976", "#6F3874", 
            "#703873", "#723771", "#733770", "#74366E", "#75366C", 
            "#77356B", "#783569", "#793468", "#7A3466", "#7C3365", 
            "#7D3363", "#7E3261", "#7F3260", "#81315E", "#82315D", 
            "#83305B", "#843059", "#862F58", "#872E56", "#882E55", 
            "#892D53", "#8B2D51", "#8C2C50", "#8D2C4E", "#8E2B4D", 
            "#902B4B", "#912A49", "#922A48", "#932946", "#952945", 
            "#962843", "#972841", "#982740", "#9A273E", "#9B263D", 
            "#9C263B", "#9D2539", "#9F2438", "#A02436", "#A12335", 
            "#A22333", "#A42231", "#A52230", "#A6212E", "#A7212D", 
            "#A9202B", "#AA2029", "#AB1F28", "#AC1F26", "#AE1E25", 
            "#AF1E23", "#B01D21", "#B11D20", "#B31C1E", "#B41C1D", 
            "#B51B1B", "#B71B1A")), shade.colors = list(alpha = 1, 
            palette = function(irr, ref, height, saturation = .9) {
                             hsv(h = height, s = 1 - saturation * (1 - (1-ref)^0.5), v = irr)
                         }), axis.line = list(alpha = 1, col = "transparent", 
            lty = 1, lwd = 1), axis.text = list(alpha = 1, cex = 0.8, 
            col = "grey50", font = 1, lineheight = 0.9), axis.components = list(
            left = list(tck = 1, pad1 = 1, pad2 = 1), top = list(
                tck = 1, pad1 = 1, pad2 = 1), right = list(tck = 1, 
                pad1 = 1, pad2 = 1), bottom = list(tck = 1, pad1 = 1, 
                pad2 = 1)), layout.heights = list(top.padding = 1, 
            main = 1, main.key.padding = 1, key.top = 1, xlab.top = 1, 
            key.axis.padding = 1, axis.top = 1, strip = 1, panel = 1, 
            axis.panel = 1, between = 1, axis.bottom = 1, axis.xlab.padding = 1, 
            xlab = 1, xlab.key.padding = 0, key.bottom = 1, key.sub.padding = 1, 
            sub = 1, bottom.padding = 1), layout.widths = list(
            left.padding = 1, key.left = 1, key.ylab.padding = 0, 
            ylab = 1, ylab.axis.padding = 1, axis.left = 1, axis.panel = 1, 
            strip.left = 1, panel = 1, between = 1, axis.right = 1, 
            axis.key.padding = 1, ylab.right = 1, key.right = 1, 
            right.padding = 1), box.3d = list(alpha = 1, col = "black", 
            lty = 1, lwd = 1), par.xlab.text = list(alpha = 1, 
            cex = 1, col = "black", font = 1, lineheight = 1), 
        par.ylab.text = list(alpha = 1, cex = 1, col = "black", 
            font = 1, lineheight = 1), par.zlab.text = list(alpha = 1, 
            cex = 1, col = "black", font = 1, lineheight = 1), 
        par.main.text = list(alpha = 1, cex = 1.2, col = "black", 
            font = 2, lineheight = 1), par.sub.text = list(alpha = 1, 
            cex = 1, col = "black", font = 2, lineheight = 1))), 
    channel = quote(list(CD8 = CD8)), channel.name = quote(c(CD8 = "CD8")), 
    frames = quote(<environment>), overlap = quote(0.3), which.channel = quote(c("CD8", 
    "CD8", "CD8", "CD8", "CD8", "CD8", "CD8", "CD8", "CD8", "CD8", 
    "CD8", "CD8", "CD8", "CD8", "CD8")), box.ratio = quote(1), 
    horizontal = quote(TRUE))
 --- call from argument --- 
if (!is.na(bounds)) {
    for (j in seq_along(bounds)) {
        tb <- bounds[[j]]
        if (fitGate) {
            if (ncol(tb) == 1 && colnames(tb) == parm) {
                sel <- xl >= min(tb) & xl <= max(tb)
                if (any(sel)) {
                  afun <- approxfun(xl, yl)
                  xr <- c(min(tb), seq(min(tb), max(tb), len = 100), 
                    max(tb))
                  yr <- c(i, afun(xr[-c(1, length(xr))]), i)
                  gpd <- gp$gate.density
                  panel.polygon(xr, yr, border = gpd$col, col = gpd$fill, 
                    alpha = gpd$alpha, lwd = gpd$lwd, lty = gpd$lty)
                }
            }
        }
        else {
            gpg <- gp$gate
            panel.lines(x = c(tb[1], tb[1]), y = c(i, i + height), 
                col = gpg$col, alpha = gpg$alpha, lwd = gpg$lwd, 
                lty = gpg$lty)
            panel.lines(x = c(tb[2], tb[2]), y = c(i, i + height), 
                col = gpg$col, alpha = gpg$alpha, lwd = gpg$lwd, 
                lty = gpg$lty)
        }
    }
}
 --- R stacktrace ---
where 1: (function(x, y, darg=list(n=50, na.rm=TRUE), frames, channel,
             overlap = 0.3, channel.name, filter=NULL,
             fill=superpose.polygon$col,
             lty=superpose.polygon$lty,
             lwd=superpose.polygon$lwd,
             alpha=superpose.polygon$alpha,
             col=superpose.polygon$border,
             groups=NULL, refline=NULL,
             margin=0.005
			 ,stats=FALSE
			 ,pos=0.5
			 ,digits=2
			 ,abs=FALSE
			 ,fitGate=TRUE
             ,checkName = TRUE
             , plotType = "densityplot"
             , hist.type = "density"
             , breaks = "Sturges"
             ,gp, ...)
{
	
    
    which.channel <- tail(which.packet(), 1)
    
    lc <- length(channel)
    channel <- channel[[which.channel]]
    channel.name <- channel.name[which.channel]
    ycode <- as.numeric(y)
    validName <- !length(grep("\\(", channel.name))
    if(checkName)
      validName <- !(length(grep("\\(", channel.name)) ||
            length(grep("\\(", channel.name)))
    else
      validName <- TRUE
    
    if(!validName)
      warning("Gate will not be plotted because channel names contain '(' character! Try to set checkName to FALSE to skip this check.")

    if (any(duplicated(ycode)))
        warning("Some combinations seem to have multiple samples.  \n  ",
                "Only one will be used.")
    nnm <- as.character(x)
    filter <- .processFilter(filter, nnm, lc = lc, which.channel = which.channel)  
    ny <- nlevels(y)
	superpose.polygon <- flowViz.par.get("superpose.polygon")
    border <- rep(col, length = ny)
    col <- rep(fill, length = ny)
    if(!is.null(groups))
        col <- col[groups]
    lty <- rep(lty, length = ny)
    lwd <- rep(lwd, length = ny)
    alpha <- rep(alpha, length = ny)
    x <- as.character(x)
    height <- (1 + overlap)
    parm <- gsub("`", "", as.character(channel))
	ptList<-plotType("gdensity", parm)
    for (i in rev(seq_len(ny))){
        if (i %in% ycode)
        {
            nm <- x[match(i, ycode)]
            xx <- evalInFlowFrame(channel, frames[[nm]])
            r <- unlist(range(frames[[nm]])[, channel.name])
            
            if(!is.logical(margin)||isTRUE(margin))#when margin is logical FALSE we skip marginal events filtering
            {
              margin <- min(1, max(0, margin))
              pl <- xx<=r[1]
              pr <- xx>=r[2]
              xxt <- xx[!(pl | pr)]
              ## we indicate piled up data by vertical lines (if > 1%) unless
              ## margin=FALSE
              if(margin<1)
                  mbar(xx, list(pl, pr), r, i, col[i], margin)
              }else
                xxt <- xx
            ## we need a smaller bandwidth than the default and keep it constant
            if(length(xxt)){
                
                if(plotType == "densityplot"){
                  #densityplot
                  if(!("adjust" %in% names(darg)))
                    darg[["adjust"]] <- 2
                  
                  h <- do.call(density, c(list(x=xxt), darg))
                  x.val <- h$x
                  y.val <- h$y
                  n <- length(x.val)
                }else{
                  fitGate <- FALSE
                  #histogram
                  h <- lattice:::hist.constructor(xxt, breaks = breaks, ...)
                  y.val <- switch(hist.type, count = h$counts, percent = 100 * h$counts/length(x), density = h$density)
                  x.val <- h$breaks
                  n <- length(x.val)
                  if (length(y.val) != n - 1) 
                    warning("problem with 'hist' computations")
                }

                max.d <- max(y.val)
                xl <- x.val[c(1, 1:n, n)]
                yl <- i + height * c(0, y.val, 0) / max.d
                
                if(plotType == "densityplot")
                  panel.polygon(x=xl,y=yl, col=col[i], border=NA, alpha=alpha[i])
                else
                  panel.rect(x = xl[-n], y = 0, height = yl, width = diff(xl), 
                      col = col[i], alpha = alpha[i], border = border[i], just = c("left", "bottom"), identifier = "histogram")
                
                ## add the filterResult if possible, we get them from the output of
                ## glpolygon (with plot=FALSE)
				
                if(!is.null(filter[[nm]]) && validName){
                  curFilter <- filter[[nm]]
                  
                  if(is.list(stats))
                    curStats <- stats[[nm]]
                  else
                    curStats <- stats
#                browser()
                if(is(curFilter,"filters"))
                {
                  mapply(curFilter,curStats,FUN=function(thisFilter,thisStats){
#                        browser()              
                         names <- .getStats(thisFilter,thisStats, frames[[nm]], digits, ...)
                        

                        #this plot routine is only for 2-d scatter plot
                        #thus set plot as FALSE,just use it to get bounds
                        #add plot stats/names
                        bounds <- glpolygon(thisFilter, frames[[nm]],
                            channels=parm
                            ,ptList=ptList
                            ,verbose=FALSE
                            , plot=FALSE 
                            ,names=names
                            ,xlim=r
                            ,ylim=c(i,i+1)
                            ,strict=FALSE)
                        oo <- options(warn=-1)
                        on.exit(options(oo))
                        if(!is.na(bounds)){
                          ## iterate over gate regions
                          for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
                            if(fitGate)
                            {
                              if(ncol(tb) == 1 && colnames(tb) == parm){
                                sel <- xl >= min(tb) & xl <= max(tb)
                                if(any(sel)){
                                  afun <- approxfun(xl, yl)
                                  xr <- c(min(tb), seq(min(tb), max(tb), len=100),
                                      max(tb))
                                  yr <- c(i, afun(xr[-c(1, length(xr))]), i)
                                  gpd<-gp$gate.density
                                  panel.polygon(xr, yr
                                      , border=gpd$col, col=gpd$fill,
                                      alpha=gpd$alpha, lwd=gpd$lwd,
                                      lty=gpd$lty
                                  )
                                }
                              }	
                            }else
                            {
#								browser()
                              gpg<-gp$gate
                              panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                              panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                            }
                            
                          }
                        }
                        
                        
                        
                        options(oo)
                      })
                }else
                {
					curFilter<-filter[[nm]]
#					browser()
                    if(is.list(stats))
                      thisStats <- stats[[nm]]
                    else
                      thisStats <- stats
                    names <- .getStats(curFilter,thisStats, frames[[nm]], digits, ...)
					
#					browser()
					#this plot routine is only for 2-d scatter plot
					#thus set plot as FALSE,just use it to get bounds
					#add plot stats/names
                    bounds <- glpolygon(curFilter, frames[[nm]],
                                        channels=parm
										,ptList=ptList
                                        ,verbose=FALSE
										, plot=FALSE 
										,names=names
										,xlim=r
										,ylim=c(i,i+1)
										,strict=FALSE)
                    oo <- options(warn=-1)
                    on.exit(options(oo))
                    if(!is.na(bounds)){
                        ## iterate over gate regions
                        for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
							if(fitGate)
							{
								if(ncol(tb) == 1 && colnames(tb) == parm){
									sel <- xl >= min(tb) & xl <= max(tb)
									if(any(sel)){
										afun <- approxfun(xl, yl)
										xr <- c(min(tb), seq(min(tb), max(tb), len=100),
												max(tb))
										yr <- c(i, afun(xr[-c(1, length(xr))]), i)
										gpd<-gp$gate.density
										panel.polygon(xr, yr
												, border=gpd$col, col=gpd$fill,
												alpha=gpd$alpha, lwd=gpd$lwd,
												lty=gpd$lty
												)
									}
								}	
							}else
							{
#								browser()
								gpg<-gp$gate
								panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
								panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
							}
                            
                        }
                    }
					
					
					
                    options(oo)
                }
               }
#				browser()
                panel.lines(x=xl,y=yl, col=border[i], lty=lty[i],lwd=lwd[i])

            }else{
                panel.lines(rl, rep(i,2), col="black")
            }
			
        }
    }
    if(!is.null(refline))
        panel.abline(v=refline)
})(x = quote(1:15), y = quote(1:15), subscripts = quote(1:15), 
    filter = quote(new("curv1Filter", bwFac = 1.2, gridsize = c(401, 
    401), parameters = new("parameters", .Data = list(new("unitytransform", 
        .Data = function () 
        NULL, parameters = "CD8", transformationId = "defaultUnityTransform"))), 
        filterId = "defaultCurv1Filter")), plotType = quote("densityplot"), 
    gp = quote(list(gate = list(alpha = 1, cex = NULL, pch = NULL, 
        col = "#9E0142", fill = "transparent", lwd = 1, lty = "solid"), 
        gate.text = list(font = 1, col = "#000000", alpha = 1, 
            cex = 0.8, lineheight = 0.8, background = list(fill = "white", 
                col = "transparent", alpha = 1)), overlay.symbol = list(
            alpha = 0.5, bg.alpha = 0.3, col = "transparent", 
            fill = "red", cex = 0.5, pch = 19), flow.symbol = list(
            alpha = 1, cex = 0.1, pch = 19, col = "black", fill = "transparent"), 
        gate.density = list(alpha = 1, fill = "#FFFFFFB3", col = "black", 
            lwd = 1, lty = "dotted"), argcolramp = function(n) {
            x <- ramp(seq.int(0, 1, length.out = n))
            rgb(x[, 1L], x[, 2L], x[, 3L], maxColorValue = 255, alpha = alpha * 255)
          }, grid.pars = list(), fontsize = list(text = 12, points = 8), 
        background = list(alpha = 1, col = "transparent"), panel.background = list(
            col = "grey90"), clip = list(panel = "on", strip = "on"), 
        add.line = list(alpha = 1, col = "black", lty = 1, lwd = 1), 
        add.text = list(alpha = 1, cex = 0.8, col = "black", 
            font = 1, lineheight = 1.2), plot.polygon = list(
            alpha = 1, col = "grey20", border = "transparent", 
            lty = 1, lwd = 1), box.dot = list(alpha = 1, col = "grey20", 
            cex = 1, font = 1, pch = "|"), box.rectangle = list(
            alpha = 1, col = "grey20", fill = "white", lty = 1, 
            lwd = 1), box.umbrella = list(alpha = 1, col = "grey20", 
            lty = 1, lwd = 1), dot.line = list(alpha = 1, col = "white", 
            lty = 1, lwd = 1), dot.symbol = list(alpha = 1, cex = 0.8, 
            col = "black", font = 1, pch = 19), plot.line = list(
            alpha = 1, col = "black", lty = 1, lwd = 1), plot.symbol = list(
            alpha = 1, cex = 0.6, col = "black", font = 1, pch = 19, 
            fill = "transparent"), reference.line = list(alpha = 1, 
            col = "white", lty = 1, lwd = 1), strip.background = list(
            alpha = 1, col = c("grey80", "grey70", "grey60")), 
        strip.shingle = list(alpha = 1, col = c("grey60", "grey50", 
        "grey40")), strip.border = list(alpha = 1, col = "transparent", 
            lty = c(1, 1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 
            1, 1, 1)), superpose.line = list(alpha = 1, col = c("#F8766D", 
        "#B79F00", "#00BA38", "#00BFC4", "#619CFF", "#F564E3"
        ), lty = c(1, 1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 
        1, 1, 1)), superpose.symbol = list(alpha = c(1, 1, 1, 
        1, 1, 1, 1), cex = 0.6, col = c("#F8766D", "#B79F00", 
        "#00BA38", "#00BFC4", "#619CFF", "#F564E3"), fill = c("#CCFFFF", 
        "#FFCCFF", "#CCFFCC", "#FFE5CC", "#CCE6FF", "#FFFFCC", 
        "#FFCCCC"), font = c(1, 1, 1, 1, 1, 1, 1), pch = 19), 
        superpose.polygon = list(alpha = c(1, 1, 1, 1, 1, 1, 
        1), col = c("#F8766D", "#B79F00", "#00BA38", "#00BFC4", 
        "#619CFF", "#F564E3"), border = "transparent", lty = c(1, 
        1, 1, 1, 1, 1, 1), lwd = c(1, 1, 1, 1, 1, 1, 1)), regions = list(
            alpha = 1, col = c("#3B4FB8", "#3C4EB6", "#3D4DB4", 
            "#3E4DB3", "#404CB1", "#414CB0", "#424BAE", "#434BAC", 
            "#454AAB", "#464AA9", "#4749A8", "#4849A6", "#4A48A4", 
            "#4B48A3", "#4C47A1", "#4D47A0", "#4F469E", "#50469C", 
            "#51459B", "#524599", "#544498", "#554396", "#564394", 
            "#574293", "#594291", "#5A4190", "#5B418E", "#5C408C", 
            "#5E408B", "#5F3F89", "#603F88", "#613E86", "#633E84", 
            "#643D83", "#653D81", "#663C80", "#683C7E", "#693B7C", 
            "#6A3B7B", "#6B3A79", "#6D3978", "#6E3976", "#6F3874", 
            "#703873", "#723771", "#733770", "#74366E", "#75366C", 
            "#77356B", "#783569", "#793468", "#7A3466", "#7C3365", 
            "#7D3363", "#7E3261", "#7F3260", "#81315E", "#82315D", 
            "#83305B", "#843059", "#862F58", "#872E56", "#882E55", 
            "#892D53", "#8B2D51", "#8C2C50", "#8D2C4E", "#8E2B4D", 
            "#902B4B", "#912A49", "#922A48", "#932946", "#952945", 
            "#962843", "#972841", "#982740", "#9A273E", "#9B263D", 
            "#9C263B", "#9D2539", "#9F2438", "#A02436", "#A12335", 
            "#A22333", "#A42231", "#A52230", "#A6212E", "#A7212D", 
            "#A9202B", "#AA2029", "#AB1F28", "#AC1F26", "#AE1E25", 
            "#AF1E23", "#B01D21", "#B11D20", "#B31C1E", "#B41C1D", 
            "#B51B1B", "#B71B1A")), shade.colors = list(alpha = 1, 
            palette = function(irr, ref, height, saturation = .9) {
                             hsv(h = height, s = 1 - saturation * (1 - (1-ref)^0.5), v = irr)
                         }), axis.line = list(alpha = 1, col = "transparent", 
            lty = 1, lwd = 1), axis.text = list(alpha = 1, cex = 0.8, 
            col = "grey50", font = 1, lineheight = 0.9), axis.components = list(
            left = list(tck = 1, pad1 = 1, pad2 = 1), top = list(
                tck = 1, pad1 = 1, pad2 = 1), right = list(tck = 1, 
                pad1 = 1, pad2 = 1), bottom = list(tck = 1, pad1 = 1, 
                pad2 = 1)), layout.heights = list(top.padding = 1, 
            main = 1, main.key.padding = 1, key.top = 1, xlab.top = 1, 
            key.axis.padding = 1, axis.top = 1, strip = 1, panel = 1, 
            axis.panel = 1, between = 1, axis.bottom = 1, axis.xlab.padding = 1, 
            xlab = 1, xlab.key.padding = 0, key.bottom = 1, key.sub.padding = 1, 
            sub = 1, bottom.padding = 1), layout.widths = list(
            left.padding = 1, key.left = 1, key.ylab.padding = 0, 
            ylab = 1, ylab.axis.padding = 1, axis.left = 1, axis.panel = 1, 
            strip.left = 1, panel = 1, between = 1, axis.right = 1, 
            axis.key.padding = 1, ylab.right = 1, key.right = 1, 
            right.padding = 1), box.3d = list(alpha = 1, col = "black", 
            lty = 1, lwd = 1), par.xlab.text = list(alpha = 1, 
            cex = 1, col = "black", font = 1, lineheight = 1), 
        par.ylab.text = list(alpha = 1, cex = 1, col = "black", 
            font = 1, lineheight = 1), par.zlab.text = list(alpha = 1, 
            cex = 1, col = "black", font = 1, lineheight = 1), 
        par.main.text = list(alpha = 1, cex = 1.2, col = "black", 
            font = 2, lineheight = 1), par.sub.text = list(alpha = 1, 
            cex = 1, col = "black", font = 2, lineheight = 1))), 
    channel = quote(list(CD8 = CD8)), channel.name = quote(c(CD8 = "CD8")), 
    frames = quote(<environment>), overlap = quote(0.3), which.channel = quote(c("CD8", 
    "CD8", "CD8", "CD8", "CD8", "CD8", "CD8", "CD8", "CD8", "CD8", 
    "CD8", "CD8", "CD8", "CD8", "CD8")), box.ratio = quote(1), 
    horizontal = quote(TRUE))
where 2 at /var/scratch2/tomas/tmp/RtmpcDb5qX/R.INSTALL704449cf62db/lattice/R/miscellaneous.R#44: do.call(FUN, args, quote = TRUE)
where 3 at /var/scratch2/tomas/tmp/RtmpcDb5qX/R.INSTALL704449cf62db/lattice/R/print.trellis.R#1190: checkArgsAndCall(panel, pargs)
where 4: doTryCatch(return(expr), name, parentenv, handler)
where 5: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 6: tryCatchList(expr, classes, parentenv, handlers)
where 7 at /var/scratch2/tomas/tmp/RtmpcDb5qX/R.INSTALL704449cf62db/lattice/R/print.trellis.R#1190: tryCatch(checkArgsAndCall(panel, pargs), error = function(e) panel.error(e))
where 8 at ../../../../R/src/library/graphics/R/plot.R#21: plot.trellis(d1, split = c(1, 1, 2, 1))
where 9: plot(d1, split = c(1, 1, 2, 1))
where 10: plot(d1, split = c(1, 1, 2, 1))

 --- value of length: 2 type: logical ---
[1] TRUE TRUE
 --- function from context --- 
function(x, y, darg=list(n=50, na.rm=TRUE), frames, channel,
             overlap = 0.3, channel.name, filter=NULL,
             fill=superpose.polygon$col,
             lty=superpose.polygon$lty,
             lwd=superpose.polygon$lwd,
             alpha=superpose.polygon$alpha,
             col=superpose.polygon$border,
             groups=NULL, refline=NULL,
             margin=0.005
			 ,stats=FALSE
			 ,pos=0.5
			 ,digits=2
			 ,abs=FALSE
			 ,fitGate=TRUE
             ,checkName = TRUE
             , plotType = "densityplot"
             , hist.type = "density"
             , breaks = "Sturges"
             ,gp, ...)
{
	
    
    which.channel <- tail(which.packet(), 1)
    
    lc <- length(channel)
    channel <- channel[[which.channel]]
    channel.name <- channel.name[which.channel]
    ycode <- as.numeric(y)
    validName <- !length(grep("\\(", channel.name))
    if(checkName)
      validName <- !(length(grep("\\(", channel.name)) ||
            length(grep("\\(", channel.name)))
    else
      validName <- TRUE
    
    if(!validName)
      warning("Gate will not be plotted because channel names contain '(' character! Try to set checkName to FALSE to skip this check.")

    if (any(duplicated(ycode)))
        warning("Some combinations seem to have multiple samples.  \n  ",
                "Only one will be used.")
    nnm <- as.character(x)
    filter <- .processFilter(filter, nnm, lc = lc, which.channel = which.channel)  
    ny <- nlevels(y)
	superpose.polygon <- flowViz.par.get("superpose.polygon")
    border <- rep(col, length = ny)
    col <- rep(fill, length = ny)
    if(!is.null(groups))
        col <- col[groups]
    lty <- rep(lty, length = ny)
    lwd <- rep(lwd, length = ny)
    alpha <- rep(alpha, length = ny)
    x <- as.character(x)
    height <- (1 + overlap)
    parm <- gsub("`", "", as.character(channel))
	ptList<-plotType("gdensity", parm)
    for (i in rev(seq_len(ny))){
        if (i %in% ycode)
        {
            nm <- x[match(i, ycode)]
            xx <- evalInFlowFrame(channel, frames[[nm]])
            r <- unlist(range(frames[[nm]])[, channel.name])
            
            if(!is.logical(margin)||isTRUE(margin))#when margin is logical FALSE we skip marginal events filtering
            {
              margin <- min(1, max(0, margin))
              pl <- xx<=r[1]
              pr <- xx>=r[2]
              xxt <- xx[!(pl | pr)]
              ## we indicate piled up data by vertical lines (if > 1%) unless
              ## margin=FALSE
              if(margin<1)
                  mbar(xx, list(pl, pr), r, i, col[i], margin)
              }else
                xxt <- xx
            ## we need a smaller bandwidth than the default and keep it constant
            if(length(xxt)){
                
                if(plotType == "densityplot"){
                  #densityplot
                  if(!("adjust" %in% names(darg)))
                    darg[["adjust"]] <- 2
                  
                  h <- do.call(density, c(list(x=xxt), darg))
                  x.val <- h$x
                  y.val <- h$y
                  n <- length(x.val)
                }else{
                  fitGate <- FALSE
                  #histogram
                  h <- lattice:::hist.constructor(xxt, breaks = breaks, ...)
                  y.val <- switch(hist.type, count = h$counts, percent = 100 * h$counts/length(x), density = h$density)
                  x.val <- h$breaks
                  n <- length(x.val)
                  if (length(y.val) != n - 1) 
                    warning("problem with 'hist' computations")
                }

                max.d <- max(y.val)
                xl <- x.val[c(1, 1:n, n)]
                yl <- i + height * c(0, y.val, 0) / max.d
                
                if(plotType == "densityplot")
                  panel.polygon(x=xl,y=yl, col=col[i], border=NA, alpha=alpha[i])
                else
                  panel.rect(x = xl[-n], y = 0, height = yl, width = diff(xl), 
                      col = col[i], alpha = alpha[i], border = border[i], just = c("left", "bottom"), identifier = "histogram")
                
                ## add the filterResult if possible, we get them from the output of
                ## glpolygon (with plot=FALSE)
				
                if(!is.null(filter[[nm]]) && validName){
                  curFilter <- filter[[nm]]
                  
                  if(is.list(stats))
                    curStats <- stats[[nm]]
                  else
                    curStats <- stats
#                browser()
                if(is(curFilter,"filters"))
                {
                  mapply(curFilter,curStats,FUN=function(thisFilter,thisStats){
#                        browser()              
                         names <- .getStats(thisFilter,thisStats, frames[[nm]], digits, ...)
                        

                        #this plot routine is only for 2-d scatter plot
                        #thus set plot as FALSE,just use it to get bounds
                        #add plot stats/names
                        bounds <- glpolygon(thisFilter, frames[[nm]],
                            channels=parm
                            ,ptList=ptList
                            ,verbose=FALSE
                            , plot=FALSE 
                            ,names=names
                            ,xlim=r
                            ,ylim=c(i,i+1)
                            ,strict=FALSE)
                        oo <- options(warn=-1)
                        on.exit(options(oo))
                        if(!is.na(bounds)){
                          ## iterate over gate regions
                          for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
                            if(fitGate)
                            {
                              if(ncol(tb) == 1 && colnames(tb) == parm){
                                sel <- xl >= min(tb) & xl <= max(tb)
                                if(any(sel)){
                                  afun <- approxfun(xl, yl)
                                  xr <- c(min(tb), seq(min(tb), max(tb), len=100),
                                      max(tb))
                                  yr <- c(i, afun(xr[-c(1, length(xr))]), i)
                                  gpd<-gp$gate.density
                                  panel.polygon(xr, yr
                                      , border=gpd$col, col=gpd$fill,
                                      alpha=gpd$alpha, lwd=gpd$lwd,
                                      lty=gpd$lty
                                  )
                                }
                              }	
                            }else
                            {
#								browser()
                              gpg<-gp$gate
                              panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                              panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
                                  ,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
                            }
                            
                          }
                        }
                        
                        
                        
                        options(oo)
                      })
                }else
                {
					curFilter<-filter[[nm]]
#					browser()
                    if(is.list(stats))
                      thisStats <- stats[[nm]]
                    else
                      thisStats <- stats
                    names <- .getStats(curFilter,thisStats, frames[[nm]], digits, ...)
					
#					browser()
					#this plot routine is only for 2-d scatter plot
					#thus set plot as FALSE,just use it to get bounds
					#add plot stats/names
                    bounds <- glpolygon(curFilter, frames[[nm]],
                                        channels=parm
										,ptList=ptList
                                        ,verbose=FALSE
										, plot=FALSE 
										,names=names
										,xlim=r
										,ylim=c(i,i+1)
										,strict=FALSE)
                    oo <- options(warn=-1)
                    on.exit(options(oo))
                    if(!is.na(bounds)){
                        ## iterate over gate regions
                        for(j in seq_along(bounds)){
                            tb <- bounds[[j]]
#							browser()
							if(fitGate)
							{
								if(ncol(tb) == 1 && colnames(tb) == parm){
									sel <- xl >= min(tb) & xl <= max(tb)
									if(any(sel)){
										afun <- approxfun(xl, yl)
										xr <- c(min(tb), seq(min(tb), max(tb), len=100),
												max(tb))
										yr <- c(i, afun(xr[-c(1, length(xr))]), i)
										gpd<-gp$gate.density
										panel.polygon(xr, yr
												, border=gpd$col, col=gpd$fill,
												alpha=gpd$alpha, lwd=gpd$lwd,
												lty=gpd$lty
												)
									}
								}	
							}else
							{
#								browser()
								gpg<-gp$gate
								panel.lines(x=c(tb[1],tb[1]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
								panel.lines(x=c(tb[2],tb[2]),y=c(i,i+height)
										,col=gpg$col,alpha=gpg$alpha, lwd=gpg$lwd,lty=gpg$lty)
							}
                            
                        }
                    }
					
					
					
                    options(oo)
                }
               }
#				browser()
                panel.lines(x=xl,y=yl, col=border[i], lty=lty[i],lwd=lwd[i])

            }else{
                panel.lines(rl, rep(i,2), col="black")
            }
			
        }
    }
    if(!is.null(refline))
        panel.abline(v=refline)
}
<bytecode: 0x1db59b50>
<environment: namespace:flowViz>
 --- function search by body ---
Function panel.densityplot.flowset.stack in namespace flowViz has this body.
 ----------- END OF FAILURE REPORT -------------- 
Fatal error: the condition has length > 1
