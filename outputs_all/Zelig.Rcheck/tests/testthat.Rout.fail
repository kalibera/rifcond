
R Under development (unstable) (2018-10-04 r75396) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(AER)
Loading required package: car
Loading required package: carData
Loading required package: lmtest
Loading required package: zoo

Attaching package: 'zoo'

The following objects are masked from 'package:base':

    as.Date, as.Date.numeric

Loading required package: sandwich
Loading required package: survival
> library(dplyr)

Attaching package: 'dplyr'

The following object is masked from 'package:car':

    recode

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union

> library(geepack)
> library(survey)
Loading required package: grid
Loading required package: Matrix

Attaching package: 'survey'

The following object is masked from 'package:graphics':

    dotchart

> library(testthat)

Attaching package: 'testthat'

The following object is masked from 'package:dplyr':

    matches

> library(zeligverse)
+ Zelig       5.1.6        Date: 2018-10-09
+ ZeligChoice 0.9.6           R: 3.6.0
+ ZeligEI     0.1.2          OS: Fedora 27 (Twenty Seven)
+ Amelia      1.7.5         GUI: X11
+ MatchIt     3.0.2      Locale: C
+ WhatIf      1.5.9          TZ: America/Chicago
> 
> set.seed(123)
> test_check("Zelig")
-- Imputation 1 --

  1  2  3

-- Imputation 2 --

  1  2  3

-- Imputation 3 --

  1  2  3

-- Imputation 4 --

  1  2  3

-- Imputation 5 --

  1  2  3

How to cite this model in Zelig:
  R Core Team. 2007.
  ls: Least Squares Regression for Continuous Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
-- Imputation 1 --

  1  2

-- Imputation 2 --

  1  2  3

-- Imputation 3 --

  1  2

-- Imputation 4 --

  1  2  3

-- Imputation 5 --

  1  2

How to cite this model in Zelig:
  R Core Team. 2007.
  ls: Least Squares Regression for Continuous Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  R Core Team. 2007.
  ls: Least Squares Regression for Continuous Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  James Honaker. 2018.
  arima: Autoregressive Moving-Average Models for Time-Series Data
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  James Honaker. 2018.
  arima: Autoregressive Moving-Average Models for Time-Series Data
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/

 sim x :
 -----
ev
         mean       sd      50%     2.5%    97.5%
[1,] 71.84089 125.7108 45.07644 14.44789 300.5451
pv
         mean       sd      50%     2.5%    97.5%
[1,] 71.82691 125.7453 44.93173 14.39416 301.4845
fd
         mean       sd      50%      2.5%    97.5%
[1,] 46.72488 333.1546 7.806861 -2.343672 192.7132
How to cite this model in Zelig:
  James Honaker. 2018.
  arima: Autoregressive Moving-Average Models for Time-Series Data
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  James Honaker. 2018.
  arima: Autoregressive Moving-Average Models for Time-Series Data
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  Ben Goodrich, and Ying Lu. 2013.
  normal-bayes: Bayesian Normal Linear Regression
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2013.
  factor-bayes: Bayesian Factor Analysis
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  Terry M. Therneau, and Thomas Lumley. 2011.
  exp: Exponential Regression for Duration Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  R Core Team. 2007.
  gamma: Gamma Regression for Continuous, Positive Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  R Core Team. 2007.
  ls: Least Squares Regression for Continuous Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  R Core Team. 2007.
  ls: Least Squares Regression for Continuous Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  R Core Team. 2007.
  ls: Least Squares Regression for Continuous Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  R Core Team. 2007.
  ls: Least Squares Regression for Continuous Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  R Core Team. 2007.
  ls: Least Squares Regression for Continuous Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
How to cite this model in Zelig:
  R Core Team. 2007.
  ls: Least Squares Regression for Continuous Dependent Variables
  in Christine Choirat, Christopher Gandrud, James Honaker, Kosuke Imai, Gary King, and Olivia Lau,
  "Zelig: Everyone's Statistical Software," http://zeligproject.org/
Calculating MLEs and large sample var-cov matrix.
This may take a moment...
Inverting Hessian to get large sample var-cov matrix.
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpWAZ5eY/R.INSTALL2a5020928d4c/MCMCpack/R/MCMCmnl.R#573: 
 --- package (from environment) --- 
MCMCpack
 --- call from context --- 
MCMCpack::MCMCmnl(formula = vote88 ~ pristr + othcok + othsocok, 
    verbose = FALSE, data = as.data.frame(.))
 --- call from argument --- 
if (mcmc.method == "RWM") {
    auto.Scythe.call(output.object = "posterior", cc.fun.name = "MCMCmnlMH", 
        sample.nonconst = sample, Y = Y, X = X, burnin = as.integer(burnin), 
        mcmc = as.integer(mcmc), thin = as.integer(thin), tune = tune, 
        lecuyer = as.integer(lecuyer), seedarray = as.integer(seed.array), 
        lecuyerstream = as.integer(lecuyer.stream), verbose = as.integer(verbose), 
        betastart = beta.start, betamode = beta.mode, b0 = b0, 
        B0 = B0, V = V, RW = as.integer(1), tdf = as.double(tdf))
    output <- form.mcmc.object(posterior, names = xnames, title = "MCMCmnl Posterior Sample")
} else if (mcmc.method == "IndMH") {
    auto.Scythe.call(output.object = "posterior", cc.fun.name = "MCMCmnlMH", 
        sample.nonconst = sample, Y = Y, X = X, burnin = as.integer(burnin), 
        mcmc = as.integer(mcmc), thin = as.integer(thin), tune = tune, 
        lecuyer = as.integer(lecuyer), seedarray = as.integer(seed.array), 
        lecuyerstream = as.integer(lecuyer.stream), verbose = as.integer(verbose), 
        betastart = beta.start, betamode = beta.mode, b0 = b0, 
        B0 = B0, V = V, RW = as.integer(0), tdf = as.double(tdf))
    output <- form.mcmc.object(posterior, names = xnames, title = "MCMCmnl Posterior Sample")
} else if (mcmc.method == "slice") {
    auto.Scythe.call(output.object = "posterior", cc.fun.name = "MCMCmnlslice", 
        sample.nonconst = sample, Y = Y, X = X, burnin = as.integer(burnin), 
        mcmc = as.integer(mcmc), thin = as.integer(thin), lecuyer = as.integer(lecuyer), 
        seedarray = as.integer(seed.array), lecuyerstream = as.integer(lecuyer.stream), 
        verbose = as.integer(verbose), betastart = beta.start, 
        b0 = b0, B0 = B0, V = V)
    output <- form.mcmc.object(posterior, names = xnames, title = "MCMCmnl Posterior Sample")
}
 --- R stacktrace ---
where 1: MCMCpack::MCMCmnl(formula = vote88 ~ pristr + othcok + othsocok, 
    verbose = FALSE, data = as.data.frame(.))
where 2: eval(fn2(.self$model.call, quote(as.data.frame(.))))
where 3 at /var/scratch2/tomas/tmp/RtmpCNyMli/R.INSTALL1f046ceb3c8/rlang/R/lifecycle-retired.R#213: eval(fn2(.self$model.call, quote(as.data.frame(.))))
where 4 at /var/scratch2/tomas/tmp/RtmpKwqGWq/R.INSTALLa2e82c5d61be/dplyr/R/grouped-df.r#223: overscope_eval_next(overscope, args[[j]])
where 5 at /var/scratch2/tomas/tmp/RtmpKwqGWq/R.INSTALLa2e82c5d61be/dplyr/R/do.r#84: do.grouped_df(., z.out = eval(fn2(.self$model.call, quote(as.data.frame(.)))))
where 6: do(., z.out = eval(fn2(.self$model.call, quote(as.data.frame(.)))))
where 7 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/freduce.R#20: function_list[[k]](value)
where 8 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/freduce.R#20: withVisible(function_list[[k]](value))
where 9 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/pipe.R#28: freduce(value, `_function_list`)
where 10: `_fseq`(`_lhs`)
where 11: eval(quote(`_fseq`(`_lhs`)), env, env)
where 12 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/pipe.R#44: eval(quote(`_fseq`(`_lhs`)), env, env)
where 13 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/pipe.R#44: withVisible(eval(quote(`_fseq`(`_lhs`)), env, env))
where 14 at /var/scratch2/tomas/tmp/Rtmp5LHDzM/R.INSTALL585b736a4183/Zelig/R/model-zelig.R#502: .self$data %>% group_by_(.self$by) %>% do(z.out = eval(fn2(.self$model.call, 
    quote(as.data.frame(.)))))
where 15 at /var/scratch2/tomas/tmp/Rtmp5LHDzM/R.INSTALL585b736a4183/Zelig/R/model-bayes.R#37: callSuper(formula = formula, data = data, ..., by = by, bootstrap = FALSE)
where 16: z5$zelig(formula = vote88 ~ pristr + othcok + othsocok, data = mexico, 
    verbose = FALSE)
where 17: eval(mf, environment())
where 18 at /var/scratch2/tomas/tmp/Rtmp5LHDzM/R.INSTALL585b736a4183/Zelig/R/wrappers.R#124: eval(mf, environment())
where 19: doTryCatch(return(expr), name, parentenv, handler)
where 20: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 21: tryCatchList(expr, classes, parentenv, handlers)
where 22: tryCatch(expr, error = function(e) {
    call <- conditionCall(e)
    if (!is.null(call)) {
        if (identical(call[[1L]], quote(doTryCatch))) 
            call <- sys.call(-4L)
        dcall <- deparse(call)[1L]
        prefix <- paste("Error in", dcall, ": ")
        LONG <- 75L
        sm <- strsplit(conditionMessage(e), "\n")[[1L]]
        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")
        if (is.na(w)) 
            w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
                type = "b")
        if (w > LONG) 
            prefix <- paste0(prefix, "\n  ")
    }
    else prefix <- "Error : "
    msg <- paste0(prefix, conditionMessage(e), "\n")
    .Internal(seterrmessage(msg[1L]))
    if (!silent && isTRUE(getOption("show.error.messages"))) {
        cat(msg, file = outFile)
        .Internal(printDeferredWarnings())
    }
    invisible(structure(msg, class = "try-error", condition = e))
})
where 23 at /var/scratch2/tomas/tmp/Rtmp5LHDzM/R.INSTALL585b736a4183/Zelig/R/wrappers.R#124: try(eval(mf, environment()), silent = TRUE)
where 24: zelig(vote88 ~ pristr + othcok + othsocok, model = "mlogit.bayes", 
    data = mexico, verbose = FALSE)
where 25: eval(lhs, parent, parent)
where 26 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/pipe.R#41: eval(lhs, parent, parent)
where 27 at testthat/test-interface.R#74: zelig(vote88 ~ pristr + othcok + othsocok, model = "mlogit.bayes", 
    data = mexico, verbose = FALSE) %>% setx() %>% sim() %>% 
    zelig_qi_to_df()
where 28: eval(code, test_env)
where 29 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-that.R#152: eval(code, test_env)
where 30 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-that.R#149: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error)
where 31: doTryCatch(return(expr), name, parentenv, handler)
where 32: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 33: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 34: doTryCatch(return(expr), name, parentenv, handler)
where 35: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
    names[nh], parentenv, handlers[[nh]])
where 36: tryCatchList(expr, classes, parentenv, handlers)
where 37 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-that.R#149: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error), error = handle_fatal, 
    skip = function(e) {
    })
where 38 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-that.R#31: test_code(desc, code, env = parent.frame())
where 39 at testthat/test-interface.R#70: test_that("REQUIRE TEST zelig_qi_to_df multinomial outcome", 
    {
        library(dplyr)
        set.seed(123)
        data(mexico)
        sims1_setx <- zelig(vote88 ~ pristr + othcok + othsocok, 
            model = "mlogit.bayes", data = mexico, verbose = FALSE) %>% 
            setx() %>% sim() %>% zelig_qi_to_df()
        sims1_setrange <- zelig(vote88 ~ pristr + othcok + othsocok, 
            model = "mlogit.bayes", data = mexico, verbose = FALSE) %>% 
            setx(pristr = 1:3) %>% sim() %>% zelig_qi_to_df()
        expected_col_names <- c("setx_value", "pristr", "othcok", 
            "othsocok", "expected_P(Y=1)", "expected_P(Y=2)", 
            "expected_P(Y=3)", "predicted_value")
        expect_equal(names(sims1_setx), expected_col_names)
        expect_equal(names(sims1_setrange), expected_col_names)
        slimmed_setx <- qi_slimmer(sims1_setx, qi_type = "expected_P(Y=2)")
        expect_lt(slimmed_setx$qi_ci_median, 0.25)
        slimmed_setrange <- qi_slimmer(sims1_setrange, qi_type = "predicted_value")
        expected_sr_colnames <- c("setx_value", "pristr", "othcok", 
            "othsocok", "predicted_proportion_(Y=1)", "predicted_proportion_(Y=2)", 
            "predicted_proportion_(Y=3)")
        expect_equal(names(slimmed_setrange), expected_sr_colnames)
    })
where 40: eval(code, test_env)
where 41 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-that.R#152: eval(code, test_env)
where 42 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-that.R#149: withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error)
where 43: doTryCatch(return(expr), name, parentenv, handler)
where 44: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 45: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
where 46: doTryCatch(return(expr), name, parentenv, handler)
where 47: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
    names[nh], parentenv, handlers[[nh]])
where 48: tryCatchList(expr, classes, parentenv, handlers)
where 49 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-that.R#149: tryCatch(withCallingHandlers({
    eval(code, test_env)
    if (!handled && !is.null(test)) {
        skip_empty()
    }
}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning, 
    message = handle_message, error = handle_error), error = handle_fatal, 
    skip = function(e) {
    })
where 50 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/source.R#42: test_code(NULL, exprs, env)
where 51 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-files.R#131: source_file(path, new.env(parent = env), chdir = TRUE, wrap = wrap)
where 52 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/reporter-zzz.R#53: force(code)
where 53 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-files.R#125: with_reporter(reporter = reporter, start_end_reporter = start_end_reporter, 
    {
        lister$start_file(basename(path))
        source_file(path, new.env(parent = env), chdir = TRUE, 
            wrap = wrap)
        end_context()
    })
where 54: FUN(X[[i]], ...)
where 55 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-files.R#25: lapply(paths, test_file, env = env, reporter = current_reporter, 
    start_end_reporter = FALSE, load_helpers = FALSE, wrap = wrap)
where 56 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/reporter-zzz.R#53: force(code)
where 57 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-files.R#25: with_reporter(reporter = current_reporter, results <- lapply(paths, 
    test_file, env = env, reporter = current_reporter, start_end_reporter = FALSE, 
    load_helpers = FALSE, wrap = wrap))
where 58 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-directory.R#86: test_files(paths, reporter = reporter, env = env, stop_on_failure = stop_on_failure, 
    stop_on_warning = stop_on_warning, wrap = wrap)
where 59 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-directory.R#190: test_dir(path = test_path, reporter = reporter, env = env, filter = filter, 
    ..., stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning, 
    wrap = wrap)
where 60 at /var/scratch2/tomas/tmp/RtmpLjy9nM/R.INSTALL2049131c71f5/testthat/R/test-directory.R#171: test_package_dir(package = package, test_path = test_path, filter = filter, 
    reporter = reporter, ..., stop_on_failure = stop_on_failure, 
    stop_on_warning = stop_on_warning, wrap = wrap)
where 61: test_check("Zelig")

 --- value of length: 3 type: logical ---
[1] FALSE  TRUE FALSE
 --- function from context --- 
function(formula, baseline=NULL, data=NULL,
           burnin = 1000, mcmc = 10000, thin=1,
           mcmc.method = c("IndMH", "RWM", "slice"),
           tune = 1.0, tdf=6, verbose = 0, seed = NA,
           beta.start = NA, b0 = 0, B0 = 0, ...) {

    ## checks
    check.offset(list(...))
    check.mcmc.parameters(burnin, mcmc, thin)
    if (tdf <= 0){
      stop("degrees of freedom for multivariate-t proposal must be positive.\n Respecify tdf and try again.\n")
    }

    ## seeds
    seeds <- form.seeds(seed)
    lecuyer <- seeds[[1]]
    seed.array <- seeds[[2]]
    lecuyer.stream <- seeds[[3]]

    ## form response and model matrix
    holder <- parse.formula.mnl(formula=formula, baseline=baseline,
                                data=data)
    Y <- holder[[1]]
    ## check to make sure baseline category is always available in choiceset
    if (is.null(baseline)){
      if (max(Y[,1] == -999) == 1){
        stop("Baseline choice not available in all choicesets.\n Respecify baseline category and try again.\n")
      }
    }
    else{
      if (max(Y[,baseline] == -999) == 1){
        stop("Baseline choice not available in all choicesets.\n Respecify baseline category and try again.\n")
      }
    }
    X <- holder[[2]]
    xnames <- holder[[3]]
    xobs <- holder[[4]]
    number.choices <- holder[[5]]
    K <- ncol(X)  # number of covariates

    ## form the tuning parameter
    tune <- vector.tune(tune, K)

    ## priors and starting values
    mvn.prior <- form.mvn.prior(b0, B0, K)
    b0 <- mvn.prior[[1]]
    B0 <- mvn.prior[[2]]

    beta.init <- rep(0, K)
    cat("Calculating MLEs and large sample var-cov matrix.\n")
    cat("This may take a moment...\n")
    if (max(is.na(Y))){
      optim.out <- optim(beta.init, mnl.logpost.NA, method="BFGS",
                         control=list(fnscale=-1),
                         hessian=TRUE, Y=Y, X=X, b0=b0, B0=B0)
    }
    else{
      new.Y <- apply(Y==1, 1, which)
      optim.out <- optim(beta.init, mnl.logpost.noNA, method="BFGS",
                         control=list(fnscale=-1),
                         hessian=TRUE, new.Y=new.Y, X=X, b0=b0, B0=B0)
    }
    cat("Inverting Hessian to get large sample var-cov matrix.\n")
    ##V <- solve(-1*optim.out$hessian)
    V <- chol2inv(chol(-1*optim.out$hessian))
    beta.mode <- matrix(optim.out$par, K, 1)


    if (is.na(beta.start) || is.null(beta.start)){
      beta.start <- matrix(optim.out$par, K, 1)
    }
    else if(is.null(dim(beta.start))) {
      beta.start <- matrix(beta.start, K, 1)
    }
    else if (length(beta.start != K)){
      stop("beta.start not of appropriate dimension\n")
    }

    ## define holder for posterior sample
    sample <- matrix(data=0, mcmc/thin, dim(X)[2] )
    posterior <- NULL

    if (mcmc.method=="RWM"){
      ## call C++ code to draw sample
      auto.Scythe.call(output.object="posterior", cc.fun.name="MCMCmnlMH",
                       sample.nonconst=sample, Y=Y, X=X,
                       burnin=as.integer(burnin),
                       mcmc=as.integer(mcmc), thin=as.integer(thin),
                       tune=tune, lecuyer=as.integer(lecuyer),
                       seedarray=as.integer(seed.array),
                       lecuyerstream=as.integer(lecuyer.stream),
                       verbose=as.integer(verbose),
                       betastart=beta.start, betamode=beta.mode,
                       b0=b0, B0=B0,
                       V=V, RW=as.integer(1), tdf=as.double(tdf))

      ## put together matrix and build MCMC object to return
      output <- form.mcmc.object(posterior, names=xnames,
                                 title="MCMCmnl Posterior Sample")
    }
    else if (mcmc.method=="IndMH"){
      auto.Scythe.call(output.object="posterior", cc.fun.name="MCMCmnlMH",
                       sample.nonconst=sample, Y=Y, X=X,
                       burnin=as.integer(burnin),
                       mcmc=as.integer(mcmc), thin=as.integer(thin),
                       tune=tune, lecuyer=as.integer(lecuyer),
                       seedarray=as.integer(seed.array),
                       lecuyerstream=as.integer(lecuyer.stream),
                       verbose=as.integer(verbose),
                       betastart=beta.start, betamode=beta.mode,
                       b0=b0, B0=B0,
                       V=V, RW=as.integer(0), tdf=as.double(tdf))

      ## put together matrix and build MCMC object to return
      output <- form.mcmc.object(posterior, names=xnames,
                                 title="MCMCmnl Posterior Sample")

    }
    else if (mcmc.method=="slice"){
      ## call C++ code to draw sample
      auto.Scythe.call(output.object="posterior", cc.fun.name="MCMCmnlslice",
                       sample.nonconst=sample, Y=Y, X=X,
                       burnin=as.integer(burnin),
                       mcmc=as.integer(mcmc), thin=as.integer(thin),
                       lecuyer=as.integer(lecuyer),
                       seedarray=as.integer(seed.array),
                       lecuyerstream=as.integer(lecuyer.stream),
                       verbose=as.integer(verbose), betastart=beta.start,
                       b0=b0, B0=B0, V=V)

      ## put together matrix and build MCMC object to return
      output <- form.mcmc.object(posterior, names=xnames,
                                 title="MCMCmnl Posterior Sample")

    }

    return(output)

  }
<bytecode: 0x207ed260>
<environment: namespace:MCMCpack>
 --- function search by body ---
Function MCMCmnl in namespace MCMCpack has this body.
 ----------- END OF FAILURE REPORT -------------- 
Fatal error: the condition has length > 1
