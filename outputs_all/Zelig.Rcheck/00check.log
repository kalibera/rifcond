* using log directory ‘/var/scratch2/tomas/test/mine/R-svn-dev-75396/check/Zelig.Rcheck’
* using R Under development (unstable) (2018-10-04 r75396)
* using platform: x86_64-pc-linux-gnu (64-bit)
* using session charset: UTF-8
* checking for file ‘Zelig/DESCRIPTION’ ... OK
* this is package ‘Zelig’ version ‘5.1.6’
* checking package namespace information ... OK
* checking package dependencies ... OK
* checking if this is a source package ... OK
* checking if there is a namespace ... OK
* checking for executable files ... OK
* checking for hidden files and directories ... OK
* checking for portable file names ... OK
* checking for sufficient/correct file permissions ... OK
* checking whether package ‘Zelig’ can be installed ... OK
* checking package directory ... OK
* checking DESCRIPTION meta-information ... OK
* checking top-level files ... OK
* checking for left-over files ... OK
* checking index information ... OK
* checking package subdirectories ... OK
* checking R files for non-ASCII characters ... OK
* checking R files for syntax errors ... OK
* checking whether the package can be loaded ... OK
* checking whether the package can be loaded with stated dependencies ... OK
* checking whether the package can be unloaded cleanly ... OK
* checking whether the namespace can be loaded with stated dependencies ... OK
* checking whether the namespace can be unloaded cleanly ... OK
* checking loading without being on the library search path ... OK
* checking dependencies in R code ... OK
* checking S3 generic/method consistency ... OK
* checking replacement functions ... OK
* checking foreign function calls ... OK
* checking R code for possible problems ... OK
* checking Rd files ... OK
* checking Rd metadata ... OK
* checking Rd cross-references ... OK
* checking for missing documentation entries ... OK
* checking for code/documentation mismatches ... OK
* checking Rd \usage sections ... OK
* checking Rd contents ... OK
* checking for unstated dependencies in examples ... OK
* checking contents of ‘data’ directory ... OK
* checking data for non-ASCII characters ... OK
* checking data for ASCII and uncompressed saves ... OK
* checking examples ... ERROR
Running examples in ‘Zelig-Ex.R’ failed
The error most likely occurred in:

> ### Name: Zelig-mlogit-bayes-class
> ### Title: Bayesian Multinomial Logistic Regression
> ### Aliases: Zelig-mlogit-bayes-class zmlogitbayes
> 
> ### ** Examples
> 
> data(mexico)
> z.out <- zelig(vote88 ~ pristr + othcok + othsocok,model = "mlogit.bayes",
+ data = mexico,verbose = FALSE)
Calculating MLEs and large sample var-cov matrix.
This may take a moment...
Inverting Hessian to get large sample var-cov matrix.
 ----------- FAILURE REPORT -------------- 
 --- srcref --- 
 at /var/scratch2/tomas/tmp/RtmpWAZ5eY/R.INSTALL2a5020928d4c/MCMCpack/R/MCMCmnl.R#573: 
 --- package (from environment) --- 
MCMCpack
 --- call from context --- 
MCMCpack::MCMCmnl(formula = vote88 ~ pristr + othcok + othsocok, 
    verbose = FALSE, data = as.data.frame(.))
 --- call from argument --- 
if (mcmc.method == "RWM") {
    auto.Scythe.call(output.object = "posterior", cc.fun.name = "MCMCmnlMH", 
        sample.nonconst = sample, Y = Y, X = X, burnin = as.integer(burnin), 
        mcmc = as.integer(mcmc), thin = as.integer(thin), tune = tune, 
        lecuyer = as.integer(lecuyer), seedarray = as.integer(seed.array), 
        lecuyerstream = as.integer(lecuyer.stream), verbose = as.integer(verbose), 
        betastart = beta.start, betamode = beta.mode, b0 = b0, 
        B0 = B0, V = V, RW = as.integer(1), tdf = as.double(tdf))
    output <- form.mcmc.object(posterior, names = xnames, title = "MCMCmnl Posterior Sample")
} else if (mcmc.method == "IndMH") {
    auto.Scythe.call(output.object = "posterior", cc.fun.name = "MCMCmnlMH", 
        sample.nonconst = sample, Y = Y, X = X, burnin = as.integer(burnin), 
        mcmc = as.integer(mcmc), thin = as.integer(thin), tune = tune, 
        lecuyer = as.integer(lecuyer), seedarray = as.integer(seed.array), 
        lecuyerstream = as.integer(lecuyer.stream), verbose = as.integer(verbose), 
        betastart = beta.start, betamode = beta.mode, b0 = b0, 
        B0 = B0, V = V, RW = as.integer(0), tdf = as.double(tdf))
    output <- form.mcmc.object(posterior, names = xnames, title = "MCMCmnl Posterior Sample")
} else if (mcmc.method == "slice") {
    auto.Scythe.call(output.object = "posterior", cc.fun.name = "MCMCmnlslice", 
        sample.nonconst = sample, Y = Y, X = X, burnin = as.integer(burnin), 
        mcmc = as.integer(mcmc), thin = as.integer(thin), lecuyer = as.integer(lecuyer), 
        seedarray = as.integer(seed.array), lecuyerstream = as.integer(lecuyer.stream), 
        verbose = as.integer(verbose), betastart = beta.start, 
        b0 = b0, B0 = B0, V = V)
    output <- form.mcmc.object(posterior, names = xnames, title = "MCMCmnl Posterior Sample")
}
 --- R stacktrace ---
where 1: MCMCpack::MCMCmnl(formula = vote88 ~ pristr + othcok + othsocok, 
    verbose = FALSE, data = as.data.frame(.))
where 2: eval(fn2(.self$model.call, quote(as.data.frame(.))))
where 3 at /var/scratch2/tomas/tmp/RtmpCNyMli/R.INSTALL1f046ceb3c8/rlang/R/lifecycle-retired.R#213: eval(fn2(.self$model.call, quote(as.data.frame(.))))
where 4 at /var/scratch2/tomas/tmp/RtmpKwqGWq/R.INSTALLa2e82c5d61be/dplyr/R/grouped-df.r#223: overscope_eval_next(overscope, args[[j]])
where 5 at /var/scratch2/tomas/tmp/RtmpKwqGWq/R.INSTALLa2e82c5d61be/dplyr/R/do.r#84: do.grouped_df(., z.out = eval(fn2(.self$model.call, quote(as.data.frame(.)))))
where 6: do(., z.out = eval(fn2(.self$model.call, quote(as.data.frame(.)))))
where 7 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/freduce.R#20: function_list[[k]](value)
where 8 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/freduce.R#20: withVisible(function_list[[k]](value))
where 9 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/pipe.R#28: freduce(value, `_function_list`)
where 10: `_fseq`(`_lhs`)
where 11: eval(quote(`_fseq`(`_lhs`)), env, env)
where 12 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/pipe.R#44: eval(quote(`_fseq`(`_lhs`)), env, env)
where 13 at /var/scratch2/tomas/tmp/RtmpEYWWs3/R.INSTALL84ff4a49f903/magrittr/R/pipe.R#44: withVisible(eval(quote(`_fseq`(`_lhs`)), env, env))
where 14 at /var/scratch2/tomas/tmp/Rtmp5LHDzM/R.INSTALL585b736a4183/Zelig/R/model-zelig.R#502: .self$data %>% group_by_(.self$by) %>% do(z.out = eval(fn2(.self$model.call, 
    quote(as.data.frame(.)))))
where 15 at /var/scratch2/tomas/tmp/Rtmp5LHDzM/R.INSTALL585b736a4183/Zelig/R/model-bayes.R#37: callSuper(formula = formula, data = data, ..., by = by, bootstrap = FALSE)
where 16: z5$zelig(formula = vote88 ~ pristr + othcok + othsocok, data = mexico, 
    verbose = FALSE)
where 17: eval(mf, environment())
where 18 at /var/scratch2/tomas/tmp/Rtmp5LHDzM/R.INSTALL585b736a4183/Zelig/R/wrappers.R#124: eval(mf, environment())
where 19: doTryCatch(return(expr), name, parentenv, handler)
where 20: tryCatchOne(expr, names, parentenv, handlers[[1L]])
where 21: tryCatchList(expr, classes, parentenv, handlers)
where 22: tryCatch(expr, error = function(e) {
    call <- conditionCall(e)
    if (!is.null(call)) {
        if (identical(call[[1L]], quote(doTryCatch))) 
            call <- sys.call(-4L)
        dcall <- deparse(call)[1L]
        prefix <- paste("Error in", dcall, ": ")
        LONG <- 75L
        sm <- strsplit(conditionMessage(e), "\n")[[1L]]
        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")
        if (is.na(w)) 
            w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
                type = "b")
        if (w > LONG) 
            prefix <- paste0(prefix, "\n  ")
    }
    else prefix <- "Error : "
    msg <- paste0(prefix, conditionMessage(e), "\n")
    .Internal(seterrmessage(msg[1L]))
    if (!silent && isTRUE(getOption("show.error.messages"))) {
        cat(msg, file = outFile)
        .Internal(printDeferredWarnings())
    }
    invisible(structure(msg, class = "try-error", condition = e))
})
where 23 at /var/scratch2/tomas/tmp/Rtmp5LHDzM/R.INSTALL585b736a4183/Zelig/R/wrappers.R#124: try(eval(mf, environment()), silent = TRUE)
where 24: zelig(vote88 ~ pristr + othcok + othsocok, model = "mlogit.bayes", 
    data = mexico, verbose = FALSE)

 --- value of length: 3 type: logical ---
[1] FALSE  TRUE FALSE
 --- function from context --- 
function(formula, baseline=NULL, data=NULL,
           burnin = 1000, mcmc = 10000, thin=1,
           mcmc.method = c("IndMH", "RWM", "slice"),
           tune = 1.0, tdf=6, verbose = 0, seed = NA,
           beta.start = NA, b0 = 0, B0 = 0, ...) {

    ## checks
    check.offset(list(...))
    check.mcmc.parameters(burnin, mcmc, thin)
    if (tdf <= 0){
      stop("degrees of freedom for multivariate-t proposal must be positive.\n Respecify tdf and try again.\n")
    }

    ## seeds
    seeds <- form.seeds(seed)
    lecuyer <- seeds[[1]]
    seed.array <- seeds[[2]]
    lecuyer.stream <- seeds[[3]]

    ## form response and model matrix
    holder <- parse.formula.mnl(formula=formula, baseline=baseline,
                                data=data)
    Y <- holder[[1]]
    ## check to make sure baseline category is always available in choiceset
    if (is.null(baseline)){
      if (max(Y[,1] == -999) == 1){
        stop("Baseline choice not available in all choicesets.\n Respecify baseline category and try again.\n")
      }
    }
    else{
      if (max(Y[,baseline] == -999) == 1){
        stop("Baseline choice not available in all choicesets.\n Respecify baseline category and try again.\n")
      }
    }
    X <- holder[[2]]
    xnames <- holder[[3]]
    xobs <- holder[[4]]
    number.choices <- holder[[5]]
    K <- ncol(X)  # number of covariates

    ## form the tuning parameter
    tune <- vector.tune(tune, K)

    ## priors and starting values
    mvn.prior <- form.mvn.prior(b0, B0, K)
    b0 <- mvn.prior[[1]]
    B0 <- mvn.prior[[2]]

    beta.init <- rep(0, K)
    cat("Calculating MLEs and large sample var-cov matrix.\n")
    cat("This may take a moment...\n")
    if (max(is.na(Y))){
      optim.out <- optim(beta.init, mnl.logpost.NA, method="BFGS",
                         control=list(fnscale=-1),
                         hessian=TRUE, Y=Y, X=X, b0=b0, B0=B0)
    }
    else{
      new.Y <- apply(Y==1, 1, which)
      optim.out <- optim(beta.init, mnl.logpost.noNA, method="BFGS",
                         control=list(fnscale=-1),
                         hessian=TRUE, new.Y=new.Y, X=X, b0=b0, B0=B0)
    }
    cat("Inverting Hessian to get large sample var-cov matrix.\n")
    ##V <- solve(-1*optim.out$hessian)
    V <- chol2inv(chol(-1*optim.out$hessian))
    beta.mode <- matrix(optim.out$par, K, 1)


    if (is.na(beta.start) || is.null(beta.start)){
      beta.start <- matrix(optim.out$par, K, 1)
    }
    else if(is.null(dim(beta.start))) {
      beta.start <- matrix(beta.start, K, 1)
    }
    else if (length(beta.start != K)){
      stop("beta.start not of appropriate dimension\n")
    }

    ## define holder for posterior sample
    sample <- matrix(data=0, mcmc/thin, dim(X)[2] )
    posterior <- NULL

    if (mcmc.method=="RWM"){
      ## call C++ code to draw sample
      auto.Scythe.call(output.object="posterior", cc.fun.name="MCMCmnlMH",
                       sample.nonconst=sample, Y=Y, X=X,
                       burnin=as.integer(burnin),
                       mcmc=as.integer(mcmc), thin=as.integer(thin),
                       tune=tune, lecuyer=as.integer(lecuyer),
                       seedarray=as.integer(seed.array),
                       lecuyerstream=as.integer(lecuyer.stream),
                       verbose=as.integer(verbose),
                       betastart=beta.start, betamode=beta.mode,
                       b0=b0, B0=B0,
                       V=V, RW=as.integer(1), tdf=as.double(tdf))

      ## put together matrix and build MCMC object to return
      output <- form.mcmc.object(posterior, names=xnames,
                                 title="MCMCmnl Posterior Sample")
    }
    else if (mcmc.method=="IndMH"){
      auto.Scythe.call(output.object="posterior", cc.fun.name="MCMCmnlMH",
                       sample.nonconst=sample, Y=Y, X=X,
                       burnin=as.integer(burnin),
                       mcmc=as.integer(mcmc), thin=as.integer(thin),
                       tune=tune, lecuyer=as.integer(lecuyer),
                       seedarray=as.integer(seed.array),
                       lecuyerstream=as.integer(lecuyer.stream),
                       verbose=as.integer(verbose),
                       betastart=beta.start, betamode=beta.mode,
                       b0=b0, B0=B0,
                       V=V, RW=as.integer(0), tdf=as.double(tdf))

      ## put together matrix and build MCMC object to return
      output <- form.mcmc.object(posterior, names=xnames,
                                 title="MCMCmnl Posterior Sample")

    }
    else if (mcmc.method=="slice"){
      ## call C++ code to draw sample
      auto.Scythe.call(output.object="posterior", cc.fun.name="MCMCmnlslice",
                       sample.nonconst=sample, Y=Y, X=X,
                       burnin=as.integer(burnin),
                       mcmc=as.integer(mcmc), thin=as.integer(thin),
                       lecuyer=as.integer(lecuyer),
                       seedarray=as.integer(seed.array),
                       lecuyerstream=as.integer(lecuyer.stream),
                       verbose=as.integer(verbose), betastart=beta.start,
                       b0=b0, B0=B0, V=V)

      ## put together matrix and build MCMC object to return
      output <- form.mcmc.object(posterior, names=xnames,
                                 title="MCMCmnl Posterior Sample")

    }

    return(output)

  }
<bytecode: 0x1aa2db78>
<environment: namespace:MCMCpack>
 --- function search by body ---
Function MCMCmnl in namespace MCMCpack has this body.
 ----------- END OF FAILURE REPORT -------------- 
Fatal error: the condition has length > 1
* checking for unstated dependencies in ‘tests’ ... OK
* checking tests ... ERROR
  Running ‘testthat.R’
Running the tests in ‘tests/testthat.R’ failed.
Last 13 lines of output:
        ## put together matrix and build MCMC object to return
        output <- form.mcmc.object(posterior, names=xnames,
                                   title="MCMCmnl Posterior Sample")
  
      }
  
      return(output)
  
    }
  <bytecode: 0x207ed260>
  <environment: namespace:MCMCpack>
   --- function search by body ---
  Function MCMCmnl in namespace MCMCpack has this body.
   ----------- END OF FAILURE REPORT -------------- 
  Fatal error: the condition has length > 1
* checking PDF version of manual ... OK
* DONE
Status: 2 ERRORs
